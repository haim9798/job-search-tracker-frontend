{"ast":null,"code":"import{PositionStatus,InterviewType,InterviewPlace,InterviewOutcome}from'./index';// Validation schema types\n// Position validation schema\nexport const positionValidationSchema={title:{required:true,minLength:2,maxLength:200},company:{required:true,minLength:2,maxLength:100},description:{maxLength:2000},location:{maxLength:100},salary_range:{maxLength:50},status:{required:true,custom:value=>{if(!Object.values(PositionStatus).includes(value)){return'Invalid position status';}return null;}},application_date:{required:true,custom:value=>{const date=new Date(value);if(isNaN(date.getTime())){return'Invalid date format';}if(date>new Date()){return'Application date cannot be in the future';}return null;}}};// Interview validation schema\nexport const interviewValidationSchema={type:{required:true,custom:value=>{if(!Object.values(InterviewType).includes(value)){return'Invalid interview type';}return null;}},place:{required:true,custom:value=>{if(!Object.values(InterviewPlace).includes(value)){return'Invalid interview place';}return null;}},scheduled_date:{required:true,custom:value=>{const date=new Date(value);if(isNaN(date.getTime())){return'Invalid date format';}return null;}},duration_minutes:{custom:value=>{if(value!==undefined&&value!==null){const num=Number(value);if(isNaN(num)||num<0||num>480){return'Duration must be between 0 and 480 minutes';}}return null;}},notes:{maxLength:2000},outcome:{required:true,custom:value=>{if(!Object.values(InterviewOutcome).includes(value)){return'Invalid interview outcome';}return null;}}};// User registration validation schema\nexport const registerValidationSchema={email:{required:true,pattern:/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,maxLength:254},password:{required:true,minLength:8,maxLength:128,custom:value=>{if(!/(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/.test(value)){return'Password must contain at least one lowercase letter, one uppercase letter, and one number';}return null;}},confirmPassword:{required:true,custom:(value,formData)=>{if(value!==(formData===null||formData===void 0?void 0:formData.password)){return'Passwords do not match';}return null;}},first_name:{required:true,minLength:1,maxLength:50,pattern:/^[a-zA-Z\\s'-]+$/},last_name:{required:true,minLength:1,maxLength:50,pattern:/^[a-zA-Z\\s'-]+$/}};// Login validation schema\nexport const loginValidationSchema={email:{required:true,pattern:/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/},password:{required:true,minLength:1}};// Validation utility functions\nexport const validateField=(value,rule,formData)=>{// Check required\nif(rule.required&&(value===undefined||value===null||value==='')){return'This field is required';}// Skip other validations if value is empty and not required\nif(!rule.required&&(value===undefined||value===null||value==='')){return null;}// Check minLength\nif(rule.minLength&&value.length<rule.minLength){return\"Minimum length is \".concat(rule.minLength,\" characters\");}// Check maxLength\nif(rule.maxLength&&value.length>rule.maxLength){return\"Maximum length is \".concat(rule.maxLength,\" characters\");}// Check pattern\nif(rule.pattern&&!rule.pattern.test(value)){return'Invalid format';}// Check custom validation\nif(rule.custom){return rule.custom(value,formData);}return null;};export const validateForm=(formData,schema)=>{const errors={};Object.keys(schema).forEach(field=>{const error=validateField(formData[field],schema[field],formData);if(error){errors[field]=error;}});return errors;};export const isFormValid=errors=>{return Object.keys(errors).length===0;};","map":{"version":3,"names":["PositionStatus","InterviewType","InterviewPlace","InterviewOutcome","positionValidationSchema","title","required","minLength","maxLength","company","description","location","salary_range","status","custom","value","Object","values","includes","application_date","date","Date","isNaN","getTime","interviewValidationSchema","type","place","scheduled_date","duration_minutes","undefined","num","Number","notes","outcome","registerValidationSchema","email","pattern","password","test","confirmPassword","formData","first_name","last_name","loginValidationSchema","validateField","rule","length","concat","validateForm","schema","errors","keys","forEach","field","error","isFormValid"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/types/validation.ts"],"sourcesContent":["import { PositionStatus, InterviewType, InterviewPlace, InterviewOutcome } from './index';\n\n// Validation schema types\nexport interface ValidationRule {\n  required?: boolean;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: RegExp;\n  custom?: (value: any, formData?: any) => string | null;\n}\n\nexport interface ValidationSchema {\n  [key: string]: ValidationRule;\n}\n\n// Position validation schema\nexport const positionValidationSchema: ValidationSchema = {\n  title: {\n    required: true,\n    minLength: 2,\n    maxLength: 200,\n  },\n  company: {\n    required: true,\n    minLength: 2,\n    maxLength: 100,\n  },\n  description: {\n    maxLength: 2000,\n  },\n  location: {\n    maxLength: 100,\n  },\n  salary_range: {\n    maxLength: 50,\n  },\n  status: {\n    required: true,\n    custom: (value) => {\n      if (!Object.values(PositionStatus).includes(value)) {\n        return 'Invalid position status';\n      }\n      return null;\n    },\n  },\n  application_date: {\n    required: true,\n    custom: (value) => {\n      const date = new Date(value);\n      if (isNaN(date.getTime())) {\n        return 'Invalid date format';\n      }\n      if (date > new Date()) {\n        return 'Application date cannot be in the future';\n      }\n      return null;\n    },\n  },\n};\n\n// Interview validation schema\nexport const interviewValidationSchema: ValidationSchema = {\n  type: {\n    required: true,\n    custom: (value) => {\n      if (!Object.values(InterviewType).includes(value)) {\n        return 'Invalid interview type';\n      }\n      return null;\n    },\n  },\n  place: {\n    required: true,\n    custom: (value) => {\n      if (!Object.values(InterviewPlace).includes(value)) {\n        return 'Invalid interview place';\n      }\n      return null;\n    },\n  },\n  scheduled_date: {\n    required: true,\n    custom: (value) => {\n      const date = new Date(value);\n      if (isNaN(date.getTime())) {\n        return 'Invalid date format';\n      }\n      return null;\n    },\n  },\n  duration_minutes: {\n    custom: (value) => {\n      if (value !== undefined && value !== null) {\n        const num = Number(value);\n        if (isNaN(num) || num < 0 || num > 480) {\n          return 'Duration must be between 0 and 480 minutes';\n        }\n      }\n      return null;\n    },\n  },\n  notes: {\n    maxLength: 2000,\n  },\n  outcome: {\n    required: true,\n    custom: (value) => {\n      if (!Object.values(InterviewOutcome).includes(value)) {\n        return 'Invalid interview outcome';\n      }\n      return null;\n    },\n  },\n};\n\n// User registration validation schema\nexport const registerValidationSchema: ValidationSchema = {\n  email: {\n    required: true,\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n    maxLength: 254,\n  },\n  password: {\n    required: true,\n    minLength: 8,\n    maxLength: 128,\n    custom: (value) => {\n      if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/.test(value)) {\n        return 'Password must contain at least one lowercase letter, one uppercase letter, and one number';\n      }\n      return null;\n    },\n  },\n  confirmPassword: {\n    required: true,\n    custom: (value, formData) => {\n      if (value !== formData?.password) {\n        return 'Passwords do not match';\n      }\n      return null;\n    },\n  },\n  first_name: {\n    required: true,\n    minLength: 1,\n    maxLength: 50,\n    pattern: /^[a-zA-Z\\s'-]+$/,\n  },\n  last_name: {\n    required: true,\n    minLength: 1,\n    maxLength: 50,\n    pattern: /^[a-zA-Z\\s'-]+$/,\n  },\n};\n\n// Login validation schema\nexport const loginValidationSchema: ValidationSchema = {\n  email: {\n    required: true,\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n  },\n  password: {\n    required: true,\n    minLength: 1,\n  },\n};\n\n// Validation utility functions\nexport const validateField = (\n  value: any,\n  rule: ValidationRule,\n  formData?: any\n): string | null => {\n  // Check required\n  if (rule.required && (value === undefined || value === null || value === '')) {\n    return 'This field is required';\n  }\n\n  // Skip other validations if value is empty and not required\n  if (!rule.required && (value === undefined || value === null || value === '')) {\n    return null;\n  }\n\n  // Check minLength\n  if (rule.minLength && value.length < rule.minLength) {\n    return `Minimum length is ${rule.minLength} characters`;\n  }\n\n  // Check maxLength\n  if (rule.maxLength && value.length > rule.maxLength) {\n    return `Maximum length is ${rule.maxLength} characters`;\n  }\n\n  // Check pattern\n  if (rule.pattern && !rule.pattern.test(value)) {\n    return 'Invalid format';\n  }\n\n  // Check custom validation\n  if (rule.custom) {\n    return rule.custom(value, formData);\n  }\n\n  return null;\n};\n\nexport const validateForm = (\n  formData: any,\n  schema: ValidationSchema\n): { [key: string]: string } => {\n  const errors: { [key: string]: string } = {};\n\n  Object.keys(schema).forEach((field) => {\n    const error = validateField(formData[field], schema[field], formData);\n    if (error) {\n      errors[field] = error;\n    }\n  });\n\n  return errors;\n};\n\nexport const isFormValid = (errors: { [key: string]: string }): boolean => {\n  return Object.keys(errors).length === 0;\n};"],"mappings":"AAAA,OAASA,cAAc,CAAEC,aAAa,CAAEC,cAAc,CAAEC,gBAAgB,KAAQ,SAAS,CAEzF;AAaA;AACA,MAAO,MAAM,CAAAC,wBAA0C,CAAG,CACxDC,KAAK,CAAE,CACLC,QAAQ,CAAE,IAAI,CACdC,SAAS,CAAE,CAAC,CACZC,SAAS,CAAE,GACb,CAAC,CACDC,OAAO,CAAE,CACPH,QAAQ,CAAE,IAAI,CACdC,SAAS,CAAE,CAAC,CACZC,SAAS,CAAE,GACb,CAAC,CACDE,WAAW,CAAE,CACXF,SAAS,CAAE,IACb,CAAC,CACDG,QAAQ,CAAE,CACRH,SAAS,CAAE,GACb,CAAC,CACDI,YAAY,CAAE,CACZJ,SAAS,CAAE,EACb,CAAC,CACDK,MAAM,CAAE,CACNP,QAAQ,CAAE,IAAI,CACdQ,MAAM,CAAGC,KAAK,EAAK,CACjB,GAAI,CAACC,MAAM,CAACC,MAAM,CAACjB,cAAc,CAAC,CAACkB,QAAQ,CAACH,KAAK,CAAC,CAAE,CAClD,MAAO,yBAAyB,CAClC,CACA,MAAO,KAAI,CACb,CACF,CAAC,CACDI,gBAAgB,CAAE,CAChBb,QAAQ,CAAE,IAAI,CACdQ,MAAM,CAAGC,KAAK,EAAK,CACjB,KAAM,CAAAK,IAAI,CAAG,GAAI,CAAAC,IAAI,CAACN,KAAK,CAAC,CAC5B,GAAIO,KAAK,CAACF,IAAI,CAACG,OAAO,CAAC,CAAC,CAAC,CAAE,CACzB,MAAO,qBAAqB,CAC9B,CACA,GAAIH,IAAI,CAAG,GAAI,CAAAC,IAAI,CAAC,CAAC,CAAE,CACrB,MAAO,0CAA0C,CACnD,CACA,MAAO,KAAI,CACb,CACF,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAG,yBAA2C,CAAG,CACzDC,IAAI,CAAE,CACJnB,QAAQ,CAAE,IAAI,CACdQ,MAAM,CAAGC,KAAK,EAAK,CACjB,GAAI,CAACC,MAAM,CAACC,MAAM,CAAChB,aAAa,CAAC,CAACiB,QAAQ,CAACH,KAAK,CAAC,CAAE,CACjD,MAAO,wBAAwB,CACjC,CACA,MAAO,KAAI,CACb,CACF,CAAC,CACDW,KAAK,CAAE,CACLpB,QAAQ,CAAE,IAAI,CACdQ,MAAM,CAAGC,KAAK,EAAK,CACjB,GAAI,CAACC,MAAM,CAACC,MAAM,CAACf,cAAc,CAAC,CAACgB,QAAQ,CAACH,KAAK,CAAC,CAAE,CAClD,MAAO,yBAAyB,CAClC,CACA,MAAO,KAAI,CACb,CACF,CAAC,CACDY,cAAc,CAAE,CACdrB,QAAQ,CAAE,IAAI,CACdQ,MAAM,CAAGC,KAAK,EAAK,CACjB,KAAM,CAAAK,IAAI,CAAG,GAAI,CAAAC,IAAI,CAACN,KAAK,CAAC,CAC5B,GAAIO,KAAK,CAACF,IAAI,CAACG,OAAO,CAAC,CAAC,CAAC,CAAE,CACzB,MAAO,qBAAqB,CAC9B,CACA,MAAO,KAAI,CACb,CACF,CAAC,CACDK,gBAAgB,CAAE,CAChBd,MAAM,CAAGC,KAAK,EAAK,CACjB,GAAIA,KAAK,GAAKc,SAAS,EAAId,KAAK,GAAK,IAAI,CAAE,CACzC,KAAM,CAAAe,GAAG,CAAGC,MAAM,CAAChB,KAAK,CAAC,CACzB,GAAIO,KAAK,CAACQ,GAAG,CAAC,EAAIA,GAAG,CAAG,CAAC,EAAIA,GAAG,CAAG,GAAG,CAAE,CACtC,MAAO,4CAA4C,CACrD,CACF,CACA,MAAO,KAAI,CACb,CACF,CAAC,CACDE,KAAK,CAAE,CACLxB,SAAS,CAAE,IACb,CAAC,CACDyB,OAAO,CAAE,CACP3B,QAAQ,CAAE,IAAI,CACdQ,MAAM,CAAGC,KAAK,EAAK,CACjB,GAAI,CAACC,MAAM,CAACC,MAAM,CAACd,gBAAgB,CAAC,CAACe,QAAQ,CAACH,KAAK,CAAC,CAAE,CACpD,MAAO,2BAA2B,CACpC,CACA,MAAO,KAAI,CACb,CACF,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAmB,wBAA0C,CAAG,CACxDC,KAAK,CAAE,CACL7B,QAAQ,CAAE,IAAI,CACd8B,OAAO,CAAE,4BAA4B,CACrC5B,SAAS,CAAE,GACb,CAAC,CACD6B,QAAQ,CAAE,CACR/B,QAAQ,CAAE,IAAI,CACdC,SAAS,CAAE,CAAC,CACZC,SAAS,CAAE,GAAG,CACdM,MAAM,CAAGC,KAAK,EAAK,CACjB,GAAI,CAAC,gCAAgC,CAACuB,IAAI,CAACvB,KAAK,CAAC,CAAE,CACjD,MAAO,2FAA2F,CACpG,CACA,MAAO,KAAI,CACb,CACF,CAAC,CACDwB,eAAe,CAAE,CACfjC,QAAQ,CAAE,IAAI,CACdQ,MAAM,CAAEA,CAACC,KAAK,CAAEyB,QAAQ,GAAK,CAC3B,GAAIzB,KAAK,IAAKyB,QAAQ,SAARA,QAAQ,iBAARA,QAAQ,CAAEH,QAAQ,EAAE,CAChC,MAAO,wBAAwB,CACjC,CACA,MAAO,KAAI,CACb,CACF,CAAC,CACDI,UAAU,CAAE,CACVnC,QAAQ,CAAE,IAAI,CACdC,SAAS,CAAE,CAAC,CACZC,SAAS,CAAE,EAAE,CACb4B,OAAO,CAAE,iBACX,CAAC,CACDM,SAAS,CAAE,CACTpC,QAAQ,CAAE,IAAI,CACdC,SAAS,CAAE,CAAC,CACZC,SAAS,CAAE,EAAE,CACb4B,OAAO,CAAE,iBACX,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAO,qBAAuC,CAAG,CACrDR,KAAK,CAAE,CACL7B,QAAQ,CAAE,IAAI,CACd8B,OAAO,CAAE,4BACX,CAAC,CACDC,QAAQ,CAAE,CACR/B,QAAQ,CAAE,IAAI,CACdC,SAAS,CAAE,CACb,CACF,CAAC,CAED;AACA,MAAO,MAAM,CAAAqC,aAAa,CAAGA,CAC3B7B,KAAU,CACV8B,IAAoB,CACpBL,QAAc,GACI,CAClB;AACA,GAAIK,IAAI,CAACvC,QAAQ,GAAKS,KAAK,GAAKc,SAAS,EAAId,KAAK,GAAK,IAAI,EAAIA,KAAK,GAAK,EAAE,CAAC,CAAE,CAC5E,MAAO,wBAAwB,CACjC,CAEA;AACA,GAAI,CAAC8B,IAAI,CAACvC,QAAQ,GAAKS,KAAK,GAAKc,SAAS,EAAId,KAAK,GAAK,IAAI,EAAIA,KAAK,GAAK,EAAE,CAAC,CAAE,CAC7E,MAAO,KAAI,CACb,CAEA;AACA,GAAI8B,IAAI,CAACtC,SAAS,EAAIQ,KAAK,CAAC+B,MAAM,CAAGD,IAAI,CAACtC,SAAS,CAAE,CACnD,2BAAAwC,MAAA,CAA4BF,IAAI,CAACtC,SAAS,gBAC5C,CAEA;AACA,GAAIsC,IAAI,CAACrC,SAAS,EAAIO,KAAK,CAAC+B,MAAM,CAAGD,IAAI,CAACrC,SAAS,CAAE,CACnD,2BAAAuC,MAAA,CAA4BF,IAAI,CAACrC,SAAS,gBAC5C,CAEA;AACA,GAAIqC,IAAI,CAACT,OAAO,EAAI,CAACS,IAAI,CAACT,OAAO,CAACE,IAAI,CAACvB,KAAK,CAAC,CAAE,CAC7C,MAAO,gBAAgB,CACzB,CAEA;AACA,GAAI8B,IAAI,CAAC/B,MAAM,CAAE,CACf,MAAO,CAAA+B,IAAI,CAAC/B,MAAM,CAACC,KAAK,CAAEyB,QAAQ,CAAC,CACrC,CAEA,MAAO,KAAI,CACb,CAAC,CAED,MAAO,MAAM,CAAAQ,YAAY,CAAGA,CAC1BR,QAAa,CACbS,MAAwB,GACM,CAC9B,KAAM,CAAAC,MAAiC,CAAG,CAAC,CAAC,CAE5ClC,MAAM,CAACmC,IAAI,CAACF,MAAM,CAAC,CAACG,OAAO,CAAEC,KAAK,EAAK,CACrC,KAAM,CAAAC,KAAK,CAAGV,aAAa,CAACJ,QAAQ,CAACa,KAAK,CAAC,CAAEJ,MAAM,CAACI,KAAK,CAAC,CAAEb,QAAQ,CAAC,CACrE,GAAIc,KAAK,CAAE,CACTJ,MAAM,CAACG,KAAK,CAAC,CAAGC,KAAK,CACvB,CACF,CAAC,CAAC,CAEF,MAAO,CAAAJ,MAAM,CACf,CAAC,CAED,MAAO,MAAM,CAAAK,WAAW,CAAIL,MAAiC,EAAc,CACzE,MAAO,CAAAlC,MAAM,CAACmC,IAAI,CAACD,MAAM,CAAC,CAACJ,MAAM,GAAK,CAAC,CACzC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}