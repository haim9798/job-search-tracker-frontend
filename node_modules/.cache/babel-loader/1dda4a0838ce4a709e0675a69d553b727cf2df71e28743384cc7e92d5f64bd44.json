{"ast":null,"code":"var _jsxFileName = \"/home/haim/github/job-search-tracker-api/frontend/src/providers/AuthProvider.tsx\",\n  _s = $RefreshSig$(),\n  _s2 = $RefreshSig$();\nimport React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { toast } from 'react-hot-toast';\nimport { authService } from '../services';\nimport { queryKeys } from '../lib/queryClient';\nimport { sessionPersistence } from '../utils/sessionPersistence';\n\n// Auth Context Types\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n// Create context\nconst AuthContext = /*#__PURE__*/createContext(undefined);\n\n// Auth Provider Props\n\n// Token refresh interval (15 minutes)\nconst TOKEN_REFRESH_INTERVAL = 15 * 60 * 1000;\nexport const AuthProvider = ({\n  children\n}) => {\n  _s();\n  const [user, setUser] = useState(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [error, setError] = useState(null);\n  const queryClient = useQueryClient();\n\n  // Computed state\n  const isAuthenticated = !!user && authService.isAuthenticated();\n\n  // Clear error helper\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  // Check session validity\n  const checkSession = useCallback(async () => {\n    try {\n      if (!authService.isAuthenticated()) {\n        return false;\n      }\n      const isValid = await authService.verifyToken();\n      return isValid;\n    } catch (error) {\n      console.warn('Session check failed:', error);\n      return false;\n    }\n  }, []);\n\n  // Restore session from storage\n  const restoreSession = useCallback(async () => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      // Check if session should be restored\n      if (!sessionPersistence.shouldRestoreSession()) {\n        sessionPersistence.clearSessionState();\n        setIsInitialized(true);\n        return;\n      }\n\n      // Try to get current user\n      const currentUser = await authService.getCurrentUser();\n      setUser(currentUser);\n\n      // Update session state\n      sessionPersistence.saveSessionState(true, currentUser.id, currentUser.email);\n\n      // Update query cache\n      queryClient.setQueryData(queryKeys.auth.user, currentUser);\n      queryClient.setQueryData(queryKeys.auth.verify, true);\n    } catch (error) {\n      console.warn('Session restoration failed:', error);\n\n      // Clear invalid session\n      authService.logout();\n      sessionPersistence.clearSessionState();\n      setUser(null);\n      queryClient.removeQueries(queryKeys.auth.user);\n      queryClient.removeQueries(queryKeys.auth.verify);\n      setError('Session expired. Please log in again.');\n    } finally {\n      setIsLoading(false);\n      setIsInitialized(true);\n    }\n  }, [queryClient]);\n\n  // Login function\n  const login = useCallback(async credentials => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const response = await authService.login(credentials);\n      setUser(response.user);\n\n      // Update session state\n      sessionPersistence.saveSessionState(true, response.user.id, response.user.email);\n\n      // Update query cache\n      queryClient.setQueryData(queryKeys.auth.user, response.user);\n      queryClient.setQueryData(queryKeys.auth.verify, true);\n      toast.success(`Welcome back, ${response.user.first_name}!`);\n\n      // Prefetch dashboard data after login\n      queryClient.prefetchQuery({\n        queryKey: queryKeys.statistics.dashboard(),\n        queryFn: () => import('../services').then(({\n          statisticsService\n        }) => statisticsService.getDashboardSummary())\n      });\n    } catch (error) {\n      const errorMessage = error.message || 'Login failed';\n      setError(errorMessage);\n      toast.error(errorMessage);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [queryClient]);\n\n  // Register function\n  const register = useCallback(async userData => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      const {\n        confirmPassword,\n        ...registrationData\n      } = userData;\n      await authService.register(registrationData);\n      toast.success('Registration successful! Please log in.');\n    } catch (error) {\n      const errorMessage = error.message || 'Registration failed';\n      setError(errorMessage);\n      toast.error(errorMessage);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // Logout function\n  const logout = useCallback(async () => {\n    setIsLoading(true);\n    setError(null);\n    try {\n      await authService.logout();\n    } catch (error) {\n      console.warn('Logout API call failed:', error);\n    } finally {\n      // Always clear local state\n      setUser(null);\n      sessionPersistence.clearSessionState();\n\n      // Clear all cached data\n      queryClient.clear();\n      queryClient.removeQueries(queryKeys.auth.user);\n      queryClient.removeQueries(queryKeys.auth.verify);\n      toast.success('Logged out successfully');\n      setIsLoading(false);\n    }\n  }, [queryClient]);\n\n  // Refresh token function\n  const refreshToken = useCallback(async () => {\n    try {\n      await authService.refreshToken();\n\n      // Update verification status\n      queryClient.setQueryData(queryKeys.auth.verify, true);\n      console.log('Token refreshed successfully');\n    } catch (error) {\n      console.warn('Token refresh failed:', error);\n\n      // Clear auth data and redirect to login\n      setUser(null);\n      sessionPersistence.clearSessionState();\n      queryClient.clear();\n      queryClient.removeQueries(queryKeys.auth.user);\n      queryClient.removeQueries(queryKeys.auth.verify);\n      setError('Session expired. Please log in again.');\n      toast.error('Session expired. Please log in again.');\n\n      // Redirect to login page\n      window.location.href = '/login';\n    }\n  }, [queryClient]);\n\n  // Auto-refresh token setup\n  useEffect(() => {\n    if (!isAuthenticated || !isInitialized) {\n      return;\n    }\n    const interval = setInterval(() => {\n      if (authService.isAuthenticated()) {\n        refreshToken();\n      }\n    }, TOKEN_REFRESH_INTERVAL);\n    return () => clearInterval(interval);\n  }, [isAuthenticated, isInitialized, refreshToken]);\n\n  // Initialize auth state on mount\n  useEffect(() => {\n    restoreSession();\n  }, [restoreSession]);\n\n  // Set up activity tracking\n  useEffect(() => {\n    if (!isAuthenticated || !isInitialized) {\n      return;\n    }\n    const cleanup = sessionPersistence.setupActivityTracking();\n    return cleanup;\n  }, [isAuthenticated, isInitialized]);\n\n  // Set up session timeout warning\n  useEffect(() => {\n    if (!isAuthenticated || !isInitialized) {\n      return;\n    }\n    const cleanup = sessionPersistence.setupSessionTimeoutWarning(() => {\n      toast.error('Your session will expire soon. Please save your work.', {\n        duration: 10000\n      });\n    });\n    return cleanup;\n  }, [isAuthenticated, isInitialized]);\n\n  // Handle browser storage events (for multi-tab sync)\n  useEffect(() => {\n    const handleStorageChange = event => {\n      if (event.key === 'access_token' || event.key === 'user') {\n        if (!event.newValue) {\n          // Token was removed in another tab\n          setUser(null);\n          queryClient.clear();\n        } else if (event.newValue && !user) {\n          // Token was added in another tab\n          restoreSession();\n        }\n      }\n    };\n    window.addEventListener('storage', handleStorageChange);\n    return () => window.removeEventListener('storage', handleStorageChange);\n  }, [user, queryClient, restoreSession]);\n\n  // Handle page visibility change (refresh token when page becomes visible)\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible' && isAuthenticated) {\n        checkSession().then(isValid => {\n          if (!isValid) {\n            refreshToken();\n          }\n        });\n      }\n    };\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);\n  }, [isAuthenticated, checkSession, refreshToken]);\n\n  // Context value\n  const contextValue = {\n    // State\n    user,\n    isAuthenticated,\n    isLoading,\n    isInitialized,\n    error,\n    // Actions\n    login,\n    register,\n    logout,\n    refreshToken,\n    clearError,\n    // Session management\n    checkSession,\n    restoreSession\n  };\n  return /*#__PURE__*/_jsxDEV(AuthContext.Provider, {\n    value: contextValue,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 329,\n    columnNumber: 5\n  }, this);\n};\n\n// Custom hook to use auth context\n_s(AuthProvider, \"NsxNf2In9Qj606FkDpANQ6lYxBg=\", false, function () {\n  return [useQueryClient];\n});\n_c = AuthProvider;\nexport const useAuthContext = () => {\n  _s2();\n  const context = useContext(AuthContext);\n  if (context === undefined) {\n    throw new Error('useAuthContext must be used within an AuthProvider');\n  }\n  return context;\n};\n_s2(useAuthContext, \"b9L3QQ+jgeyIrH0NfHrJ8nn7VMU=\");\nexport default AuthProvider;\nvar _c;\n$RefreshReg$(_c, \"AuthProvider\");","map":{"version":3,"names":["React","createContext","useContext","useEffect","useState","useCallback","useQueryClient","toast","authService","queryKeys","sessionPersistence","jsxDEV","_jsxDEV","AuthContext","undefined","TOKEN_REFRESH_INTERVAL","AuthProvider","children","_s","user","setUser","isLoading","setIsLoading","isInitialized","setIsInitialized","error","setError","queryClient","isAuthenticated","clearError","checkSession","isValid","verifyToken","console","warn","restoreSession","shouldRestoreSession","clearSessionState","currentUser","getCurrentUser","saveSessionState","id","email","setQueryData","auth","verify","logout","removeQueries","login","credentials","response","success","first_name","prefetchQuery","queryKey","statistics","dashboard","queryFn","then","statisticsService","getDashboardSummary","errorMessage","message","register","userData","confirmPassword","registrationData","clear","refreshToken","log","window","location","href","interval","setInterval","clearInterval","cleanup","setupActivityTracking","setupSessionTimeoutWarning","duration","handleStorageChange","event","key","newValue","addEventListener","removeEventListener","handleVisibilityChange","document","visibilityState","contextValue","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","useAuthContext","_s2","context","Error","$RefreshReg$"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/providers/AuthProvider.tsx"],"sourcesContent":["import React, { createContext, useContext, useEffect, useState, useCallback } from 'react';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { toast } from 'react-hot-toast';\nimport { authService } from '../services';\nimport { queryKeys } from '../lib/queryClient';\nimport { sessionPersistence } from '../utils/sessionPersistence';\nimport {\n  User,\n  AuthResponse,\n  LoginCredentials,\n  RegisterData,\n} from '../types';\n\n// Auth Context Types\ninterface AuthContextType {\n  // State\n  user: User | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  isInitialized: boolean;\n  error: string | null;\n  \n  // Actions\n  login: (credentials: LoginCredentials) => Promise<void>;\n  register: (userData: RegisterData) => Promise<void>;\n  logout: () => Promise<void>;\n  refreshToken: () => Promise<void>;\n  clearError: () => void;\n  \n  // Session management\n  checkSession: () => Promise<boolean>;\n  restoreSession: () => Promise<void>;\n}\n\n// Create context\nconst AuthContext = createContext<AuthContextType | undefined>(undefined);\n\n// Auth Provider Props\ninterface AuthProviderProps {\n  children: React.ReactNode;\n}\n\n// Token refresh interval (15 minutes)\nconst TOKEN_REFRESH_INTERVAL = 15 * 60 * 1000;\n\nexport const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {\n  const [user, setUser] = useState<User | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [isInitialized, setIsInitialized] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const queryClient = useQueryClient();\n\n  // Computed state\n  const isAuthenticated = !!user && authService.isAuthenticated();\n\n  // Clear error helper\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  // Check session validity\n  const checkSession = useCallback(async (): Promise<boolean> => {\n    try {\n      if (!authService.isAuthenticated()) {\n        return false;\n      }\n\n      const isValid = await authService.verifyToken();\n      return isValid;\n    } catch (error) {\n      console.warn('Session check failed:', error);\n      return false;\n    }\n  }, []);\n\n  // Restore session from storage\n  const restoreSession = useCallback(async () => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      // Check if session should be restored\n      if (!sessionPersistence.shouldRestoreSession()) {\n        sessionPersistence.clearSessionState();\n        setIsInitialized(true);\n        return;\n      }\n\n      // Try to get current user\n      const currentUser = await authService.getCurrentUser();\n      setUser(currentUser);\n      \n      // Update session state\n      sessionPersistence.saveSessionState(true, currentUser.id, currentUser.email);\n      \n      // Update query cache\n      queryClient.setQueryData(queryKeys.auth.user, currentUser);\n      queryClient.setQueryData(queryKeys.auth.verify, true);\n\n    } catch (error: any) {\n      console.warn('Session restoration failed:', error);\n      \n      // Clear invalid session\n      authService.logout();\n      sessionPersistence.clearSessionState();\n      setUser(null);\n      queryClient.removeQueries(queryKeys.auth.user);\n      queryClient.removeQueries(queryKeys.auth.verify);\n      \n      setError('Session expired. Please log in again.');\n    } finally {\n      setIsLoading(false);\n      setIsInitialized(true);\n    }\n  }, [queryClient]);\n\n  // Login function\n  const login = useCallback(async (credentials: LoginCredentials) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const response: AuthResponse = await authService.login(credentials);\n      \n      setUser(response.user);\n      \n      // Update session state\n      sessionPersistence.saveSessionState(true, response.user.id, response.user.email);\n      \n      // Update query cache\n      queryClient.setQueryData(queryKeys.auth.user, response.user);\n      queryClient.setQueryData(queryKeys.auth.verify, true);\n      \n      toast.success(`Welcome back, ${response.user.first_name}!`);\n      \n      // Prefetch dashboard data after login\n      queryClient.prefetchQuery({\n        queryKey: queryKeys.statistics.dashboard(),\n        queryFn: () => import('../services').then(({ statisticsService }) => \n          statisticsService.getDashboardSummary()\n        ),\n      });\n\n    } catch (error: any) {\n      const errorMessage = error.message || 'Login failed';\n      setError(errorMessage);\n      toast.error(errorMessage);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [queryClient]);\n\n  // Register function\n  const register = useCallback(async (userData: RegisterData) => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const { confirmPassword, ...registrationData } = userData;\n      await authService.register(registrationData);\n      \n      toast.success('Registration successful! Please log in.');\n      \n    } catch (error: any) {\n      const errorMessage = error.message || 'Registration failed';\n      setError(errorMessage);\n      toast.error(errorMessage);\n      throw error;\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  // Logout function\n  const logout = useCallback(async () => {\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      await authService.logout();\n    } catch (error) {\n      console.warn('Logout API call failed:', error);\n    } finally {\n      // Always clear local state\n      setUser(null);\n      sessionPersistence.clearSessionState();\n      \n      // Clear all cached data\n      queryClient.clear();\n      queryClient.removeQueries(queryKeys.auth.user);\n      queryClient.removeQueries(queryKeys.auth.verify);\n      \n      toast.success('Logged out successfully');\n      setIsLoading(false);\n    }\n  }, [queryClient]);\n\n  // Refresh token function\n  const refreshToken = useCallback(async () => {\n    try {\n      await authService.refreshToken();\n      \n      // Update verification status\n      queryClient.setQueryData(queryKeys.auth.verify, true);\n      \n      console.log('Token refreshed successfully');\n      \n    } catch (error: any) {\n      console.warn('Token refresh failed:', error);\n      \n      // Clear auth data and redirect to login\n      setUser(null);\n      sessionPersistence.clearSessionState();\n      queryClient.clear();\n      queryClient.removeQueries(queryKeys.auth.user);\n      queryClient.removeQueries(queryKeys.auth.verify);\n      \n      setError('Session expired. Please log in again.');\n      toast.error('Session expired. Please log in again.');\n      \n      // Redirect to login page\n      window.location.href = '/login';\n    }\n  }, [queryClient]);\n\n  // Auto-refresh token setup\n  useEffect(() => {\n    if (!isAuthenticated || !isInitialized) {\n      return;\n    }\n\n    const interval = setInterval(() => {\n      if (authService.isAuthenticated()) {\n        refreshToken();\n      }\n    }, TOKEN_REFRESH_INTERVAL);\n\n    return () => clearInterval(interval);\n  }, [isAuthenticated, isInitialized, refreshToken]);\n\n  // Initialize auth state on mount\n  useEffect(() => {\n    restoreSession();\n  }, [restoreSession]);\n\n  // Set up activity tracking\n  useEffect(() => {\n    if (!isAuthenticated || !isInitialized) {\n      return;\n    }\n\n    const cleanup = sessionPersistence.setupActivityTracking();\n    return cleanup;\n  }, [isAuthenticated, isInitialized]);\n\n  // Set up session timeout warning\n  useEffect(() => {\n    if (!isAuthenticated || !isInitialized) {\n      return;\n    }\n\n    const cleanup = sessionPersistence.setupSessionTimeoutWarning(() => {\n      toast.error('Your session will expire soon. Please save your work.', {\n        duration: 10000,\n      });\n    });\n\n    return cleanup;\n  }, [isAuthenticated, isInitialized]);\n\n  // Handle browser storage events (for multi-tab sync)\n  useEffect(() => {\n    const handleStorageChange = (event: StorageEvent) => {\n      if (event.key === 'access_token' || event.key === 'user') {\n        if (!event.newValue) {\n          // Token was removed in another tab\n          setUser(null);\n          queryClient.clear();\n        } else if (event.newValue && !user) {\n          // Token was added in another tab\n          restoreSession();\n        }\n      }\n    };\n\n    window.addEventListener('storage', handleStorageChange);\n    return () => window.removeEventListener('storage', handleStorageChange);\n  }, [user, queryClient, restoreSession]);\n\n  // Handle page visibility change (refresh token when page becomes visible)\n  useEffect(() => {\n    const handleVisibilityChange = () => {\n      if (document.visibilityState === 'visible' && isAuthenticated) {\n        checkSession().then(isValid => {\n          if (!isValid) {\n            refreshToken();\n          }\n        });\n      }\n    };\n\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    return () => document.removeEventListener('visibilitychange', handleVisibilityChange);\n  }, [isAuthenticated, checkSession, refreshToken]);\n\n  // Context value\n  const contextValue: AuthContextType = {\n    // State\n    user,\n    isAuthenticated,\n    isLoading,\n    isInitialized,\n    error,\n    \n    // Actions\n    login,\n    register,\n    logout,\n    refreshToken,\n    clearError,\n    \n    // Session management\n    checkSession,\n    restoreSession,\n  };\n\n  return (\n    <AuthContext.Provider value={contextValue}>\n      {children}\n    </AuthContext.Provider>\n  );\n};\n\n// Custom hook to use auth context\nexport const useAuthContext = (): AuthContextType => {\n  const context = useContext(AuthContext);\n  \n  if (context === undefined) {\n    throw new Error('useAuthContext must be used within an AuthProvider');\n  }\n  \n  return context;\n};\n\nexport default AuthProvider;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}