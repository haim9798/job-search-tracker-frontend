{"ast":null,"code":"import { tokenManager } from './tokenManager';\n\n// Session storage keys\nconst SESSION_STATE_KEY = 'session_state';\nconst LAST_ACTIVITY_KEY = 'last_activity';\n\n// Session timeout (24 hours)\nconst SESSION_TIMEOUT = 24 * 60 * 60 * 1000;\nexport class SessionPersistence {\n  /**\n   * Save session state\n   */\n  saveSessionState(isAuthenticated, userId, userEmail) {\n    try {\n      const sessionState = {\n        isAuthenticated,\n        lastActivity: Date.now(),\n        userId,\n        userEmail\n      };\n      localStorage.setItem(SESSION_STATE_KEY, JSON.stringify(sessionState));\n      localStorage.setItem(LAST_ACTIVITY_KEY, Date.now().toString());\n    } catch (error) {\n      console.error('Failed to save session state:', error);\n    }\n  }\n\n  /**\n   * Get session state\n   */\n  getSessionState() {\n    try {\n      const sessionStateStr = localStorage.getItem(SESSION_STATE_KEY);\n      return sessionStateStr ? JSON.parse(sessionStateStr) : null;\n    } catch (error) {\n      console.error('Failed to get session state:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Check if session is valid (not expired)\n   */\n  isSessionValid() {\n    try {\n      const sessionState = this.getSessionState();\n      if (!sessionState) {\n        return false;\n      }\n      const now = Date.now();\n      const timeSinceLastActivity = now - sessionState.lastActivity;\n      return timeSinceLastActivity < SESSION_TIMEOUT;\n    } catch (error) {\n      console.error('Failed to check session validity:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Update last activity timestamp\n   */\n  updateLastActivity() {\n    try {\n      const sessionState = this.getSessionState();\n      if (sessionState) {\n        sessionState.lastActivity = Date.now();\n        localStorage.setItem(SESSION_STATE_KEY, JSON.stringify(sessionState));\n      }\n      localStorage.setItem(LAST_ACTIVITY_KEY, Date.now().toString());\n    } catch (error) {\n      console.error('Failed to update last activity:', error);\n    }\n  }\n\n  /**\n   * Clear session state\n   */\n  clearSessionState() {\n    try {\n      localStorage.removeItem(SESSION_STATE_KEY);\n      localStorage.removeItem(LAST_ACTIVITY_KEY);\n    } catch (error) {\n      console.error('Failed to clear session state:', error);\n    }\n  }\n\n  /**\n   * Get time since last activity\n   */\n  getTimeSinceLastActivity() {\n    try {\n      const lastActivityStr = localStorage.getItem(LAST_ACTIVITY_KEY);\n      if (!lastActivityStr) {\n        return Infinity;\n      }\n      const lastActivity = parseInt(lastActivityStr, 10);\n      return Date.now() - lastActivity;\n    } catch (error) {\n      console.error('Failed to get time since last activity:', error);\n      return Infinity;\n    }\n  }\n\n  /**\n   * Check if session should be restored\n   */\n  shouldRestoreSession() {\n    const sessionState = this.getSessionState();\n    const hasTokens = tokenManager.isAuthenticated();\n    const isSessionValid = this.isSessionValid();\n    return !!(sessionState !== null && sessionState !== void 0 && sessionState.isAuthenticated && hasTokens && isSessionValid);\n  }\n\n  /**\n   * Set up activity tracking\n   */\n  setupActivityTracking() {\n    const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];\n    let activityTimeout;\n    const updateActivity = () => {\n      // Debounce activity updates to avoid excessive localStorage writes\n      clearTimeout(activityTimeout);\n      activityTimeout = setTimeout(() => {\n        this.updateLastActivity();\n      }, 1000);\n    };\n\n    // Add event listeners\n    events.forEach(event => {\n      document.addEventListener(event, updateActivity, {\n        passive: true\n      });\n    });\n\n    // Cleanup function\n    return () => {\n      clearTimeout(activityTimeout);\n      events.forEach(event => {\n        document.removeEventListener(event, updateActivity);\n      });\n    };\n  }\n\n  /**\n   * Set up session timeout warning\n   */\n  setupSessionTimeoutWarning(warningCallback, warningTimeBeforeExpiry = 5 * 60 * 1000 // 5 minutes\n  ) {\n    let warningTimeout;\n    let checkInterval;\n    const checkSessionExpiry = () => {\n      const timeSinceLastActivity = this.getTimeSinceLastActivity();\n      const timeUntilExpiry = SESSION_TIMEOUT - timeSinceLastActivity;\n      if (timeUntilExpiry <= warningTimeBeforeExpiry && timeUntilExpiry > 0) {\n        warningCallback();\n        clearInterval(checkInterval); // Stop checking after warning\n      } else if (timeUntilExpiry <= 0) {\n        // Session expired\n        this.clearSessionState();\n        tokenManager.clearTokens();\n        clearInterval(checkInterval);\n      }\n    };\n\n    // Check every minute\n    const intervalId = setInterval(checkSessionExpiry, 60 * 1000);\n    checkInterval = intervalId;\n\n    // Cleanup function\n    return () => {\n      clearTimeout(warningTimeout);\n      clearInterval(checkInterval);\n    };\n  }\n\n  /**\n   * Extend session (reset activity timer)\n   */\n  extendSession() {\n    this.updateLastActivity();\n  }\n\n  /**\n   * Get session info for debugging\n   */\n  getSessionInfo() {\n    const sessionState = this.getSessionState();\n    const timeSinceLastActivity = this.getTimeSinceLastActivity();\n    return {\n      sessionState,\n      isValid: this.isSessionValid(),\n      timeSinceLastActivity,\n      timeUntilExpiry: SESSION_TIMEOUT - timeSinceLastActivity,\n      shouldRestore: this.shouldRestoreSession()\n    };\n  }\n}\n\n// Export singleton instance\nexport const sessionPersistence = new SessionPersistence();\nexport default sessionPersistence;","map":{"version":3,"names":["tokenManager","SESSION_STATE_KEY","LAST_ACTIVITY_KEY","SESSION_TIMEOUT","SessionPersistence","saveSessionState","isAuthenticated","userId","userEmail","sessionState","lastActivity","Date","now","localStorage","setItem","JSON","stringify","toString","error","console","getSessionState","sessionStateStr","getItem","parse","isSessionValid","timeSinceLastActivity","updateLastActivity","clearSessionState","removeItem","getTimeSinceLastActivity","lastActivityStr","Infinity","parseInt","shouldRestoreSession","hasTokens","setupActivityTracking","events","activityTimeout","updateActivity","clearTimeout","setTimeout","forEach","event","document","addEventListener","passive","removeEventListener","setupSessionTimeoutWarning","warningCallback","warningTimeBeforeExpiry","warningTimeout","checkInterval","checkSessionExpiry","timeUntilExpiry","clearInterval","clearTokens","intervalId","setInterval","extendSession","getSessionInfo","isValid","shouldRestore","sessionPersistence"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/utils/sessionPersistence.ts"],"sourcesContent":["import { tokenManager } from './tokenManager';\n\n// Session storage keys\nconst SESSION_STATE_KEY = 'session_state';\nconst LAST_ACTIVITY_KEY = 'last_activity';\n\n// Session timeout (24 hours)\nconst SESSION_TIMEOUT = 24 * 60 * 60 * 1000;\n\ninterface SessionState {\n  isAuthenticated: boolean;\n  lastActivity: number;\n  userId?: string | undefined;\n  userEmail?: string | undefined;\n}\n\nexport class SessionPersistence {\n  /**\n   * Save session state\n   */\n  saveSessionState(isAuthenticated: boolean, userId?: string, userEmail?: string): void {\n    try {\n      const sessionState: SessionState = {\n        isAuthenticated,\n        lastActivity: Date.now(),\n        userId,\n        userEmail,\n      };\n\n      localStorage.setItem(SESSION_STATE_KEY, JSON.stringify(sessionState));\n      localStorage.setItem(LAST_ACTIVITY_KEY, Date.now().toString());\n    } catch (error) {\n      console.error('Failed to save session state:', error);\n    }\n  }\n\n  /**\n   * Get session state\n   */\n  getSessionState(): SessionState | null {\n    try {\n      const sessionStateStr = localStorage.getItem(SESSION_STATE_KEY);\n      return sessionStateStr ? JSON.parse(sessionStateStr) : null;\n    } catch (error) {\n      console.error('Failed to get session state:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Check if session is valid (not expired)\n   */\n  isSessionValid(): boolean {\n    try {\n      const sessionState = this.getSessionState();\n      if (!sessionState) {\n        return false;\n      }\n\n      const now = Date.now();\n      const timeSinceLastActivity = now - sessionState.lastActivity;\n\n      return timeSinceLastActivity < SESSION_TIMEOUT;\n    } catch (error) {\n      console.error('Failed to check session validity:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Update last activity timestamp\n   */\n  updateLastActivity(): void {\n    try {\n      const sessionState = this.getSessionState();\n      if (sessionState) {\n        sessionState.lastActivity = Date.now();\n        localStorage.setItem(SESSION_STATE_KEY, JSON.stringify(sessionState));\n      }\n      localStorage.setItem(LAST_ACTIVITY_KEY, Date.now().toString());\n    } catch (error) {\n      console.error('Failed to update last activity:', error);\n    }\n  }\n\n  /**\n   * Clear session state\n   */\n  clearSessionState(): void {\n    try {\n      localStorage.removeItem(SESSION_STATE_KEY);\n      localStorage.removeItem(LAST_ACTIVITY_KEY);\n    } catch (error) {\n      console.error('Failed to clear session state:', error);\n    }\n  }\n\n  /**\n   * Get time since last activity\n   */\n  getTimeSinceLastActivity(): number {\n    try {\n      const lastActivityStr = localStorage.getItem(LAST_ACTIVITY_KEY);\n      if (!lastActivityStr) {\n        return Infinity;\n      }\n\n      const lastActivity = parseInt(lastActivityStr, 10);\n      return Date.now() - lastActivity;\n    } catch (error) {\n      console.error('Failed to get time since last activity:', error);\n      return Infinity;\n    }\n  }\n\n  /**\n   * Check if session should be restored\n   */\n  shouldRestoreSession(): boolean {\n    const sessionState = this.getSessionState();\n    const hasTokens = tokenManager.isAuthenticated();\n    const isSessionValid = this.isSessionValid();\n\n    return !!(sessionState?.isAuthenticated && hasTokens && isSessionValid);\n  }\n\n  /**\n   * Set up activity tracking\n   */\n  setupActivityTracking(): () => void {\n    const events = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart', 'click'];\n    let activityTimeout: NodeJS.Timeout;\n\n    const updateActivity = () => {\n      // Debounce activity updates to avoid excessive localStorage writes\n      clearTimeout(activityTimeout);\n      activityTimeout = setTimeout(() => {\n        this.updateLastActivity();\n      }, 1000);\n    };\n\n    // Add event listeners\n    events.forEach(event => {\n      document.addEventListener(event, updateActivity, { passive: true });\n    });\n\n    // Cleanup function\n    return () => {\n      clearTimeout(activityTimeout);\n      events.forEach(event => {\n        document.removeEventListener(event, updateActivity);\n      });\n    };\n  }\n\n  /**\n   * Set up session timeout warning\n   */\n  setupSessionTimeoutWarning(\n    warningCallback: () => void,\n    warningTimeBeforeExpiry: number = 5 * 60 * 1000 // 5 minutes\n  ): () => void {\n    let warningTimeout: NodeJS.Timeout;\n    let checkInterval: NodeJS.Timeout;\n\n    const checkSessionExpiry = () => {\n      const timeSinceLastActivity = this.getTimeSinceLastActivity();\n      const timeUntilExpiry = SESSION_TIMEOUT - timeSinceLastActivity;\n\n      if (timeUntilExpiry <= warningTimeBeforeExpiry && timeUntilExpiry > 0) {\n        warningCallback();\n        clearInterval(checkInterval); // Stop checking after warning\n      } else if (timeUntilExpiry <= 0) {\n        // Session expired\n        this.clearSessionState();\n        tokenManager.clearTokens();\n        clearInterval(checkInterval);\n      }\n    };\n\n    // Check every minute\n    const intervalId = setInterval(checkSessionExpiry, 60 * 1000);\n    checkInterval = intervalId;\n\n    // Cleanup function\n    return () => {\n      clearTimeout(warningTimeout);\n      clearInterval(checkInterval);\n    };\n  }\n\n  /**\n   * Extend session (reset activity timer)\n   */\n  extendSession(): void {\n    this.updateLastActivity();\n  }\n\n  /**\n   * Get session info for debugging\n   */\n  getSessionInfo(): {\n    sessionState: SessionState | null;\n    isValid: boolean;\n    timeSinceLastActivity: number;\n    timeUntilExpiry: number;\n    shouldRestore: boolean;\n  } {\n    const sessionState = this.getSessionState();\n    const timeSinceLastActivity = this.getTimeSinceLastActivity();\n    \n    return {\n      sessionState,\n      isValid: this.isSessionValid(),\n      timeSinceLastActivity,\n      timeUntilExpiry: SESSION_TIMEOUT - timeSinceLastActivity,\n      shouldRestore: this.shouldRestoreSession(),\n    };\n  }\n}\n\n// Export singleton instance\nexport const sessionPersistence = new SessionPersistence();\nexport default sessionPersistence;"],"mappings":"AAAA,SAASA,YAAY,QAAQ,gBAAgB;;AAE7C;AACA,MAAMC,iBAAiB,GAAG,eAAe;AACzC,MAAMC,iBAAiB,GAAG,eAAe;;AAEzC;AACA,MAAMC,eAAe,GAAG,EAAE,GAAG,EAAE,GAAG,EAAE,GAAG,IAAI;AAS3C,OAAO,MAAMC,kBAAkB,CAAC;EAC9B;AACF;AACA;EACEC,gBAAgBA,CAACC,eAAwB,EAAEC,MAAe,EAAEC,SAAkB,EAAQ;IACpF,IAAI;MACF,MAAMC,YAA0B,GAAG;QACjCH,eAAe;QACfI,YAAY,EAAEC,IAAI,CAACC,GAAG,CAAC,CAAC;QACxBL,MAAM;QACNC;MACF,CAAC;MAEDK,YAAY,CAACC,OAAO,CAACb,iBAAiB,EAAEc,IAAI,CAACC,SAAS,CAACP,YAAY,CAAC,CAAC;MACrEI,YAAY,CAACC,OAAO,CAACZ,iBAAiB,EAAES,IAAI,CAACC,GAAG,CAAC,CAAC,CAACK,QAAQ,CAAC,CAAC,CAAC;IAChE,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,+BAA+B,EAAEA,KAAK,CAAC;IACvD;EACF;;EAEA;AACF;AACA;EACEE,eAAeA,CAAA,EAAwB;IACrC,IAAI;MACF,MAAMC,eAAe,GAAGR,YAAY,CAACS,OAAO,CAACrB,iBAAiB,CAAC;MAC/D,OAAOoB,eAAe,GAAGN,IAAI,CAACQ,KAAK,CAACF,eAAe,CAAC,GAAG,IAAI;IAC7D,CAAC,CAAC,OAAOH,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,8BAA8B,EAAEA,KAAK,CAAC;MACpD,OAAO,IAAI;IACb;EACF;;EAEA;AACF;AACA;EACEM,cAAcA,CAAA,EAAY;IACxB,IAAI;MACF,MAAMf,YAAY,GAAG,IAAI,CAACW,eAAe,CAAC,CAAC;MAC3C,IAAI,CAACX,YAAY,EAAE;QACjB,OAAO,KAAK;MACd;MAEA,MAAMG,GAAG,GAAGD,IAAI,CAACC,GAAG,CAAC,CAAC;MACtB,MAAMa,qBAAqB,GAAGb,GAAG,GAAGH,YAAY,CAACC,YAAY;MAE7D,OAAOe,qBAAqB,GAAGtB,eAAe;IAChD,CAAC,CAAC,OAAOe,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,mCAAmC,EAAEA,KAAK,CAAC;MACzD,OAAO,KAAK;IACd;EACF;;EAEA;AACF;AACA;EACEQ,kBAAkBA,CAAA,EAAS;IACzB,IAAI;MACF,MAAMjB,YAAY,GAAG,IAAI,CAACW,eAAe,CAAC,CAAC;MAC3C,IAAIX,YAAY,EAAE;QAChBA,YAAY,CAACC,YAAY,GAAGC,IAAI,CAACC,GAAG,CAAC,CAAC;QACtCC,YAAY,CAACC,OAAO,CAACb,iBAAiB,EAAEc,IAAI,CAACC,SAAS,CAACP,YAAY,CAAC,CAAC;MACvE;MACAI,YAAY,CAACC,OAAO,CAACZ,iBAAiB,EAAES,IAAI,CAACC,GAAG,CAAC,CAAC,CAACK,QAAQ,CAAC,CAAC,CAAC;IAChE,CAAC,CAAC,OAAOC,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;IACzD;EACF;;EAEA;AACF;AACA;EACES,iBAAiBA,CAAA,EAAS;IACxB,IAAI;MACFd,YAAY,CAACe,UAAU,CAAC3B,iBAAiB,CAAC;MAC1CY,YAAY,CAACe,UAAU,CAAC1B,iBAAiB,CAAC;IAC5C,CAAC,CAAC,OAAOgB,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;IACxD;EACF;;EAEA;AACF;AACA;EACEW,wBAAwBA,CAAA,EAAW;IACjC,IAAI;MACF,MAAMC,eAAe,GAAGjB,YAAY,CAACS,OAAO,CAACpB,iBAAiB,CAAC;MAC/D,IAAI,CAAC4B,eAAe,EAAE;QACpB,OAAOC,QAAQ;MACjB;MAEA,MAAMrB,YAAY,GAAGsB,QAAQ,CAACF,eAAe,EAAE,EAAE,CAAC;MAClD,OAAOnB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGF,YAAY;IAClC,CAAC,CAAC,OAAOQ,KAAK,EAAE;MACdC,OAAO,CAACD,KAAK,CAAC,yCAAyC,EAAEA,KAAK,CAAC;MAC/D,OAAOa,QAAQ;IACjB;EACF;;EAEA;AACF;AACA;EACEE,oBAAoBA,CAAA,EAAY;IAC9B,MAAMxB,YAAY,GAAG,IAAI,CAACW,eAAe,CAAC,CAAC;IAC3C,MAAMc,SAAS,GAAGlC,YAAY,CAACM,eAAe,CAAC,CAAC;IAChD,MAAMkB,cAAc,GAAG,IAAI,CAACA,cAAc,CAAC,CAAC;IAE5C,OAAO,CAAC,EAAEf,YAAY,aAAZA,YAAY,eAAZA,YAAY,CAAEH,eAAe,IAAI4B,SAAS,IAAIV,cAAc,CAAC;EACzE;;EAEA;AACF;AACA;EACEW,qBAAqBA,CAAA,EAAe;IAClC,MAAMC,MAAM,GAAG,CAAC,WAAW,EAAE,WAAW,EAAE,UAAU,EAAE,QAAQ,EAAE,YAAY,EAAE,OAAO,CAAC;IACtF,IAAIC,eAA+B;IAEnC,MAAMC,cAAc,GAAGA,CAAA,KAAM;MAC3B;MACAC,YAAY,CAACF,eAAe,CAAC;MAC7BA,eAAe,GAAGG,UAAU,CAAC,MAAM;QACjC,IAAI,CAACd,kBAAkB,CAAC,CAAC;MAC3B,CAAC,EAAE,IAAI,CAAC;IACV,CAAC;;IAED;IACAU,MAAM,CAACK,OAAO,CAACC,KAAK,IAAI;MACtBC,QAAQ,CAACC,gBAAgB,CAACF,KAAK,EAAEJ,cAAc,EAAE;QAAEO,OAAO,EAAE;MAAK,CAAC,CAAC;IACrE,CAAC,CAAC;;IAEF;IACA,OAAO,MAAM;MACXN,YAAY,CAACF,eAAe,CAAC;MAC7BD,MAAM,CAACK,OAAO,CAACC,KAAK,IAAI;QACtBC,QAAQ,CAACG,mBAAmB,CAACJ,KAAK,EAAEJ,cAAc,CAAC;MACrD,CAAC,CAAC;IACJ,CAAC;EACH;;EAEA;AACF;AACA;EACES,0BAA0BA,CACxBC,eAA2B,EAC3BC,uBAA+B,GAAG,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC;EAAA,EACpC;IACZ,IAAIC,cAA8B;IAClC,IAAIC,aAA6B;IAEjC,MAAMC,kBAAkB,GAAGA,CAAA,KAAM;MAC/B,MAAM3B,qBAAqB,GAAG,IAAI,CAACI,wBAAwB,CAAC,CAAC;MAC7D,MAAMwB,eAAe,GAAGlD,eAAe,GAAGsB,qBAAqB;MAE/D,IAAI4B,eAAe,IAAIJ,uBAAuB,IAAII,eAAe,GAAG,CAAC,EAAE;QACrEL,eAAe,CAAC,CAAC;QACjBM,aAAa,CAACH,aAAa,CAAC,CAAC,CAAC;MAChC,CAAC,MAAM,IAAIE,eAAe,IAAI,CAAC,EAAE;QAC/B;QACA,IAAI,CAAC1B,iBAAiB,CAAC,CAAC;QACxB3B,YAAY,CAACuD,WAAW,CAAC,CAAC;QAC1BD,aAAa,CAACH,aAAa,CAAC;MAC9B;IACF,CAAC;;IAED;IACA,MAAMK,UAAU,GAAGC,WAAW,CAACL,kBAAkB,EAAE,EAAE,GAAG,IAAI,CAAC;IAC7DD,aAAa,GAAGK,UAAU;;IAE1B;IACA,OAAO,MAAM;MACXjB,YAAY,CAACW,cAAc,CAAC;MAC5BI,aAAa,CAACH,aAAa,CAAC;IAC9B,CAAC;EACH;;EAEA;AACF;AACA;EACEO,aAAaA,CAAA,EAAS;IACpB,IAAI,CAAChC,kBAAkB,CAAC,CAAC;EAC3B;;EAEA;AACF;AACA;EACEiC,cAAcA,CAAA,EAMZ;IACA,MAAMlD,YAAY,GAAG,IAAI,CAACW,eAAe,CAAC,CAAC;IAC3C,MAAMK,qBAAqB,GAAG,IAAI,CAACI,wBAAwB,CAAC,CAAC;IAE7D,OAAO;MACLpB,YAAY;MACZmD,OAAO,EAAE,IAAI,CAACpC,cAAc,CAAC,CAAC;MAC9BC,qBAAqB;MACrB4B,eAAe,EAAElD,eAAe,GAAGsB,qBAAqB;MACxDoC,aAAa,EAAE,IAAI,CAAC5B,oBAAoB,CAAC;IAC3C,CAAC;EACH;AACF;;AAEA;AACA,OAAO,MAAM6B,kBAAkB,GAAG,IAAI1D,kBAAkB,CAAC,CAAC;AAC1D,eAAe0D,kBAAkB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}