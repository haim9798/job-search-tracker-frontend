{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useRef, useCallback, useState } from 'react';\nexport const usePullToRefresh = options => {\n  _s();\n  const {\n    onRefresh,\n    threshold = 80,\n    resistance = 2.5,\n    enabled = true\n  } = options;\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [pullDistance, setPullDistance] = useState(0);\n  const [isPulling, setIsPulling] = useState(false);\n  const startY = useRef(0);\n  const currentY = useRef(0);\n  const scrollElement = useRef(null);\n  const handleTouchStart = useCallback(e => {\n    if (!enabled || isRefreshing) return;\n    const element = scrollElement.current;\n    if (!element || element.scrollTop > 0) return;\n    startY.current = e.touches[0].clientY;\n    setIsPulling(true);\n  }, [enabled, isRefreshing]);\n  const handleTouchMove = useCallback(e => {\n    if (!enabled || isRefreshing || !isPulling) return;\n    const element = scrollElement.current;\n    if (!element || element.scrollTop > 0) {\n      setIsPulling(false);\n      setPullDistance(0);\n      return;\n    }\n    currentY.current = e.touches[0].clientY;\n    const deltaY = currentY.current - startY.current;\n    if (deltaY > 0) {\n      e.preventDefault();\n      const distance = Math.min(deltaY / resistance, threshold * 1.5);\n      setPullDistance(distance);\n    }\n  }, [enabled, isRefreshing, isPulling, resistance, threshold]);\n  const handleTouchEnd = useCallback(async () => {\n    if (!enabled || isRefreshing || !isPulling) return;\n    setIsPulling(false);\n    if (pullDistance >= threshold) {\n      setIsRefreshing(true);\n      try {\n        await onRefresh();\n      } catch (error) {\n        console.error('Pull to refresh failed:', error);\n      } finally {\n        setIsRefreshing(false);\n      }\n    }\n    setPullDistance(0);\n  }, [enabled, isRefreshing, isPulling, pullDistance, threshold, onRefresh]);\n  const attachPullToRefresh = useCallback(element => {\n    scrollElement.current = element;\n    if (!element || !enabled) return;\n    element.addEventListener('touchstart', handleTouchStart, {\n      passive: false\n    });\n    element.addEventListener('touchmove', handleTouchMove, {\n      passive: false\n    });\n    element.addEventListener('touchend', handleTouchEnd, {\n      passive: true\n    });\n    return () => {\n      element.removeEventListener('touchstart', handleTouchStart);\n      element.removeEventListener('touchmove', handleTouchMove);\n      element.removeEventListener('touchend', handleTouchEnd);\n    };\n  }, [handleTouchStart, handleTouchMove, handleTouchEnd, enabled]);\n  const progress = Math.min(pullDistance / threshold, 1);\n  const shouldRefresh = pullDistance >= threshold;\n  return {\n    attachPullToRefresh,\n    isRefreshing,\n    isPulling,\n    pullDistance,\n    progress,\n    shouldRefresh\n  };\n};\n_s(usePullToRefresh, \"5M5OMOdip+eKg169xIbmD+8fw/U=\");\nexport default usePullToRefresh;","map":{"version":3,"names":["useRef","useCallback","useState","usePullToRefresh","options","_s","onRefresh","threshold","resistance","enabled","isRefreshing","setIsRefreshing","pullDistance","setPullDistance","isPulling","setIsPulling","startY","currentY","scrollElement","handleTouchStart","e","element","current","scrollTop","touches","clientY","handleTouchMove","deltaY","preventDefault","distance","Math","min","handleTouchEnd","error","console","attachPullToRefresh","addEventListener","passive","removeEventListener","progress","shouldRefresh"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/hooks/usePullToRefresh.ts"],"sourcesContent":["import { useRef, useCallback, useEffect, useState } from 'react';\n\ninterface PullToRefreshOptions {\n  onRefresh: () => Promise<void> | void;\n  threshold?: number;\n  resistance?: number;\n  enabled?: boolean;\n}\n\nexport const usePullToRefresh = (options: PullToRefreshOptions) => {\n  const {\n    onRefresh,\n    threshold = 80,\n    resistance = 2.5,\n    enabled = true,\n  } = options;\n\n  const [isRefreshing, setIsRefreshing] = useState(false);\n  const [pullDistance, setPullDistance] = useState(0);\n  const [isPulling, setIsPulling] = useState(false);\n\n  const startY = useRef(0);\n  const currentY = useRef(0);\n  const scrollElement = useRef<HTMLElement | null>(null);\n\n  const handleTouchStart = useCallback((e: TouchEvent) => {\n    if (!enabled || isRefreshing) return;\n\n    const element = scrollElement.current;\n    if (!element || element.scrollTop > 0) return;\n\n    startY.current = e.touches[0].clientY;\n    setIsPulling(true);\n  }, [enabled, isRefreshing]);\n\n  const handleTouchMove = useCallback((e: TouchEvent) => {\n    if (!enabled || isRefreshing || !isPulling) return;\n\n    const element = scrollElement.current;\n    if (!element || element.scrollTop > 0) {\n      setIsPulling(false);\n      setPullDistance(0);\n      return;\n    }\n\n    currentY.current = e.touches[0].clientY;\n    const deltaY = currentY.current - startY.current;\n\n    if (deltaY > 0) {\n      e.preventDefault();\n      const distance = Math.min(deltaY / resistance, threshold * 1.5);\n      setPullDistance(distance);\n    }\n  }, [enabled, isRefreshing, isPulling, resistance, threshold]);\n\n  const handleTouchEnd = useCallback(async () => {\n    if (!enabled || isRefreshing || !isPulling) return;\n\n    setIsPulling(false);\n\n    if (pullDistance >= threshold) {\n      setIsRefreshing(true);\n      try {\n        await onRefresh();\n      } catch (error) {\n        console.error('Pull to refresh failed:', error);\n      } finally {\n        setIsRefreshing(false);\n      }\n    }\n\n    setPullDistance(0);\n  }, [enabled, isRefreshing, isPulling, pullDistance, threshold, onRefresh]);\n\n  const attachPullToRefresh = useCallback((element: HTMLElement | null) => {\n    scrollElement.current = element;\n    \n    if (!element || !enabled) return;\n\n    element.addEventListener('touchstart', handleTouchStart, { passive: false });\n    element.addEventListener('touchmove', handleTouchMove, { passive: false });\n    element.addEventListener('touchend', handleTouchEnd, { passive: true });\n\n    return () => {\n      element.removeEventListener('touchstart', handleTouchStart);\n      element.removeEventListener('touchmove', handleTouchMove);\n      element.removeEventListener('touchend', handleTouchEnd);\n    };\n  }, [handleTouchStart, handleTouchMove, handleTouchEnd, enabled]);\n\n  const progress = Math.min(pullDistance / threshold, 1);\n  const shouldRefresh = pullDistance >= threshold;\n\n  return {\n    attachPullToRefresh,\n    isRefreshing,\n    isPulling,\n    pullDistance,\n    progress,\n    shouldRefresh,\n  };\n};\n\nexport default usePullToRefresh;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}