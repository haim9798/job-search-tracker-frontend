{"ast":null,"code":"var _s = $RefreshSig$();\n// Offline queue item interface\n\n// Offline queue manager\nexport class OfflineQueue {\n  // Add item to offline queue\n  static addToQueue(item) {\n    const queueItem = {\n      ...item,\n      id: crypto.randomUUID(),\n      timestamp: Date.now(),\n      retryCount: 0,\n      maxRetries: this.MAX_RETRIES\n    };\n    const queue = this.getQueue();\n    queue.push(queueItem);\n    this.saveQueue(queue);\n    this.notifyListeners(queue);\n    console.log('Added to offline queue:', queueItem);\n  }\n\n  // Get current queue\n  static getQueue() {\n    try {\n      const stored = localStorage.getItem(this.QUEUE_KEY);\n      return stored ? JSON.parse(stored) : [];\n    } catch (error) {\n      console.warn('Failed to load offline queue:', error);\n      return [];\n    }\n  }\n\n  // Save queue to localStorage\n  static saveQueue(queue) {\n    try {\n      localStorage.setItem(this.QUEUE_KEY, JSON.stringify(queue));\n    } catch (error) {\n      console.warn('Failed to save offline queue:', error);\n    }\n  }\n\n  // Remove item from queue\n  static removeFromQueue(id) {\n    const queue = this.getQueue().filter(item => item.id !== id);\n    this.saveQueue(queue);\n    this.notifyListeners(queue);\n  }\n\n  // Update retry count for item\n  static updateRetryCount(id) {\n    const queue = this.getQueue();\n    const item = queue.find(item => item.id === id);\n    if (item) {\n      item.retryCount++;\n      this.saveQueue(queue);\n      this.notifyListeners(queue);\n    }\n  }\n\n  // Process offline queue\n  static async processQueue() {\n    if (this.isProcessing || !navigator.onLine) {\n      return;\n    }\n    this.isProcessing = true;\n    const queue = this.getQueue();\n    console.log(`Processing offline queue with ${queue.length} items`);\n    for (const item of queue) {\n      try {\n        await this.processQueueItem(item);\n        this.removeFromQueue(item.id);\n        console.log('Successfully processed offline queue item:', item.id);\n      } catch (error) {\n        console.error('Failed to process offline queue item:', item.id, error);\n        if (item.retryCount < item.maxRetries) {\n          this.updateRetryCount(item.id);\n          // Exponential backoff delay\n          const delay = this.RETRY_DELAY * Math.pow(2, item.retryCount);\n          setTimeout(() => {\n            // Will be processed in next queue processing cycle\n          }, delay);\n        } else {\n          // Max retries reached, remove from queue\n          console.error('Max retries reached for offline queue item:', item.id);\n          this.removeFromQueue(item.id);\n        }\n      }\n    }\n    this.isProcessing = false;\n  }\n\n  // Process individual queue item\n  static async processQueueItem(item) {\n    const response = await fetch(item.url, {\n      method: item.method,\n      headers: {\n        'Content-Type': 'application/json',\n        ...item.headers\n      },\n      body: item.data ? JSON.stringify(item.data) : undefined\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n    return response.json();\n  }\n\n  // Clear entire queue\n  static clearQueue() {\n    localStorage.removeItem(this.QUEUE_KEY);\n    this.notifyListeners([]);\n  }\n\n  // Get queue size\n  static getQueueSize() {\n    return this.getQueue().length;\n  }\n\n  // Check if queue has items\n  static hasItems() {\n    return this.getQueueSize() > 0;\n  }\n\n  // Add listener for queue changes\n  static addListener(listener) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter(l => l !== listener);\n    };\n  }\n\n  // Notify all listeners of queue changes\n  static notifyListeners(queue) {\n    this.listeners.forEach(listener => {\n      try {\n        listener(queue);\n      } catch (error) {\n        console.error('Error in offline queue listener:', error);\n      }\n    });\n  }\n\n  // Initialize offline queue\n  static initialize() {\n    // Process queue when coming back online\n    window.addEventListener('online', () => {\n      console.log('Network connection restored, processing offline queue');\n      this.processQueue();\n    });\n\n    // Process queue on page load if online\n    if (navigator.onLine) {\n      setTimeout(() => this.processQueue(), 1000);\n    }\n\n    // Periodic queue processing (in case of missed online events)\n    setInterval(() => {\n      if (navigator.onLine && this.hasItems()) {\n        this.processQueue();\n      }\n    }, 30000); // Every 30 seconds\n  }\n\n  // Get queue statistics\n  static getStatistics() {\n    const queue = this.getQueue();\n    const itemsByType = queue.reduce((acc, item) => {\n      acc[item.type] = (acc[item.type] || 0) + 1;\n      return acc;\n    }, {});\n    const itemsByResource = queue.reduce((acc, item) => {\n      acc[item.resource] = (acc[item.resource] || 0) + 1;\n      return acc;\n    }, {});\n    const timestamps = queue.map(item => item.timestamp);\n    const oldestItem = timestamps.length > 0 ? new Date(Math.min(...timestamps)) : undefined;\n    const newestItem = timestamps.length > 0 ? new Date(Math.max(...timestamps)) : undefined;\n    return {\n      totalItems: queue.length,\n      itemsByType,\n      itemsByResource,\n      oldestItem,\n      newestItem\n    };\n  }\n}\n\n// Hook for using offline queue\nOfflineQueue.QUEUE_KEY = 'offline_queue';\nOfflineQueue.MAX_RETRIES = 3;\nOfflineQueue.RETRY_DELAY = 1000;\n// 1 second base delay\nOfflineQueue.isProcessing = false;\nOfflineQueue.listeners = [];\nexport const useOfflineQueue = () => {\n  _s();\n  const [queue, setQueue] = React.useState(OfflineQueue.getQueue());\n  const [isOnline, setIsOnline] = React.useState(navigator.onLine);\n  React.useEffect(() => {\n    // Listen for online/offline events\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    // Listen for queue changes\n    const unsubscribe = OfflineQueue.addListener(setQueue);\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n      unsubscribe();\n    };\n  }, []);\n  const addToQueue = React.useCallback(item => {\n    OfflineQueue.addToQueue(item);\n  }, []);\n  const processQueue = React.useCallback(() => {\n    OfflineQueue.processQueue();\n  }, []);\n  const clearQueue = React.useCallback(() => {\n    OfflineQueue.clearQueue();\n  }, []);\n  const getStatistics = React.useCallback(() => {\n    return OfflineQueue.getStatistics();\n  }, []);\n  return {\n    queue,\n    isOnline,\n    addToQueue,\n    processQueue,\n    clearQueue,\n    getStatistics,\n    hasItems: queue.length > 0\n  };\n};\n\n// Initialize offline queue when module loads\n_s(useOfflineQueue, \"NU1m55qpDB9+4lspAd49QcRCrDo=\");\nif (typeof window !== 'undefined') {\n  OfflineQueue.initialize();\n}\n\n// Export React import for the hook\nimport React from 'react';","map":{"version":3,"names":["OfflineQueue","addToQueue","item","queueItem","id","crypto","randomUUID","timestamp","Date","now","retryCount","maxRetries","MAX_RETRIES","queue","getQueue","push","saveQueue","notifyListeners","console","log","stored","localStorage","getItem","QUEUE_KEY","JSON","parse","error","warn","setItem","stringify","removeFromQueue","filter","updateRetryCount","find","processQueue","isProcessing","navigator","onLine","length","processQueueItem","delay","RETRY_DELAY","Math","pow","setTimeout","response","fetch","url","method","headers","body","data","undefined","ok","Error","status","statusText","json","clearQueue","removeItem","getQueueSize","hasItems","addListener","listener","listeners","l","forEach","initialize","window","addEventListener","setInterval","getStatistics","itemsByType","reduce","acc","type","itemsByResource","resource","timestamps","map","oldestItem","min","newestItem","max","totalItems","useOfflineQueue","_s","setQueue","React","useState","isOnline","setIsOnline","useEffect","handleOnline","handleOffline","unsubscribe","removeEventListener","useCallback"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/utils/offlineQueue.ts"],"sourcesContent":["import { CacheManager } from './cacheManager';\n\n// Offline queue item interface\nexport interface OfflineQueueItem {\n  id: string;\n  type: 'create' | 'update' | 'delete';\n  resource: 'position' | 'interview';\n  data: any;\n  timestamp: number;\n  retryCount: number;\n  maxRetries: number;\n  url: string;\n  method: string;\n  headers?: Record<string, string>;\n}\n\n// Offline queue manager\nexport class OfflineQueue {\n  private static readonly QUEUE_KEY = 'offline_queue';\n  private static readonly MAX_RETRIES = 3;\n  private static readonly RETRY_DELAY = 1000; // 1 second base delay\n  private static isProcessing = false;\n  private static listeners: Array<(queue: OfflineQueueItem[]) => void> = [];\n\n  // Add item to offline queue\n  static addToQueue(item: Omit<OfflineQueueItem, 'id' | 'timestamp' | 'retryCount' | 'maxRetries'>): void {\n    const queueItem: OfflineQueueItem = {\n      ...item,\n      id: crypto.randomUUID(),\n      timestamp: Date.now(),\n      retryCount: 0,\n      maxRetries: this.MAX_RETRIES,\n    };\n\n    const queue = this.getQueue();\n    queue.push(queueItem);\n    this.saveQueue(queue);\n    this.notifyListeners(queue);\n\n    console.log('Added to offline queue:', queueItem);\n  }\n\n  // Get current queue\n  static getQueue(): OfflineQueueItem[] {\n    try {\n      const stored = localStorage.getItem(this.QUEUE_KEY);\n      return stored ? JSON.parse(stored) : [];\n    } catch (error) {\n      console.warn('Failed to load offline queue:', error);\n      return [];\n    }\n  }\n\n  // Save queue to localStorage\n  private static saveQueue(queue: OfflineQueueItem[]): void {\n    try {\n      localStorage.setItem(this.QUEUE_KEY, JSON.stringify(queue));\n    } catch (error) {\n      console.warn('Failed to save offline queue:', error);\n    }\n  }\n\n  // Remove item from queue\n  static removeFromQueue(id: string): void {\n    const queue = this.getQueue().filter(item => item.id !== id);\n    this.saveQueue(queue);\n    this.notifyListeners(queue);\n  }\n\n  // Update retry count for item\n  private static updateRetryCount(id: string): void {\n    const queue = this.getQueue();\n    const item = queue.find(item => item.id === id);\n    if (item) {\n      item.retryCount++;\n      this.saveQueue(queue);\n      this.notifyListeners(queue);\n    }\n  }\n\n  // Process offline queue\n  static async processQueue(): Promise<void> {\n    if (this.isProcessing || !navigator.onLine) {\n      return;\n    }\n\n    this.isProcessing = true;\n    const queue = this.getQueue();\n\n    console.log(`Processing offline queue with ${queue.length} items`);\n\n    for (const item of queue) {\n      try {\n        await this.processQueueItem(item);\n        this.removeFromQueue(item.id);\n        console.log('Successfully processed offline queue item:', item.id);\n      } catch (error) {\n        console.error('Failed to process offline queue item:', item.id, error);\n        \n        if (item.retryCount < item.maxRetries) {\n          this.updateRetryCount(item.id);\n          // Exponential backoff delay\n          const delay = this.RETRY_DELAY * Math.pow(2, item.retryCount);\n          setTimeout(() => {\n            // Will be processed in next queue processing cycle\n          }, delay);\n        } else {\n          // Max retries reached, remove from queue\n          console.error('Max retries reached for offline queue item:', item.id);\n          this.removeFromQueue(item.id);\n        }\n      }\n    }\n\n    this.isProcessing = false;\n  }\n\n  // Process individual queue item\n  private static async processQueueItem(item: OfflineQueueItem): Promise<void> {\n    const response = await fetch(item.url, {\n      method: item.method,\n      headers: {\n        'Content-Type': 'application/json',\n        ...item.headers,\n      },\n      body: item.data ? JSON.stringify(item.data) : undefined,\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    return response.json();\n  }\n\n  // Clear entire queue\n  static clearQueue(): void {\n    localStorage.removeItem(this.QUEUE_KEY);\n    this.notifyListeners([]);\n  }\n\n  // Get queue size\n  static getQueueSize(): number {\n    return this.getQueue().length;\n  }\n\n  // Check if queue has items\n  static hasItems(): boolean {\n    return this.getQueueSize() > 0;\n  }\n\n  // Add listener for queue changes\n  static addListener(listener: (queue: OfflineQueueItem[]) => void): () => void {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter(l => l !== listener);\n    };\n  }\n\n  // Notify all listeners of queue changes\n  private static notifyListeners(queue: OfflineQueueItem[]): void {\n    this.listeners.forEach(listener => {\n      try {\n        listener(queue);\n      } catch (error) {\n        console.error('Error in offline queue listener:', error);\n      }\n    });\n  }\n\n  // Initialize offline queue\n  static initialize(): void {\n    // Process queue when coming back online\n    window.addEventListener('online', () => {\n      console.log('Network connection restored, processing offline queue');\n      this.processQueue();\n    });\n\n    // Process queue on page load if online\n    if (navigator.onLine) {\n      setTimeout(() => this.processQueue(), 1000);\n    }\n\n    // Periodic queue processing (in case of missed online events)\n    setInterval(() => {\n      if (navigator.onLine && this.hasItems()) {\n        this.processQueue();\n      }\n    }, 30000); // Every 30 seconds\n  }\n\n  // Get queue statistics\n  static getStatistics(): {\n    totalItems: number;\n    itemsByType: Record<string, number>;\n    itemsByResource: Record<string, number>;\n    oldestItem?: Date;\n    newestItem?: Date;\n  } {\n    const queue = this.getQueue();\n    \n    const itemsByType = queue.reduce((acc, item) => {\n      acc[item.type] = (acc[item.type] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const itemsByResource = queue.reduce((acc, item) => {\n      acc[item.resource] = (acc[item.resource] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const timestamps = queue.map(item => item.timestamp);\n    const oldestItem = timestamps.length > 0 ? new Date(Math.min(...timestamps)) : undefined;\n    const newestItem = timestamps.length > 0 ? new Date(Math.max(...timestamps)) : undefined;\n\n    return {\n      totalItems: queue.length,\n      itemsByType,\n      itemsByResource,\n      oldestItem,\n      newestItem,\n    };\n  }\n}\n\n// Hook for using offline queue\nexport const useOfflineQueue = () => {\n  const [queue, setQueue] = React.useState<OfflineQueueItem[]>(OfflineQueue.getQueue());\n  const [isOnline, setIsOnline] = React.useState(navigator.onLine);\n\n  React.useEffect(() => {\n    // Listen for online/offline events\n    const handleOnline = () => setIsOnline(true);\n    const handleOffline = () => setIsOnline(false);\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    // Listen for queue changes\n    const unsubscribe = OfflineQueue.addListener(setQueue);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n      unsubscribe();\n    };\n  }, []);\n\n  const addToQueue = React.useCallback((item: Omit<OfflineQueueItem, 'id' | 'timestamp' | 'retryCount' | 'maxRetries'>) => {\n    OfflineQueue.addToQueue(item);\n  }, []);\n\n  const processQueue = React.useCallback(() => {\n    OfflineQueue.processQueue();\n  }, []);\n\n  const clearQueue = React.useCallback(() => {\n    OfflineQueue.clearQueue();\n  }, []);\n\n  const getStatistics = React.useCallback(() => {\n    return OfflineQueue.getStatistics();\n  }, []);\n\n  return {\n    queue,\n    isOnline,\n    addToQueue,\n    processQueue,\n    clearQueue,\n    getStatistics,\n    hasItems: queue.length > 0,\n  };\n};\n\n// Initialize offline queue when module loads\nif (typeof window !== 'undefined') {\n  OfflineQueue.initialize();\n}\n\n// Export React import for the hook\nimport React from 'react';"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}