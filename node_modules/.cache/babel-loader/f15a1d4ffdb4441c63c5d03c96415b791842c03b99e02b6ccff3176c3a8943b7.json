{"ast":null,"code":"var _s = $RefreshSig$();\n// Performance monitoring utilities\n\n// Performance monitor class\nexport class PerformanceMonitor {\n  // Start performance measurement\n  static startMeasurement(name, type, metadata) {\n    const startTime = performance.now();\n    return () => {\n      const duration = performance.now() - startTime;\n      this.addEntry({\n        name,\n        startTime,\n        duration,\n        type,\n        metadata\n      });\n    };\n  }\n\n  // Add performance entry\n  static addEntry(entry) {\n    this.entries.push(entry);\n\n    // Keep only the most recent entries\n    if (this.entries.length > this.MAX_ENTRIES) {\n      this.entries = this.entries.slice(-this.MAX_ENTRIES);\n    }\n\n    // Notify listeners\n    this.listeners.forEach(listener => {\n      try {\n        listener(entry);\n      } catch (error) {\n        console.error('Error in performance monitor listener:', error);\n      }\n    });\n  }\n\n  // Get all entries\n  static getEntries() {\n    return [...this.entries];\n  }\n\n  // Get entries by type\n  static getEntriesByType(type) {\n    return this.entries.filter(entry => entry.type === type);\n  }\n\n  // Get entries by name pattern\n  static getEntriesByName(namePattern) {\n    return this.entries.filter(entry => entry.name.includes(namePattern));\n  }\n\n  // Get performance metrics\n  static getMetrics() {\n    const averages = {};\n    const totals = {};\n    const counts = {};\n\n    // Group entries by type\n    const entriesByType = this.entries.reduce((acc, entry) => {\n      if (!acc[entry.type]) {\n        acc[entry.type] = [];\n      }\n      acc[entry.type].push(entry);\n      return acc;\n    }, {});\n\n    // Calculate metrics for each type\n    Object.entries(entriesByType).forEach(([type, entries]) => {\n      const durations = entries.map(entry => entry.duration);\n      const total = durations.reduce((sum, duration) => sum + duration, 0);\n      totals[type] = total;\n      counts[type] = entries.length;\n      averages[type] = entries.length > 0 ? total / entries.length : 0;\n    });\n    return {\n      entries: this.entries,\n      averages,\n      totals,\n      counts\n    };\n  }\n\n  // Get slow operations (above threshold)\n  static getSlowOperations(threshold = 1000) {\n    return this.entries.filter(entry => entry.duration > threshold);\n  }\n\n  // Get performance summary\n  static getSummary() {\n    const metrics = this.getMetrics();\n    const slowOps = this.getSlowOperations();\n    const totalDuration = Object.values(metrics.totals).reduce((sum, total) => sum + total, 0);\n    const totalCount = Object.values(metrics.counts).reduce((sum, count) => sum + count, 0);\n    const byType = {};\n    Object.keys(metrics.counts).forEach(type => {\n      byType[type] = {\n        count: metrics.counts[type],\n        average: metrics.averages[type],\n        total: metrics.totals[type]\n      };\n    });\n    return {\n      totalOperations: totalCount,\n      averageDuration: totalCount > 0 ? totalDuration / totalCount : 0,\n      slowOperations: slowOps.length,\n      byType\n    };\n  }\n\n  // Clear all entries\n  static clear() {\n    this.entries = [];\n  }\n\n  // Add listener for new entries\n  static addListener(listener) {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter(l => l !== listener);\n    };\n  }\n\n  // Export performance data\n  static exportData() {\n    const data = {\n      entries: this.entries,\n      metrics: this.getMetrics(),\n      summary: this.getSummary(),\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n      url: window.location.href\n    };\n    return JSON.stringify(data, null, 2);\n  }\n\n  // Monitor Core Web Vitals\n  static monitorWebVitals() {\n    // Largest Contentful Paint (LCP)\n    if ('PerformanceObserver' in window) {\n      try {\n        const lcpObserver = new PerformanceObserver(list => {\n          var _lastEntry$element;\n          const entries = list.getEntries();\n          const lastEntry = entries[entries.length - 1];\n          this.addEntry({\n            name: 'LCP',\n            startTime: lastEntry.startTime,\n            duration: lastEntry.startTime,\n            type: 'render',\n            metadata: {\n              element: (_lastEntry$element = lastEntry.element) === null || _lastEntry$element === void 0 ? void 0 : _lastEntry$element.tagName,\n              url: lastEntry.url\n            }\n          });\n        });\n        lcpObserver.observe({\n          entryTypes: ['largest-contentful-paint']\n        });\n      } catch (error) {\n        console.warn('Failed to observe LCP:', error);\n      }\n\n      // First Input Delay (FID)\n      try {\n        const fidObserver = new PerformanceObserver(list => {\n          const entries = list.getEntries();\n          entries.forEach(entry => {\n            this.addEntry({\n              name: 'FID',\n              startTime: entry.startTime,\n              duration: entry.processingStart - entry.startTime,\n              type: 'render',\n              metadata: {\n                inputType: entry.name\n              }\n            });\n          });\n        });\n        fidObserver.observe({\n          entryTypes: ['first-input']\n        });\n      } catch (error) {\n        console.warn('Failed to observe FID:', error);\n      }\n\n      // Cumulative Layout Shift (CLS)\n      try {\n        const clsObserver = new PerformanceObserver(list => {\n          const entries = list.getEntries();\n          entries.forEach(entry => {\n            if (!entry.hadRecentInput) {\n              var _sources;\n              this.addEntry({\n                name: 'CLS',\n                startTime: entry.startTime,\n                duration: entry.value,\n                type: 'render',\n                metadata: {\n                  value: entry.value,\n                  sources: (_sources = entry.sources) === null || _sources === void 0 ? void 0 : _sources.map(source => {\n                    var _source$node;\n                    return {\n                      element: (_source$node = source.node) === null || _source$node === void 0 ? void 0 : _source$node.tagName\n                    };\n                  })\n                }\n              });\n            }\n          });\n        });\n        clsObserver.observe({\n          entryTypes: ['layout-shift']\n        });\n      } catch (error) {\n        console.warn('Failed to observe CLS:', error);\n      }\n    }\n  }\n\n  // Monitor navigation timing\n  static monitorNavigation() {\n    if ('performance' in window && 'getEntriesByType' in performance) {\n      const navigationEntries = performance.getEntriesByType('navigation');\n      navigationEntries.forEach(entry => {\n        // DNS lookup time\n        if (entry.domainLookupEnd > entry.domainLookupStart) {\n          this.addEntry({\n            name: 'DNS Lookup',\n            startTime: entry.domainLookupStart,\n            duration: entry.domainLookupEnd - entry.domainLookupStart,\n            type: 'navigation'\n          });\n        }\n\n        // TCP connection time\n        if (entry.connectEnd > entry.connectStart) {\n          this.addEntry({\n            name: 'TCP Connection',\n            startTime: entry.connectStart,\n            duration: entry.connectEnd - entry.connectStart,\n            type: 'navigation'\n          });\n        }\n\n        // Request/Response time\n        if (entry.responseEnd > entry.requestStart) {\n          this.addEntry({\n            name: 'Request/Response',\n            startTime: entry.requestStart,\n            duration: entry.responseEnd - entry.requestStart,\n            type: 'navigation'\n          });\n        }\n\n        // DOM processing time\n        if (entry.domComplete > entry.domLoading) {\n          this.addEntry({\n            name: 'DOM Processing',\n            startTime: entry.domLoading,\n            duration: entry.domComplete - entry.domLoading,\n            type: 'navigation'\n          });\n        }\n\n        // Page load time\n        if (entry.loadEventEnd > entry.navigationStart) {\n          this.addEntry({\n            name: 'Page Load',\n            startTime: entry.navigationStart,\n            duration: entry.loadEventEnd - entry.navigationStart,\n            type: 'navigation'\n          });\n        }\n      });\n    }\n  }\n\n  // Monitor resource loading\n  static monitorResources() {\n    if ('PerformanceObserver' in window) {\n      try {\n        const resourceObserver = new PerformanceObserver(list => {\n          const entries = list.getEntries();\n          entries.forEach(entry => {\n            const resourceEntry = entry;\n            this.addEntry({\n              name: `Resource: ${resourceEntry.name.split('/').pop() || 'unknown'}`,\n              startTime: resourceEntry.startTime,\n              duration: resourceEntry.duration,\n              type: 'network',\n              metadata: {\n                url: resourceEntry.name,\n                initiatorType: resourceEntry.initiatorType,\n                transferSize: resourceEntry.transferSize,\n                encodedBodySize: resourceEntry.encodedBodySize,\n                decodedBodySize: resourceEntry.decodedBodySize\n              }\n            });\n          });\n        });\n        resourceObserver.observe({\n          entryTypes: ['resource']\n        });\n      } catch (error) {\n        console.warn('Failed to observe resources:', error);\n      }\n    }\n  }\n\n  // Initialize all monitoring\n  static initialize() {\n    this.monitorWebVitals();\n    this.monitorNavigation();\n    this.monitorResources();\n\n    // Monitor long tasks\n    if ('PerformanceObserver' in window) {\n      try {\n        const longTaskObserver = new PerformanceObserver(list => {\n          const entries = list.getEntries();\n          entries.forEach(entry => {\n            this.addEntry({\n              name: 'Long Task',\n              startTime: entry.startTime,\n              duration: entry.duration,\n              type: 'render',\n              metadata: {\n                attribution: entry.attribution\n              }\n            });\n          });\n        });\n        longTaskObserver.observe({\n          entryTypes: ['longtask']\n        });\n      } catch (error) {\n        console.warn('Failed to observe long tasks:', error);\n      }\n    }\n  }\n}\n\n// React hook for performance monitoring\nPerformanceMonitor.entries = [];\nPerformanceMonitor.MAX_ENTRIES = 1000;\nPerformanceMonitor.listeners = [];\nexport const usePerformanceMonitor = () => {\n  _s();\n  const [metrics, setMetrics] = React.useState(PerformanceMonitor.getMetrics());\n  const [summary, setSummary] = React.useState(PerformanceMonitor.getSummary());\n  React.useEffect(() => {\n    // Update metrics periodically\n    const updateMetrics = () => {\n      setMetrics(PerformanceMonitor.getMetrics());\n      setSummary(PerformanceMonitor.getSummary());\n    };\n    const interval = setInterval(updateMetrics, 5000); // Every 5 seconds\n\n    // Listen for new entries\n    const unsubscribe = PerformanceMonitor.addListener(() => {\n      updateMetrics();\n    });\n    return () => {\n      clearInterval(interval);\n      unsubscribe();\n    };\n  }, []);\n  const startMeasurement = React.useCallback((name, type, metadata) => {\n    return PerformanceMonitor.startMeasurement(name, type, metadata);\n  }, []);\n  const exportData = React.useCallback(() => {\n    const data = PerformanceMonitor.exportData();\n    const blob = new Blob([data], {\n      type: 'application/json'\n    });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `performance-data-${Date.now()}.json`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }, []);\n  const clearData = React.useCallback(() => {\n    PerformanceMonitor.clear();\n    setMetrics(PerformanceMonitor.getMetrics());\n    setSummary(PerformanceMonitor.getSummary());\n  }, []);\n  return {\n    metrics,\n    summary,\n    startMeasurement,\n    exportData,\n    clearData,\n    getSlowOperations: PerformanceMonitor.getSlowOperations\n  };\n};\n\n// Performance measurement decorator\n_s(usePerformanceMonitor, \"BpZ2b1FRrVA7YFxvgGIte4dWaW0=\");\nexport const measurePerformance = (name, type = 'render') => {\n  return (target, propertyKey, descriptor) => {\n    const originalMethod = descriptor.value;\n    descriptor.value = function (...args) {\n      const endMeasurement = PerformanceMonitor.startMeasurement(`${target.constructor.name}.${propertyKey}`, type, {\n        name,\n        args: args.length\n      });\n      try {\n        const result = originalMethod.apply(this, args);\n        if (result instanceof Promise) {\n          return result.finally(() => {\n            endMeasurement();\n          });\n        } else {\n          endMeasurement();\n          return result;\n        }\n      } catch (error) {\n        endMeasurement();\n        throw error;\n      }\n    };\n    return descriptor;\n  };\n};\n\n// Initialize performance monitoring when module loads\nif (typeof window !== 'undefined') {\n  PerformanceMonitor.initialize();\n}\n\n// Export React import for the hook\nimport React from 'react';","map":{"version":3,"names":["PerformanceMonitor","startMeasurement","name","type","metadata","startTime","performance","now","duration","addEntry","entry","entries","push","length","MAX_ENTRIES","slice","listeners","forEach","listener","error","console","getEntries","getEntriesByType","filter","getEntriesByName","namePattern","includes","getMetrics","averages","totals","counts","entriesByType","reduce","acc","Object","durations","map","total","sum","getSlowOperations","threshold","getSummary","metrics","slowOps","totalDuration","values","totalCount","count","byType","keys","average","totalOperations","averageDuration","slowOperations","clear","addListener","l","exportData","data","summary","timestamp","Date","toISOString","userAgent","navigator","url","window","location","href","JSON","stringify","monitorWebVitals","lcpObserver","PerformanceObserver","list","_lastEntry$element","lastEntry","element","tagName","observe","entryTypes","warn","fidObserver","processingStart","inputType","clsObserver","hadRecentInput","_sources","value","sources","source","_source$node","node","monitorNavigation","navigationEntries","domainLookupEnd","domainLookupStart","connectEnd","connectStart","responseEnd","requestStart","domComplete","domLoading","loadEventEnd","navigationStart","monitorResources","resourceObserver","resourceEntry","split","pop","initiatorType","transferSize","encodedBodySize","decodedBodySize","initialize","longTaskObserver","attribution","usePerformanceMonitor","_s","setMetrics","React","useState","setSummary","useEffect","updateMetrics","interval","setInterval","unsubscribe","clearInterval","useCallback","blob","Blob","URL","createObjectURL","a","document","createElement","download","body","appendChild","click","removeChild","revokeObjectURL","clearData","measurePerformance","target","propertyKey","descriptor","originalMethod","args","endMeasurement","constructor","result","apply","Promise","finally"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/utils/performanceMonitor.ts"],"sourcesContent":["// Performance monitoring utilities\nexport interface PerformanceEntry {\n  name: string;\n  startTime: number;\n  duration: number;\n  type: 'query' | 'mutation' | 'render' | 'navigation' | 'cache' | 'network';\n  metadata?: Record<string, any>;\n}\n\nexport interface PerformanceMetrics {\n  entries: PerformanceEntry[];\n  averages: Record<string, number>;\n  totals: Record<string, number>;\n  counts: Record<string, number>;\n}\n\n// Performance monitor class\nexport class PerformanceMonitor {\n  private static entries: PerformanceEntry[] = [];\n  private static readonly MAX_ENTRIES = 1000;\n  private static listeners: Array<(entry: PerformanceEntry) => void> = [];\n\n  // Start performance measurement\n  static startMeasurement(name: string, type: PerformanceEntry['type'], metadata?: Record<string, any>): () => void {\n    const startTime = performance.now();\n    \n    return () => {\n      const duration = performance.now() - startTime;\n      this.addEntry({\n        name,\n        startTime,\n        duration,\n        type,\n        metadata,\n      });\n    };\n  }\n\n  // Add performance entry\n  static addEntry(entry: PerformanceEntry): void {\n    this.entries.push(entry);\n    \n    // Keep only the most recent entries\n    if (this.entries.length > this.MAX_ENTRIES) {\n      this.entries = this.entries.slice(-this.MAX_ENTRIES);\n    }\n\n    // Notify listeners\n    this.listeners.forEach(listener => {\n      try {\n        listener(entry);\n      } catch (error) {\n        console.error('Error in performance monitor listener:', error);\n      }\n    });\n  }\n\n  // Get all entries\n  static getEntries(): PerformanceEntry[] {\n    return [...this.entries];\n  }\n\n  // Get entries by type\n  static getEntriesByType(type: PerformanceEntry['type']): PerformanceEntry[] {\n    return this.entries.filter(entry => entry.type === type);\n  }\n\n  // Get entries by name pattern\n  static getEntriesByName(namePattern: string): PerformanceEntry[] {\n    return this.entries.filter(entry => entry.name.includes(namePattern));\n  }\n\n  // Get performance metrics\n  static getMetrics(): PerformanceMetrics {\n    const averages: Record<string, number> = {};\n    const totals: Record<string, number> = {};\n    const counts: Record<string, number> = {};\n\n    // Group entries by type\n    const entriesByType = this.entries.reduce((acc, entry) => {\n      if (!acc[entry.type]) {\n        acc[entry.type] = [];\n      }\n      acc[entry.type].push(entry);\n      return acc;\n    }, {} as Record<string, PerformanceEntry[]>);\n\n    // Calculate metrics for each type\n    Object.entries(entriesByType).forEach(([type, entries]) => {\n      const durations = entries.map(entry => entry.duration);\n      const total = durations.reduce((sum, duration) => sum + duration, 0);\n      \n      totals[type] = total;\n      counts[type] = entries.length;\n      averages[type] = entries.length > 0 ? total / entries.length : 0;\n    });\n\n    return {\n      entries: this.entries,\n      averages,\n      totals,\n      counts,\n    };\n  }\n\n  // Get slow operations (above threshold)\n  static getSlowOperations(threshold: number = 1000): PerformanceEntry[] {\n    return this.entries.filter(entry => entry.duration > threshold);\n  }\n\n  // Get performance summary\n  static getSummary(): {\n    totalOperations: number;\n    averageDuration: number;\n    slowOperations: number;\n    byType: Record<string, { count: number; average: number; total: number }>;\n  } {\n    const metrics = this.getMetrics();\n    const slowOps = this.getSlowOperations();\n    \n    const totalDuration = Object.values(metrics.totals).reduce((sum, total) => sum + total, 0);\n    const totalCount = Object.values(metrics.counts).reduce((sum, count) => sum + count, 0);\n\n    const byType: Record<string, { count: number; average: number; total: number }> = {};\n    Object.keys(metrics.counts).forEach(type => {\n      byType[type] = {\n        count: metrics.counts[type],\n        average: metrics.averages[type],\n        total: metrics.totals[type],\n      };\n    });\n\n    return {\n      totalOperations: totalCount,\n      averageDuration: totalCount > 0 ? totalDuration / totalCount : 0,\n      slowOperations: slowOps.length,\n      byType,\n    };\n  }\n\n  // Clear all entries\n  static clear(): void {\n    this.entries = [];\n  }\n\n  // Add listener for new entries\n  static addListener(listener: (entry: PerformanceEntry) => void): () => void {\n    this.listeners.push(listener);\n    return () => {\n      this.listeners = this.listeners.filter(l => l !== listener);\n    };\n  }\n\n  // Export performance data\n  static exportData(): string {\n    const data = {\n      entries: this.entries,\n      metrics: this.getMetrics(),\n      summary: this.getSummary(),\n      timestamp: new Date().toISOString(),\n      userAgent: navigator.userAgent,\n      url: window.location.href,\n    };\n\n    return JSON.stringify(data, null, 2);\n  }\n\n  // Monitor Core Web Vitals\n  static monitorWebVitals(): void {\n    // Largest Contentful Paint (LCP)\n    if ('PerformanceObserver' in window) {\n      try {\n        const lcpObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          const lastEntry = entries[entries.length - 1];\n          \n          this.addEntry({\n            name: 'LCP',\n            startTime: lastEntry.startTime,\n            duration: lastEntry.startTime,\n            type: 'render',\n            metadata: {\n              element: lastEntry.element?.tagName,\n              url: lastEntry.url,\n            },\n          });\n        });\n        \n        lcpObserver.observe({ entryTypes: ['largest-contentful-paint'] });\n      } catch (error) {\n        console.warn('Failed to observe LCP:', error);\n      }\n\n      // First Input Delay (FID)\n      try {\n        const fidObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          entries.forEach(entry => {\n            this.addEntry({\n              name: 'FID',\n              startTime: entry.startTime,\n              duration: entry.processingStart - entry.startTime,\n              type: 'render',\n              metadata: {\n                inputType: (entry as any).name,\n              },\n            });\n          });\n        });\n        \n        fidObserver.observe({ entryTypes: ['first-input'] });\n      } catch (error) {\n        console.warn('Failed to observe FID:', error);\n      }\n\n      // Cumulative Layout Shift (CLS)\n      try {\n        const clsObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          entries.forEach(entry => {\n            if (!(entry as any).hadRecentInput) {\n              this.addEntry({\n                name: 'CLS',\n                startTime: entry.startTime,\n                duration: (entry as any).value,\n                type: 'render',\n                metadata: {\n                  value: (entry as any).value,\n                  sources: (entry as any).sources?.map((source: any) => ({\n                    element: source.node?.tagName,\n                  })),\n                },\n              });\n            }\n          });\n        });\n        \n        clsObserver.observe({ entryTypes: ['layout-shift'] });\n      } catch (error) {\n        console.warn('Failed to observe CLS:', error);\n      }\n    }\n  }\n\n  // Monitor navigation timing\n  static monitorNavigation(): void {\n    if ('performance' in window && 'getEntriesByType' in performance) {\n      const navigationEntries = performance.getEntriesByType('navigation') as PerformanceNavigationTiming[];\n      \n      navigationEntries.forEach(entry => {\n        // DNS lookup time\n        if (entry.domainLookupEnd > entry.domainLookupStart) {\n          this.addEntry({\n            name: 'DNS Lookup',\n            startTime: entry.domainLookupStart,\n            duration: entry.domainLookupEnd - entry.domainLookupStart,\n            type: 'navigation',\n          });\n        }\n\n        // TCP connection time\n        if (entry.connectEnd > entry.connectStart) {\n          this.addEntry({\n            name: 'TCP Connection',\n            startTime: entry.connectStart,\n            duration: entry.connectEnd - entry.connectStart,\n            type: 'navigation',\n          });\n        }\n\n        // Request/Response time\n        if (entry.responseEnd > entry.requestStart) {\n          this.addEntry({\n            name: 'Request/Response',\n            startTime: entry.requestStart,\n            duration: entry.responseEnd - entry.requestStart,\n            type: 'navigation',\n          });\n        }\n\n        // DOM processing time\n        if (entry.domComplete > entry.domLoading) {\n          this.addEntry({\n            name: 'DOM Processing',\n            startTime: entry.domLoading,\n            duration: entry.domComplete - entry.domLoading,\n            type: 'navigation',\n          });\n        }\n\n        // Page load time\n        if (entry.loadEventEnd > entry.navigationStart) {\n          this.addEntry({\n            name: 'Page Load',\n            startTime: entry.navigationStart,\n            duration: entry.loadEventEnd - entry.navigationStart,\n            type: 'navigation',\n          });\n        }\n      });\n    }\n  }\n\n  // Monitor resource loading\n  static monitorResources(): void {\n    if ('PerformanceObserver' in window) {\n      try {\n        const resourceObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          entries.forEach(entry => {\n            const resourceEntry = entry as PerformanceResourceTiming;\n            \n            this.addEntry({\n              name: `Resource: ${resourceEntry.name.split('/').pop() || 'unknown'}`,\n              startTime: resourceEntry.startTime,\n              duration: resourceEntry.duration,\n              type: 'network',\n              metadata: {\n                url: resourceEntry.name,\n                initiatorType: resourceEntry.initiatorType,\n                transferSize: resourceEntry.transferSize,\n                encodedBodySize: resourceEntry.encodedBodySize,\n                decodedBodySize: resourceEntry.decodedBodySize,\n              },\n            });\n          });\n        });\n        \n        resourceObserver.observe({ entryTypes: ['resource'] });\n      } catch (error) {\n        console.warn('Failed to observe resources:', error);\n      }\n    }\n  }\n\n  // Initialize all monitoring\n  static initialize(): void {\n    this.monitorWebVitals();\n    this.monitorNavigation();\n    this.monitorResources();\n\n    // Monitor long tasks\n    if ('PerformanceObserver' in window) {\n      try {\n        const longTaskObserver = new PerformanceObserver((list) => {\n          const entries = list.getEntries();\n          entries.forEach(entry => {\n            this.addEntry({\n              name: 'Long Task',\n              startTime: entry.startTime,\n              duration: entry.duration,\n              type: 'render',\n              metadata: {\n                attribution: (entry as any).attribution,\n              },\n            });\n          });\n        });\n        \n        longTaskObserver.observe({ entryTypes: ['longtask'] });\n      } catch (error) {\n        console.warn('Failed to observe long tasks:', error);\n      }\n    }\n  }\n}\n\n// React hook for performance monitoring\nexport const usePerformanceMonitor = () => {\n  const [metrics, setMetrics] = React.useState<PerformanceMetrics>(PerformanceMonitor.getMetrics());\n  const [summary, setSummary] = React.useState(PerformanceMonitor.getSummary());\n\n  React.useEffect(() => {\n    // Update metrics periodically\n    const updateMetrics = () => {\n      setMetrics(PerformanceMonitor.getMetrics());\n      setSummary(PerformanceMonitor.getSummary());\n    };\n\n    const interval = setInterval(updateMetrics, 5000); // Every 5 seconds\n\n    // Listen for new entries\n    const unsubscribe = PerformanceMonitor.addListener(() => {\n      updateMetrics();\n    });\n\n    return () => {\n      clearInterval(interval);\n      unsubscribe();\n    };\n  }, []);\n\n  const startMeasurement = React.useCallback((name: string, type: PerformanceEntry['type'], metadata?: Record<string, any>) => {\n    return PerformanceMonitor.startMeasurement(name, type, metadata);\n  }, []);\n\n  const exportData = React.useCallback(() => {\n    const data = PerformanceMonitor.exportData();\n    const blob = new Blob([data], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `performance-data-${Date.now()}.json`;\n    document.body.appendChild(a);\n    a.click();\n    document.body.removeChild(a);\n    URL.revokeObjectURL(url);\n  }, []);\n\n  const clearData = React.useCallback(() => {\n    PerformanceMonitor.clear();\n    setMetrics(PerformanceMonitor.getMetrics());\n    setSummary(PerformanceMonitor.getSummary());\n  }, []);\n\n  return {\n    metrics,\n    summary,\n    startMeasurement,\n    exportData,\n    clearData,\n    getSlowOperations: PerformanceMonitor.getSlowOperations,\n  };\n};\n\n// Performance measurement decorator\nexport const measurePerformance = (name: string, type: PerformanceEntry['type'] = 'render') => {\n  return (target: any, propertyKey: string, descriptor: PropertyDescriptor) => {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: any[]) {\n      const endMeasurement = PerformanceMonitor.startMeasurement(\n        `${target.constructor.name}.${propertyKey}`,\n        type,\n        { name, args: args.length }\n      );\n\n      try {\n        const result = originalMethod.apply(this, args);\n        \n        if (result instanceof Promise) {\n          return result.finally(() => {\n            endMeasurement();\n          });\n        } else {\n          endMeasurement();\n          return result;\n        }\n      } catch (error) {\n        endMeasurement();\n        throw error;\n      }\n    };\n\n    return descriptor;\n  };\n};\n\n// Initialize performance monitoring when module loads\nif (typeof window !== 'undefined') {\n  PerformanceMonitor.initialize();\n}\n\n// Export React import for the hook\nimport React from 'react';"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}