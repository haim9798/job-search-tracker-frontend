{"ast":null,"code":"var _s = $RefreshSig$();\n// Cache persistence configuration\n\n// Default persistence configuration\nconst DEFAULT_CONFIG = {\n  version: '1.0',\n  maxAge: 24 * 60 * 60 * 1000,\n  // 24 hours\n  compress: false,\n  includeQueries: ['positions', 'interviews', 'statistics', 'auth'],\n  excludeQueries: ['temp', 'draft']\n};\n\n// Persisted cache entry\n\n// Cache persistence manager\nexport class CachePersistence {\n  // Set persistence configuration\n  static setConfig(config) {\n    this.config = {\n      ...DEFAULT_CONFIG,\n      ...config\n    };\n    localStorage.setItem(this.CONFIG_KEY, JSON.stringify(this.config));\n  }\n\n  // Get persistence configuration\n  static getConfig() {\n    try {\n      const stored = localStorage.getItem(this.CONFIG_KEY);\n      if (stored) {\n        this.config = {\n          ...DEFAULT_CONFIG,\n          ...JSON.parse(stored)\n        };\n      }\n    } catch (error) {\n      console.warn('Failed to load cache persistence config:', error);\n    }\n    return this.config;\n  }\n\n  // Check if query should be persisted\n  static shouldPersistQuery(queryKey) {\n    const keyString = JSON.stringify(queryKey);\n\n    // Check exclude patterns\n    if (this.config.excludeQueries.some(pattern => keyString.includes(pattern))) {\n      return false;\n    }\n\n    // Check include patterns\n    if (this.config.includeQueries.length > 0) {\n      return this.config.includeQueries.some(pattern => keyString.includes(pattern));\n    }\n    return true;\n  }\n\n  // Persist query client cache\n  static persistCache(queryClient) {\n    try {\n      const queryCache = queryClient.getQueryCache();\n      const queries = queryCache.getAll();\n      const persistedEntries = [];\n      queries.forEach(query => {\n        if (query.state.data !== undefined && query.state.status === 'success' && this.shouldPersistQuery(query.queryKey)) {\n          const entry = {\n            queryKey: query.queryKey,\n            data: query.state.data,\n            timestamp: Date.now(),\n            version: this.config.version,\n            dataUpdatedAt: query.state.dataUpdatedAt,\n            staleTime: query.options.staleTime\n          };\n          persistedEntries.push(entry);\n        }\n      });\n      const cacheData = {\n        entries: persistedEntries,\n        timestamp: Date.now(),\n        version: this.config.version\n      };\n      const serialized = this.config.compress ? this.compressData(JSON.stringify(cacheData)) : JSON.stringify(cacheData);\n      localStorage.setItem(this.CACHE_KEY, serialized);\n      console.log(`Persisted ${persistedEntries.length} cache entries`);\n    } catch (error) {\n      console.error('Failed to persist cache:', error);\n    }\n  }\n\n  // Restore query client cache\n  static restoreCache(queryClient) {\n    try {\n      const stored = localStorage.getItem(this.CACHE_KEY);\n      if (!stored) {\n        return;\n      }\n      const serialized = this.config.compress ? this.decompressData(stored) : stored;\n      const cacheData = JSON.parse(serialized);\n\n      // Check version compatibility\n      if (cacheData.version !== this.config.version) {\n        console.log('Cache version mismatch, clearing persisted cache');\n        localStorage.removeItem(this.CACHE_KEY);\n        return;\n      }\n\n      // Check if cache is too old\n      if (Date.now() - cacheData.timestamp > this.config.maxAge) {\n        console.log('Persisted cache is too old, clearing');\n        localStorage.removeItem(this.CACHE_KEY);\n        return;\n      }\n      const queryCache = queryClient.getQueryCache();\n      let restoredCount = 0;\n      cacheData.entries.forEach(entry => {\n        try {\n          // Check if entry is still valid\n          const entryAge = Date.now() - entry.dataUpdatedAt;\n          const isStale = entry.staleTime ? entryAge > entry.staleTime : false;\n          if (!isStale || entryAge < this.config.maxAge) {\n            queryCache.build(queryClient, {\n              queryKey: entry.queryKey,\n              queryFn: () => Promise.resolve(entry.data)\n            }).setData(entry.data, {\n              updatedAt: entry.dataUpdatedAt\n            });\n            restoredCount++;\n          }\n        } catch (error) {\n          console.warn('Failed to restore cache entry:', entry.queryKey, error);\n        }\n      });\n      console.log(`Restored ${restoredCount} cache entries from persistence`);\n    } catch (error) {\n      console.error('Failed to restore cache:', error);\n      // Clear corrupted cache\n      localStorage.removeItem(this.CACHE_KEY);\n    }\n  }\n\n  // Clear persisted cache\n  static clearPersistedCache() {\n    localStorage.removeItem(this.CACHE_KEY);\n  }\n\n  // Get persisted cache size\n  static getPersistedCacheSize() {\n    try {\n      var _cacheData$entries;\n      const stored = localStorage.getItem(this.CACHE_KEY);\n      if (!stored) {\n        return {\n          size: 0,\n          entryCount: 0\n        };\n      }\n      const serialized = this.config.compress ? this.decompressData(stored) : stored;\n      const cacheData = JSON.parse(serialized);\n      return {\n        size: new Blob([stored]).size,\n        entryCount: ((_cacheData$entries = cacheData.entries) === null || _cacheData$entries === void 0 ? void 0 : _cacheData$entries.length) || 0\n      };\n    } catch (error) {\n      console.warn('Failed to get persisted cache size:', error);\n      return {\n        size: 0,\n        entryCount: 0\n      };\n    }\n  }\n\n  // Compress data (simple base64 compression)\n  static compressData(data) {\n    try {\n      return btoa(data);\n    } catch (error) {\n      console.warn('Failed to compress data:', error);\n      return data;\n    }\n  }\n\n  // Decompress data\n  static decompressData(data) {\n    try {\n      return atob(data);\n    } catch (error) {\n      console.warn('Failed to decompress data:', error);\n      return data;\n    }\n  }\n\n  // Auto-persist setup\n  static setupAutoPersist(queryClient, interval = 30000) {\n    // Persist on page unload\n    const handleBeforeUnload = () => {\n      this.persistCache(queryClient);\n    };\n\n    // Persist periodically\n    const persistInterval = setInterval(() => {\n      this.persistCache(queryClient);\n    }, interval);\n\n    // Persist on visibility change (when tab becomes hidden)\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        this.persistCache(queryClient);\n      }\n    };\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n    return () => {\n      clearInterval(persistInterval);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }\n\n  // Selective cache restoration\n  static restoreSelectiveCache(queryClient, queryKeyPatterns) {\n    try {\n      const stored = localStorage.getItem(this.CACHE_KEY);\n      if (!stored) {\n        return;\n      }\n      const serialized = this.config.compress ? this.decompressData(stored) : stored;\n      const cacheData = JSON.parse(serialized);\n      if (cacheData.version !== this.config.version) {\n        return;\n      }\n      const queryCache = queryClient.getQueryCache();\n      let restoredCount = 0;\n      cacheData.entries.forEach(entry => {\n        const keyString = JSON.stringify(entry.queryKey);\n        const shouldRestore = queryKeyPatterns.some(pattern => keyString.includes(pattern));\n        if (shouldRestore) {\n          try {\n            queryCache.build(queryClient, {\n              queryKey: entry.queryKey,\n              queryFn: () => Promise.resolve(entry.data)\n            }).setData(entry.data, {\n              updatedAt: entry.dataUpdatedAt\n            });\n            restoredCount++;\n          } catch (error) {\n            console.warn('Failed to restore selective cache entry:', entry.queryKey, error);\n          }\n        }\n      });\n      console.log(`Selectively restored ${restoredCount} cache entries`);\n    } catch (error) {\n      console.error('Failed to restore selective cache:', error);\n    }\n  }\n\n  // Cache migration for version updates\n  static migrateCache(queryClient, migrationFn) {\n    try {\n      const stored = localStorage.getItem(this.CACHE_KEY);\n      if (!stored) {\n        return;\n      }\n      const serialized = this.config.compress ? this.decompressData(stored) : stored;\n      const cacheData = JSON.parse(serialized);\n\n      // Apply migration to each entry\n      const migratedEntries = cacheData.entries.map(entry => {\n        try {\n          return {\n            ...entry,\n            data: migrationFn(entry.data),\n            version: this.config.version\n          };\n        } catch (error) {\n          console.warn('Failed to migrate cache entry:', entry.queryKey, error);\n          return null;\n        }\n      }).filter(Boolean);\n\n      // Save migrated cache\n      const migratedCacheData = {\n        entries: migratedEntries,\n        timestamp: Date.now(),\n        version: this.config.version\n      };\n      const migratedSerialized = this.config.compress ? this.compressData(JSON.stringify(migratedCacheData)) : JSON.stringify(migratedCacheData);\n      localStorage.setItem(this.CACHE_KEY, migratedSerialized);\n      console.log(`Migrated ${migratedEntries.length} cache entries`);\n    } catch (error) {\n      console.error('Failed to migrate cache:', error);\n      // Clear corrupted cache\n      localStorage.removeItem(this.CACHE_KEY);\n    }\n  }\n}\n\n// Hook for cache persistence\nCachePersistence.CACHE_KEY = 'react_query_cache';\nCachePersistence.CONFIG_KEY = 'cache_persistence_config';\nCachePersistence.config = DEFAULT_CONFIG;\nexport const useCachePersistence = queryClient => {\n  _s();\n  const [isRestored, setIsRestored] = React.useState(false);\n  const [persistenceStats, setPersistenceStats] = React.useState({\n    size: 0,\n    entryCount: 0\n  });\n  React.useEffect(() => {\n    // Restore cache on mount\n    CachePersistence.restoreCache(queryClient);\n    setIsRestored(true);\n\n    // Set up auto-persist\n    const cleanup = CachePersistence.setupAutoPersist(queryClient);\n\n    // Update stats\n    const updateStats = () => {\n      setPersistenceStats(CachePersistence.getPersistedCacheSize());\n    };\n    updateStats();\n    const statsInterval = setInterval(updateStats, 10000); // Every 10 seconds\n\n    return () => {\n      cleanup();\n      clearInterval(statsInterval);\n    };\n  }, [queryClient]);\n  const persistCache = React.useCallback(() => {\n    CachePersistence.persistCache(queryClient);\n  }, [queryClient]);\n  const clearPersistedCache = React.useCallback(() => {\n    CachePersistence.clearPersistedCache();\n    setPersistenceStats({\n      size: 0,\n      entryCount: 0\n    });\n  }, []);\n  const setConfig = React.useCallback(config => {\n    CachePersistence.setConfig(config);\n  }, []);\n  return {\n    isRestored,\n    persistenceStats,\n    persistCache,\n    clearPersistedCache,\n    setConfig\n  };\n};\n\n// Export React import for the hook\n_s(useCachePersistence, \"g1x4Gqe6IaI8T+iZmH4gBEJFHuw=\");\nimport React from 'react';","map":{"version":3,"names":["DEFAULT_CONFIG","version","maxAge","compress","includeQueries","excludeQueries","CachePersistence","setConfig","config","localStorage","setItem","CONFIG_KEY","JSON","stringify","getConfig","stored","getItem","parse","error","console","warn","shouldPersistQuery","queryKey","keyString","some","pattern","includes","length","persistCache","queryClient","queryCache","getQueryCache","queries","getAll","persistedEntries","forEach","query","state","data","undefined","status","entry","timestamp","Date","now","dataUpdatedAt","staleTime","options","push","cacheData","entries","serialized","compressData","CACHE_KEY","log","restoreCache","decompressData","removeItem","restoredCount","entryAge","isStale","build","queryFn","Promise","resolve","setData","updatedAt","clearPersistedCache","getPersistedCacheSize","_cacheData$entries","size","entryCount","Blob","btoa","atob","setupAutoPersist","interval","handleBeforeUnload","persistInterval","setInterval","handleVisibilityChange","document","hidden","window","addEventListener","clearInterval","removeEventListener","restoreSelectiveCache","queryKeyPatterns","shouldRestore","migrateCache","migrationFn","migratedEntries","map","filter","Boolean","migratedCacheData","migratedSerialized","useCachePersistence","_s","isRestored","setIsRestored","React","useState","persistenceStats","setPersistenceStats","useEffect","cleanup","updateStats","statsInterval","useCallback"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/utils/cachePersistence.ts"],"sourcesContent":["import { QueryClient } from '@tanstack/react-query';\nimport { CacheManager } from './cacheManager';\n\n// Cache persistence configuration\ninterface PersistenceConfig {\n  version: string;\n  maxAge: number;\n  compress: boolean;\n  includeQueries: string[];\n  excludeQueries: string[];\n}\n\n// Default persistence configuration\nconst DEFAULT_CONFIG: PersistenceConfig = {\n  version: '1.0',\n  maxAge: 24 * 60 * 60 * 1000, // 24 hours\n  compress: false,\n  includeQueries: [\n    'positions',\n    'interviews',\n    'statistics',\n    'auth',\n  ],\n  excludeQueries: [\n    'temp',\n    'draft',\n  ],\n};\n\n// Persisted cache entry\ninterface PersistedCacheEntry {\n  queryKey: any[];\n  data: any;\n  timestamp: number;\n  version: string;\n  dataUpdatedAt: number;\n  staleTime?: number;\n}\n\n// Cache persistence manager\nexport class CachePersistence {\n  private static readonly CACHE_KEY = 'react_query_cache';\n  private static readonly CONFIG_KEY = 'cache_persistence_config';\n  private static config: PersistenceConfig = DEFAULT_CONFIG;\n\n  // Set persistence configuration\n  static setConfig(config: Partial<PersistenceConfig>): void {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    localStorage.setItem(this.CONFIG_KEY, JSON.stringify(this.config));\n  }\n\n  // Get persistence configuration\n  static getConfig(): PersistenceConfig {\n    try {\n      const stored = localStorage.getItem(this.CONFIG_KEY);\n      if (stored) {\n        this.config = { ...DEFAULT_CONFIG, ...JSON.parse(stored) };\n      }\n    } catch (error) {\n      console.warn('Failed to load cache persistence config:', error);\n    }\n    return this.config;\n  }\n\n  // Check if query should be persisted\n  private static shouldPersistQuery(queryKey: any[]): boolean {\n    const keyString = JSON.stringify(queryKey);\n    \n    // Check exclude patterns\n    if (this.config.excludeQueries.some(pattern => keyString.includes(pattern))) {\n      return false;\n    }\n\n    // Check include patterns\n    if (this.config.includeQueries.length > 0) {\n      return this.config.includeQueries.some(pattern => keyString.includes(pattern));\n    }\n\n    return true;\n  }\n\n  // Persist query client cache\n  static persistCache(queryClient: QueryClient): void {\n    try {\n      const queryCache = queryClient.getQueryCache();\n      const queries = queryCache.getAll();\n      \n      const persistedEntries: PersistedCacheEntry[] = [];\n\n      queries.forEach(query => {\n        if (\n          query.state.data !== undefined &&\n          query.state.status === 'success' &&\n          this.shouldPersistQuery(query.queryKey)\n        ) {\n          const entry: PersistedCacheEntry = {\n            queryKey: query.queryKey,\n            data: query.state.data,\n            timestamp: Date.now(),\n            version: this.config.version,\n            dataUpdatedAt: query.state.dataUpdatedAt,\n            staleTime: query.options.staleTime,\n          };\n\n          persistedEntries.push(entry);\n        }\n      });\n\n      const cacheData = {\n        entries: persistedEntries,\n        timestamp: Date.now(),\n        version: this.config.version,\n      };\n\n      const serialized = this.config.compress \n        ? this.compressData(JSON.stringify(cacheData))\n        : JSON.stringify(cacheData);\n\n      localStorage.setItem(this.CACHE_KEY, serialized);\n      \n      console.log(`Persisted ${persistedEntries.length} cache entries`);\n    } catch (error) {\n      console.error('Failed to persist cache:', error);\n    }\n  }\n\n  // Restore query client cache\n  static restoreCache(queryClient: QueryClient): void {\n    try {\n      const stored = localStorage.getItem(this.CACHE_KEY);\n      if (!stored) {\n        return;\n      }\n\n      const serialized = this.config.compress \n        ? this.decompressData(stored)\n        : stored;\n\n      const cacheData = JSON.parse(serialized);\n\n      // Check version compatibility\n      if (cacheData.version !== this.config.version) {\n        console.log('Cache version mismatch, clearing persisted cache');\n        localStorage.removeItem(this.CACHE_KEY);\n        return;\n      }\n\n      // Check if cache is too old\n      if (Date.now() - cacheData.timestamp > this.config.maxAge) {\n        console.log('Persisted cache is too old, clearing');\n        localStorage.removeItem(this.CACHE_KEY);\n        return;\n      }\n\n      const queryCache = queryClient.getQueryCache();\n      let restoredCount = 0;\n\n      cacheData.entries.forEach((entry: PersistedCacheEntry) => {\n        try {\n          // Check if entry is still valid\n          const entryAge = Date.now() - entry.dataUpdatedAt;\n          const isStale = entry.staleTime ? entryAge > entry.staleTime : false;\n\n          if (!isStale || entryAge < this.config.maxAge) {\n            queryCache.build(queryClient, {\n              queryKey: entry.queryKey,\n              queryFn: () => Promise.resolve(entry.data),\n            }).setData(entry.data, {\n              updatedAt: entry.dataUpdatedAt,\n            });\n\n            restoredCount++;\n          }\n        } catch (error) {\n          console.warn('Failed to restore cache entry:', entry.queryKey, error);\n        }\n      });\n\n      console.log(`Restored ${restoredCount} cache entries from persistence`);\n    } catch (error) {\n      console.error('Failed to restore cache:', error);\n      // Clear corrupted cache\n      localStorage.removeItem(this.CACHE_KEY);\n    }\n  }\n\n  // Clear persisted cache\n  static clearPersistedCache(): void {\n    localStorage.removeItem(this.CACHE_KEY);\n  }\n\n  // Get persisted cache size\n  static getPersistedCacheSize(): { size: number; entryCount: number } {\n    try {\n      const stored = localStorage.getItem(this.CACHE_KEY);\n      if (!stored) {\n        return { size: 0, entryCount: 0 };\n      }\n\n      const serialized = this.config.compress \n        ? this.decompressData(stored)\n        : stored;\n\n      const cacheData = JSON.parse(serialized);\n      \n      return {\n        size: new Blob([stored]).size,\n        entryCount: cacheData.entries?.length || 0,\n      };\n    } catch (error) {\n      console.warn('Failed to get persisted cache size:', error);\n      return { size: 0, entryCount: 0 };\n    }\n  }\n\n  // Compress data (simple base64 compression)\n  private static compressData(data: string): string {\n    try {\n      return btoa(data);\n    } catch (error) {\n      console.warn('Failed to compress data:', error);\n      return data;\n    }\n  }\n\n  // Decompress data\n  private static decompressData(data: string): string {\n    try {\n      return atob(data);\n    } catch (error) {\n      console.warn('Failed to decompress data:', error);\n      return data;\n    }\n  }\n\n  // Auto-persist setup\n  static setupAutoPersist(queryClient: QueryClient, interval: number = 30000): () => void {\n    // Persist on page unload\n    const handleBeforeUnload = () => {\n      this.persistCache(queryClient);\n    };\n\n    // Persist periodically\n    const persistInterval = setInterval(() => {\n      this.persistCache(queryClient);\n    }, interval);\n\n    // Persist on visibility change (when tab becomes hidden)\n    const handleVisibilityChange = () => {\n      if (document.hidden) {\n        this.persistCache(queryClient);\n      }\n    };\n\n    window.addEventListener('beforeunload', handleBeforeUnload);\n    document.addEventListener('visibilitychange', handleVisibilityChange);\n\n    return () => {\n      clearInterval(persistInterval);\n      window.removeEventListener('beforeunload', handleBeforeUnload);\n      document.removeEventListener('visibilitychange', handleVisibilityChange);\n    };\n  }\n\n  // Selective cache restoration\n  static restoreSelectiveCache(\n    queryClient: QueryClient, \n    queryKeyPatterns: string[]\n  ): void {\n    try {\n      const stored = localStorage.getItem(this.CACHE_KEY);\n      if (!stored) {\n        return;\n      }\n\n      const serialized = this.config.compress \n        ? this.decompressData(stored)\n        : stored;\n\n      const cacheData = JSON.parse(serialized);\n\n      if (cacheData.version !== this.config.version) {\n        return;\n      }\n\n      const queryCache = queryClient.getQueryCache();\n      let restoredCount = 0;\n\n      cacheData.entries.forEach((entry: PersistedCacheEntry) => {\n        const keyString = JSON.stringify(entry.queryKey);\n        const shouldRestore = queryKeyPatterns.some(pattern => \n          keyString.includes(pattern)\n        );\n\n        if (shouldRestore) {\n          try {\n            queryCache.build(queryClient, {\n              queryKey: entry.queryKey,\n              queryFn: () => Promise.resolve(entry.data),\n            }).setData(entry.data, {\n              updatedAt: entry.dataUpdatedAt,\n            });\n\n            restoredCount++;\n          } catch (error) {\n            console.warn('Failed to restore selective cache entry:', entry.queryKey, error);\n          }\n        }\n      });\n\n      console.log(`Selectively restored ${restoredCount} cache entries`);\n    } catch (error) {\n      console.error('Failed to restore selective cache:', error);\n    }\n  }\n\n  // Cache migration for version updates\n  static migrateCache(\n    queryClient: QueryClient,\n    migrationFn: (oldData: any) => any\n  ): void {\n    try {\n      const stored = localStorage.getItem(this.CACHE_KEY);\n      if (!stored) {\n        return;\n      }\n\n      const serialized = this.config.compress \n        ? this.decompressData(stored)\n        : stored;\n\n      const cacheData = JSON.parse(serialized);\n\n      // Apply migration to each entry\n      const migratedEntries = cacheData.entries.map((entry: PersistedCacheEntry) => {\n        try {\n          return {\n            ...entry,\n            data: migrationFn(entry.data),\n            version: this.config.version,\n          };\n        } catch (error) {\n          console.warn('Failed to migrate cache entry:', entry.queryKey, error);\n          return null;\n        }\n      }).filter(Boolean);\n\n      // Save migrated cache\n      const migratedCacheData = {\n        entries: migratedEntries,\n        timestamp: Date.now(),\n        version: this.config.version,\n      };\n\n      const migratedSerialized = this.config.compress \n        ? this.compressData(JSON.stringify(migratedCacheData))\n        : JSON.stringify(migratedCacheData);\n\n      localStorage.setItem(this.CACHE_KEY, migratedSerialized);\n\n      console.log(`Migrated ${migratedEntries.length} cache entries`);\n    } catch (error) {\n      console.error('Failed to migrate cache:', error);\n      // Clear corrupted cache\n      localStorage.removeItem(this.CACHE_KEY);\n    }\n  }\n}\n\n// Hook for cache persistence\nexport const useCachePersistence = (queryClient: QueryClient) => {\n  const [isRestored, setIsRestored] = React.useState(false);\n  const [persistenceStats, setPersistenceStats] = React.useState({\n    size: 0,\n    entryCount: 0,\n  });\n\n  React.useEffect(() => {\n    // Restore cache on mount\n    CachePersistence.restoreCache(queryClient);\n    setIsRestored(true);\n\n    // Set up auto-persist\n    const cleanup = CachePersistence.setupAutoPersist(queryClient);\n\n    // Update stats\n    const updateStats = () => {\n      setPersistenceStats(CachePersistence.getPersistedCacheSize());\n    };\n\n    updateStats();\n    const statsInterval = setInterval(updateStats, 10000); // Every 10 seconds\n\n    return () => {\n      cleanup();\n      clearInterval(statsInterval);\n    };\n  }, [queryClient]);\n\n  const persistCache = React.useCallback(() => {\n    CachePersistence.persistCache(queryClient);\n  }, [queryClient]);\n\n  const clearPersistedCache = React.useCallback(() => {\n    CachePersistence.clearPersistedCache();\n    setPersistenceStats({ size: 0, entryCount: 0 });\n  }, []);\n\n  const setConfig = React.useCallback((config: Partial<PersistenceConfig>) => {\n    CachePersistence.setConfig(config);\n  }, []);\n\n  return {\n    isRestored,\n    persistenceStats,\n    persistCache,\n    clearPersistedCache,\n    setConfig,\n  };\n};\n\n// Export React import for the hook\nimport React from 'react';"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}