{"ast":null,"code":"import { PositionStatus } from '../types';\n// Define filter combination rules\nconst FILTER_RULES = [\n// Date validation rules\n{\n  name: 'date_range_order',\n  condition: filters => {\n    if (!filters.date_from || !filters.date_to) return true;\n    return new Date(filters.date_from) <= new Date(filters.date_to);\n  },\n  message: 'Start date must be before or equal to end date',\n  type: 'error'\n}, {\n  name: 'future_date_warning',\n  condition: filters => {\n    const today = new Date().toISOString().split('T')[0];\n    if (filters.date_from && filters.date_from > today) return false;\n    if (filters.date_to && filters.date_to > today) return false;\n    return true;\n  },\n  message: 'You have selected future dates. Most applications are in the past.',\n  type: 'warning'\n}, {\n  name: 'very_old_dates',\n  condition: filters => {\n    const oneYearAgo = new Date();\n    oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);\n    const oneYearAgoStr = oneYearAgo.toISOString().split('T')[0];\n    if (filters.date_to && filters.date_to < oneYearAgoStr) return false;\n    return true;\n  },\n  message: 'You are filtering for very old applications. Consider expanding your date range.',\n  type: 'warning'\n},\n// Status and search combination rules\n{\n  name: 'rejected_with_company_search',\n  condition: filters => {\n    if (filters.status === PositionStatus.REJECTED && filters.company) return false;\n    return true;\n  },\n  message: 'Consider removing company filter when looking at rejected applications to see patterns across companies.',\n  type: 'suggestion'\n}, {\n  name: 'offer_status_suggestion',\n  condition: filters => {\n    if (filters.status === PositionStatus.OFFER) return false;\n    return true;\n  },\n  message: 'Great! You have offers. Consider also filtering by \"Interviewing\" status to track your pipeline.',\n  type: 'suggestion'\n},\n// Search optimization rules\n{\n  name: 'empty_search_with_filters',\n  condition: filters => {\n    const hasOtherFilters = filters.status || filters.company || filters.date_from || filters.date_to;\n    const hasEmptySearch = !filters.search || filters.search.trim() === '';\n    if (hasOtherFilters && hasEmptySearch) return false;\n    return true;\n  },\n  message: 'Try adding a search term to narrow down your results further.',\n  type: 'suggestion'\n}, {\n  name: 'too_specific_search',\n  condition: filters => {\n    if (!filters.search) return true;\n    const searchTerms = filters.search.trim().split(/\\s+/);\n    return searchTerms.length <= 4; // More than 4 terms might be too specific\n  },\n  message: 'Your search might be too specific. Try using fewer keywords.',\n  type: 'warning'\n},\n// Date range optimization\n{\n  name: 'very_narrow_date_range',\n  condition: filters => {\n    if (!filters.date_from || !filters.date_to) return true;\n    const startDate = new Date(filters.date_from);\n    const endDate = new Date(filters.date_to);\n    const diffDays = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);\n    return diffDays >= 7; // Less than a week might be too narrow\n  },\n  message: 'Your date range is very narrow (less than a week). Consider expanding it to see more results.',\n  type: 'suggestion'\n}, {\n  name: 'very_wide_date_range',\n  condition: filters => {\n    if (!filters.date_from || !filters.date_to) return true;\n    const startDate = new Date(filters.date_from);\n    const endDate = new Date(filters.date_to);\n    const diffDays = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);\n    return diffDays <= 365; // More than a year might be too wide\n  },\n  message: 'Your date range spans more than a year. Consider narrowing it down for more relevant results.',\n  type: 'suggestion'\n}];\n\n/**\n * Validates filter combinations and provides feedback\n */\nexport const validateFilters = filters => {\n  const errors = [];\n  const warnings = [];\n  const suggestions = [];\n\n  // Apply all rules\n  FILTER_RULES.forEach(rule => {\n    if (!rule.condition(filters)) {\n      switch (rule.type) {\n        case 'error':\n          errors.push(rule.message);\n          break;\n        case 'warning':\n          warnings.push(rule.message);\n          break;\n        case 'suggestion':\n          suggestions.push(rule.message);\n          break;\n      }\n    }\n  });\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n    suggestions\n  };\n};\n\n/**\n * Suggests filter improvements based on current filters\n */\nexport const suggestFilterImprovements = (filters, resultCount) => {\n  const suggestions = [];\n\n  // No results suggestions\n  if (resultCount === 0) {\n    if (Object.keys(filters).length > 0) {\n      suggestions.push('No results found. Try removing some filters or broadening your search criteria.');\n    }\n    if (filters.search && filters.search.length > 20) {\n      suggestions.push('Try using shorter, more general search terms.');\n    }\n    if (filters.company && filters.status) {\n      suggestions.push('Try removing either the company or status filter to see more results.');\n    }\n    if (filters.date_from && filters.date_to) {\n      const daysDiff = (new Date(filters.date_to).getTime() - new Date(filters.date_from).getTime()) / (1000 * 60 * 60 * 24);\n      if (daysDiff < 30) {\n        suggestions.push('Try expanding your date range to see more applications.');\n      }\n    }\n  }\n\n  // Too many results suggestions\n  if (resultCount > 50) {\n    if (!filters.status) {\n      suggestions.push('Consider filtering by status to narrow down your results.');\n    }\n    if (!filters.date_from && !filters.date_to) {\n      suggestions.push('Try adding a date range to focus on recent applications.');\n    }\n    if (!filters.search && !filters.company) {\n      suggestions.push('Add a search term or company filter to find specific positions.');\n    }\n  }\n\n  // Optimal results suggestions\n  if (resultCount > 0 && resultCount <= 20) {\n    if (filters.status === PositionStatus.APPLIED) {\n      suggestions.push('Great! These are your active applications. Consider following up on older ones.');\n    }\n    if (filters.status === PositionStatus.INTERVIEWING) {\n      suggestions.push('These positions are in your interview pipeline. Good luck!');\n    }\n  }\n  return suggestions;\n};\n\n/**\n * Optimizes filters for better performance and results\n */\nexport const optimizeFilters = filters => {\n  const optimized = {\n    ...filters\n  };\n\n  // Trim search terms\n  if (optimized.search) {\n    optimized.search = optimized.search.trim();\n    if (optimized.search === '') {\n      delete optimized.search;\n    }\n  }\n\n  // Trim company filter\n  if (optimized.company) {\n    optimized.company = optimized.company.trim();\n    if (optimized.company === '') {\n      delete optimized.company;\n    }\n  }\n\n  // Validate and fix date ranges\n  if (optimized.date_from && optimized.date_to) {\n    const startDate = new Date(optimized.date_from);\n    const endDate = new Date(optimized.date_to);\n\n    // Swap dates if they're in wrong order\n    if (startDate > endDate) {\n      optimized.date_from = endDate.toISOString().split('T')[0];\n      optimized.date_to = startDate.toISOString().split('T')[0];\n    }\n  }\n\n  // Remove empty values\n  Object.keys(optimized).forEach(key => {\n    const value = optimized[key];\n    if (value === undefined || value === null || value === '') {\n      delete optimized[key];\n    }\n  });\n  return optimized;\n};\n\n/**\n * Generates a human-readable description of active filters\n */\nexport const describeFilters = filters => {\n  const descriptions = [];\n  if (filters.search) {\n    descriptions.push(`searching for \"${filters.search}\"`);\n  }\n  if (filters.status) {\n    const statusLabels = {\n      [PositionStatus.APPLIED]: 'applied positions',\n      [PositionStatus.SCREENING]: 'positions in screening',\n      [PositionStatus.INTERVIEWING]: 'positions in interview process',\n      [PositionStatus.OFFER]: 'positions with offers',\n      [PositionStatus.REJECTED]: 'rejected positions',\n      [PositionStatus.WITHDRAWN]: 'withdrawn positions'\n    };\n    descriptions.push(statusLabels[filters.status]);\n  }\n  if (filters.company) {\n    descriptions.push(`at ${filters.company}`);\n  }\n  if (filters.date_from && filters.date_to) {\n    const startDate = new Date(filters.date_from).toLocaleDateString();\n    const endDate = new Date(filters.date_to).toLocaleDateString();\n    descriptions.push(`applied between ${startDate} and ${endDate}`);\n  } else if (filters.date_from) {\n    const startDate = new Date(filters.date_from).toLocaleDateString();\n    descriptions.push(`applied after ${startDate}`);\n  } else if (filters.date_to) {\n    const endDate = new Date(filters.date_to).toLocaleDateString();\n    descriptions.push(`applied before ${endDate}`);\n  }\n  if (descriptions.length === 0) {\n    return 'showing all positions';\n  }\n  if (descriptions.length === 1) {\n    return descriptions[0];\n  }\n  if (descriptions.length === 2) {\n    return descriptions.join(' and ');\n  }\n  return descriptions.slice(0, -1).join(', ') + ', and ' + descriptions[descriptions.length - 1];\n};\n\n/**\n * Checks if two filter sets are equivalent\n */\nexport const areFiltersEqual = (filters1, filters2) => {\n  const keys1 = Object.keys(filters1).sort();\n  const keys2 = Object.keys(filters2).sort();\n  if (keys1.length !== keys2.length) return false;\n  if (keys1.join(',') !== keys2.join(',')) return false;\n  return keys1.every(key => {\n    const value1 = filters1[key];\n    const value2 = filters2[key];\n    return value1 === value2;\n  });\n};\n\n/**\n * Merges multiple filter sets with conflict resolution\n */\nexport const mergeFilters = (...filterSets) => {\n  const merged = {};\n  filterSets.forEach(filters => {\n    Object.entries(filters).forEach(([key, value]) => {\n      if (value !== undefined && value !== null && value !== '') {\n        merged[key] = value;\n      }\n    });\n  });\n  return optimizeFilters(merged);\n};\nexport default {\n  validateFilters,\n  suggestFilterImprovements,\n  optimizeFilters,\n  describeFilters,\n  areFiltersEqual,\n  mergeFilters\n};","map":{"version":3,"names":["PositionStatus","FILTER_RULES","name","condition","filters","date_from","date_to","Date","message","type","today","toISOString","split","oneYearAgo","setFullYear","getFullYear","oneYearAgoStr","status","REJECTED","company","OFFER","hasOtherFilters","hasEmptySearch","search","trim","searchTerms","length","startDate","endDate","diffDays","getTime","validateFilters","errors","warnings","suggestions","forEach","rule","push","isValid","suggestFilterImprovements","resultCount","Object","keys","daysDiff","APPLIED","INTERVIEWING","optimizeFilters","optimized","key","value","undefined","describeFilters","descriptions","statusLabels","SCREENING","WITHDRAWN","toLocaleDateString","join","slice","areFiltersEqual","filters1","filters2","keys1","sort","keys2","every","value1","value2","mergeFilters","filterSets","merged","entries"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/utils/filterValidation.ts"],"sourcesContent":["import { PositionFilters, PositionStatus } from '../types';\n\nexport interface FilterValidationResult {\n  isValid: boolean;\n  errors: string[];\n  warnings: string[];\n  suggestions: string[];\n}\n\nexport interface FilterCombinationRule {\n  name: string;\n  condition: (filters: PositionFilters) => boolean;\n  message: string;\n  type: 'error' | 'warning' | 'suggestion';\n}\n\n// Define filter combination rules\nconst FILTER_RULES: FilterCombinationRule[] = [\n  // Date validation rules\n  {\n    name: 'date_range_order',\n    condition: (filters) => {\n      if (!filters.date_from || !filters.date_to) return true;\n      return new Date(filters.date_from) <= new Date(filters.date_to);\n    },\n    message: 'Start date must be before or equal to end date',\n    type: 'error',\n  },\n  {\n    name: 'future_date_warning',\n    condition: (filters) => {\n      const today = new Date().toISOString().split('T')[0];\n      if (filters.date_from && filters.date_from > today) return false;\n      if (filters.date_to && filters.date_to > today) return false;\n      return true;\n    },\n    message: 'You have selected future dates. Most applications are in the past.',\n    type: 'warning',\n  },\n  {\n    name: 'very_old_dates',\n    condition: (filters) => {\n      const oneYearAgo = new Date();\n      oneYearAgo.setFullYear(oneYearAgo.getFullYear() - 1);\n      const oneYearAgoStr = oneYearAgo.toISOString().split('T')[0];\n      \n      if (filters.date_to && filters.date_to < oneYearAgoStr) return false;\n      return true;\n    },\n    message: 'You are filtering for very old applications. Consider expanding your date range.',\n    type: 'warning',\n  },\n  \n  // Status and search combination rules\n  {\n    name: 'rejected_with_company_search',\n    condition: (filters) => {\n      if (filters.status === PositionStatus.REJECTED && filters.company) return false;\n      return true;\n    },\n    message: 'Consider removing company filter when looking at rejected applications to see patterns across companies.',\n    type: 'suggestion',\n  },\n  {\n    name: 'offer_status_suggestion',\n    condition: (filters) => {\n      if (filters.status === PositionStatus.OFFER) return false;\n      return true;\n    },\n    message: 'Great! You have offers. Consider also filtering by \"Interviewing\" status to track your pipeline.',\n    type: 'suggestion',\n  },\n  \n  // Search optimization rules\n  {\n    name: 'empty_search_with_filters',\n    condition: (filters) => {\n      const hasOtherFilters = filters.status || filters.company || filters.date_from || filters.date_to;\n      const hasEmptySearch = !filters.search || filters.search.trim() === '';\n      \n      if (hasOtherFilters && hasEmptySearch) return false;\n      return true;\n    },\n    message: 'Try adding a search term to narrow down your results further.',\n    type: 'suggestion',\n  },\n  {\n    name: 'too_specific_search',\n    condition: (filters) => {\n      if (!filters.search) return true;\n      const searchTerms = filters.search.trim().split(/\\s+/);\n      return searchTerms.length <= 4; // More than 4 terms might be too specific\n    },\n    message: 'Your search might be too specific. Try using fewer keywords.',\n    type: 'warning',\n  },\n  \n  // Date range optimization\n  {\n    name: 'very_narrow_date_range',\n    condition: (filters) => {\n      if (!filters.date_from || !filters.date_to) return true;\n      \n      const startDate = new Date(filters.date_from);\n      const endDate = new Date(filters.date_to);\n      const diffDays = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);\n      \n      return diffDays >= 7; // Less than a week might be too narrow\n    },\n    message: 'Your date range is very narrow (less than a week). Consider expanding it to see more results.',\n    type: 'suggestion',\n  },\n  {\n    name: 'very_wide_date_range',\n    condition: (filters) => {\n      if (!filters.date_from || !filters.date_to) return true;\n      \n      const startDate = new Date(filters.date_from);\n      const endDate = new Date(filters.date_to);\n      const diffDays = (endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24);\n      \n      return diffDays <= 365; // More than a year might be too wide\n    },\n    message: 'Your date range spans more than a year. Consider narrowing it down for more relevant results.',\n    type: 'suggestion',\n  },\n];\n\n/**\n * Validates filter combinations and provides feedback\n */\nexport const validateFilters = (filters: PositionFilters): FilterValidationResult => {\n  const errors: string[] = [];\n  const warnings: string[] = [];\n  const suggestions: string[] = [];\n\n  // Apply all rules\n  FILTER_RULES.forEach(rule => {\n    if (!rule.condition(filters)) {\n      switch (rule.type) {\n        case 'error':\n          errors.push(rule.message);\n          break;\n        case 'warning':\n          warnings.push(rule.message);\n          break;\n        case 'suggestion':\n          suggestions.push(rule.message);\n          break;\n      }\n    }\n  });\n\n  return {\n    isValid: errors.length === 0,\n    errors,\n    warnings,\n    suggestions,\n  };\n};\n\n/**\n * Suggests filter improvements based on current filters\n */\nexport const suggestFilterImprovements = (\n  filters: PositionFilters,\n  resultCount: number\n): string[] => {\n  const suggestions: string[] = [];\n\n  // No results suggestions\n  if (resultCount === 0) {\n    if (Object.keys(filters).length > 0) {\n      suggestions.push('No results found. Try removing some filters or broadening your search criteria.');\n    }\n    \n    if (filters.search && filters.search.length > 20) {\n      suggestions.push('Try using shorter, more general search terms.');\n    }\n    \n    if (filters.company && filters.status) {\n      suggestions.push('Try removing either the company or status filter to see more results.');\n    }\n    \n    if (filters.date_from && filters.date_to) {\n      const daysDiff = (new Date(filters.date_to).getTime() - new Date(filters.date_from).getTime()) / (1000 * 60 * 60 * 24);\n      if (daysDiff < 30) {\n        suggestions.push('Try expanding your date range to see more applications.');\n      }\n    }\n  }\n\n  // Too many results suggestions\n  if (resultCount > 50) {\n    if (!filters.status) {\n      suggestions.push('Consider filtering by status to narrow down your results.');\n    }\n    \n    if (!filters.date_from && !filters.date_to) {\n      suggestions.push('Try adding a date range to focus on recent applications.');\n    }\n    \n    if (!filters.search && !filters.company) {\n      suggestions.push('Add a search term or company filter to find specific positions.');\n    }\n  }\n\n  // Optimal results suggestions\n  if (resultCount > 0 && resultCount <= 20) {\n    if (filters.status === PositionStatus.APPLIED) {\n      suggestions.push('Great! These are your active applications. Consider following up on older ones.');\n    }\n    \n    if (filters.status === PositionStatus.INTERVIEWING) {\n      suggestions.push('These positions are in your interview pipeline. Good luck!');\n    }\n  }\n\n  return suggestions;\n};\n\n/**\n * Optimizes filters for better performance and results\n */\nexport const optimizeFilters = (filters: PositionFilters): PositionFilters => {\n  const optimized = { ...filters };\n\n  // Trim search terms\n  if (optimized.search) {\n    optimized.search = optimized.search.trim();\n    if (optimized.search === '') {\n      delete optimized.search;\n    }\n  }\n\n  // Trim company filter\n  if (optimized.company) {\n    optimized.company = optimized.company.trim();\n    if (optimized.company === '') {\n      delete optimized.company;\n    }\n  }\n\n  // Validate and fix date ranges\n  if (optimized.date_from && optimized.date_to) {\n    const startDate = new Date(optimized.date_from);\n    const endDate = new Date(optimized.date_to);\n    \n    // Swap dates if they're in wrong order\n    if (startDate > endDate) {\n      optimized.date_from = endDate.toISOString().split('T')[0];\n      optimized.date_to = startDate.toISOString().split('T')[0];\n    }\n  }\n\n  // Remove empty values\n  Object.keys(optimized).forEach(key => {\n    const value = optimized[key as keyof PositionFilters];\n    if (value === undefined || value === null || value === '') {\n      delete optimized[key as keyof PositionFilters];\n    }\n  });\n\n  return optimized;\n};\n\n/**\n * Generates a human-readable description of active filters\n */\nexport const describeFilters = (filters: PositionFilters): string => {\n  const descriptions: string[] = [];\n\n  if (filters.search) {\n    descriptions.push(`searching for \"${filters.search}\"`);\n  }\n\n  if (filters.status) {\n    const statusLabels: Record<PositionStatus, string> = {\n      [PositionStatus.APPLIED]: 'applied positions',\n      [PositionStatus.SCREENING]: 'positions in screening',\n      [PositionStatus.INTERVIEWING]: 'positions in interview process',\n      [PositionStatus.OFFER]: 'positions with offers',\n      [PositionStatus.REJECTED]: 'rejected positions',\n      [PositionStatus.WITHDRAWN]: 'withdrawn positions',\n    };\n    descriptions.push(statusLabels[filters.status]);\n  }\n\n  if (filters.company) {\n    descriptions.push(`at ${filters.company}`);\n  }\n\n  if (filters.date_from && filters.date_to) {\n    const startDate = new Date(filters.date_from).toLocaleDateString();\n    const endDate = new Date(filters.date_to).toLocaleDateString();\n    descriptions.push(`applied between ${startDate} and ${endDate}`);\n  } else if (filters.date_from) {\n    const startDate = new Date(filters.date_from).toLocaleDateString();\n    descriptions.push(`applied after ${startDate}`);\n  } else if (filters.date_to) {\n    const endDate = new Date(filters.date_to).toLocaleDateString();\n    descriptions.push(`applied before ${endDate}`);\n  }\n\n  if (descriptions.length === 0) {\n    return 'showing all positions';\n  }\n\n  if (descriptions.length === 1) {\n    return descriptions[0];\n  }\n\n  if (descriptions.length === 2) {\n    return descriptions.join(' and ');\n  }\n\n  return descriptions.slice(0, -1).join(', ') + ', and ' + descriptions[descriptions.length - 1];\n};\n\n/**\n * Checks if two filter sets are equivalent\n */\nexport const areFiltersEqual = (filters1: PositionFilters, filters2: PositionFilters): boolean => {\n  const keys1 = Object.keys(filters1).sort();\n  const keys2 = Object.keys(filters2).sort();\n\n  if (keys1.length !== keys2.length) return false;\n  if (keys1.join(',') !== keys2.join(',')) return false;\n\n  return keys1.every(key => {\n    const value1 = filters1[key as keyof PositionFilters];\n    const value2 = filters2[key as keyof PositionFilters];\n    return value1 === value2;\n  });\n};\n\n/**\n * Merges multiple filter sets with conflict resolution\n */\nexport const mergeFilters = (...filterSets: PositionFilters[]): PositionFilters => {\n  const merged: PositionFilters = {};\n\n  filterSets.forEach(filters => {\n    Object.entries(filters).forEach(([key, value]) => {\n      if (value !== undefined && value !== null && value !== '') {\n        merged[key as keyof PositionFilters] = value;\n      }\n    });\n  });\n\n  return optimizeFilters(merged);\n};\n\nexport default {\n  validateFilters,\n  suggestFilterImprovements,\n  optimizeFilters,\n  describeFilters,\n  areFiltersEqual,\n  mergeFilters,\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}