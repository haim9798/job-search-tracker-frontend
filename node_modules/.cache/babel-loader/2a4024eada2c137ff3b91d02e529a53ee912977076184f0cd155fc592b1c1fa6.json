{"ast":null,"code":"// Token storage keys\nconst ACCESS_TOKEN_KEY='access_token';const REFRESH_TOKEN_KEY='refresh_token';const USER_KEY='user';const TOKEN_EXPIRY_KEY='token_expiry';// Token expiry buffer (5 minutes before actual expiry)\nconst EXPIRY_BUFFER=5*60*1000;export class TokenManager{/**\n   * Set tokens and user data from auth response\n   */setTokens(authResponse){try{localStorage.setItem(ACCESS_TOKEN_KEY,authResponse.access_token);localStorage.setItem(USER_KEY,JSON.stringify(authResponse.user));// Calculate and store token expiry (assuming 1 hour default)\nconst expiryTime=Date.now()+60*60*1000;// 1 hour from now\nlocalStorage.setItem(TOKEN_EXPIRY_KEY,expiryTime.toString());// Store refresh token if provided\nif('refresh_token'in authResponse){localStorage.setItem(REFRESH_TOKEN_KEY,authResponse.refresh_token);}}catch(error){console.error('Failed to store tokens:',error);}}/**\n   * Get access token\n   */getAccessToken(){try{return localStorage.getItem(ACCESS_TOKEN_KEY);}catch(error){console.error('Failed to get access token:',error);return null;}}/**\n   * Get refresh token\n   */getRefreshToken(){try{return localStorage.getItem(REFRESH_TOKEN_KEY);}catch(error){console.error('Failed to get refresh token:',error);return null;}}/**\n   * Get stored user data\n   */getUser(){try{const userStr=localStorage.getItem(USER_KEY);return userStr?JSON.parse(userStr):null;}catch(error){console.error('Failed to get user data:',error);return null;}}/**\n   * Update stored user data\n   */setUser(user){try{localStorage.setItem(USER_KEY,JSON.stringify(user));}catch(error){console.error('Failed to store user data:',error);}}/**\n   * Check if user is authenticated (has valid token)\n   */isAuthenticated(){const token=this.getAccessToken();return!!token&&!this.isTokenExpired();}/**\n   * Check if token is expired or about to expire\n   */isTokenExpired(){try{const expiryStr=localStorage.getItem(TOKEN_EXPIRY_KEY);if(!expiryStr){// If no expiry stored, assume token is valid for backward compatibility\nreturn false;}const expiry=parseInt(expiryStr,10);const now=Date.now();// Consider token expired if it expires within the buffer time\nreturn now>=expiry-EXPIRY_BUFFER;}catch(error){console.error('Failed to check token expiry:',error);return true;// Assume expired on error\n}}/**\n   * Get time until token expires (in milliseconds)\n   */getTimeUntilExpiry(){try{const expiryStr=localStorage.getItem(TOKEN_EXPIRY_KEY);if(!expiryStr){return 0;}const expiry=parseInt(expiryStr,10);const now=Date.now();return Math.max(0,expiry-now);}catch(error){console.error('Failed to get time until expiry:',error);return 0;}}/**\n   * Update access token (for refresh operations)\n   */updateAccessToken(accessToken,expiresIn){try{localStorage.setItem(ACCESS_TOKEN_KEY,accessToken);// Update expiry if provided\nif(expiresIn){const expiryTime=Date.now()+expiresIn*1000;localStorage.setItem(TOKEN_EXPIRY_KEY,expiryTime.toString());}}catch(error){console.error('Failed to update access token:',error);}}/**\n   * Clear all stored tokens and user data\n   */clearTokens(){try{localStorage.removeItem(ACCESS_TOKEN_KEY);localStorage.removeItem(REFRESH_TOKEN_KEY);localStorage.removeItem(USER_KEY);localStorage.removeItem(TOKEN_EXPIRY_KEY);}catch(error){console.error('Failed to clear tokens:',error);}}/**\n   * Get authorization header value\n   */getAuthHeader(){const token=this.getAccessToken();return token?\"Bearer \".concat(token):null;}/**\n   * Check if refresh token is available\n   */hasRefreshToken(){return!!this.getRefreshToken();}/**\n   * Get all stored auth data for debugging\n   */getAuthData(){return{accessToken:this.getAccessToken(),refreshToken:this.getRefreshToken(),user:this.getUser(),isAuthenticated:this.isAuthenticated(),isExpired:this.isTokenExpired(),timeUntilExpiry:this.getTimeUntilExpiry()};}/**\n   * Subscribe to storage changes (for multi-tab sync)\n   */onStorageChange(callback){const handler=event=>{if([ACCESS_TOKEN_KEY,REFRESH_TOKEN_KEY,USER_KEY,TOKEN_EXPIRY_KEY].includes(event.key||'')){callback(event);}};window.addEventListener('storage',handler);return()=>{window.removeEventListener('storage',handler);};}}// Export singleton instance\nexport const tokenManager=new TokenManager();export default tokenManager;","map":{"version":3,"names":["ACCESS_TOKEN_KEY","REFRESH_TOKEN_KEY","USER_KEY","TOKEN_EXPIRY_KEY","EXPIRY_BUFFER","TokenManager","setTokens","authResponse","localStorage","setItem","access_token","JSON","stringify","user","expiryTime","Date","now","toString","refresh_token","error","console","getAccessToken","getItem","getRefreshToken","getUser","userStr","parse","setUser","isAuthenticated","token","isTokenExpired","expiryStr","expiry","parseInt","getTimeUntilExpiry","Math","max","updateAccessToken","accessToken","expiresIn","clearTokens","removeItem","getAuthHeader","concat","hasRefreshToken","getAuthData","refreshToken","isExpired","timeUntilExpiry","onStorageChange","callback","handler","event","includes","key","window","addEventListener","removeEventListener","tokenManager"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/utils/tokenManager.ts"],"sourcesContent":["import { User, AuthResponse } from '../types';\n\n// Token storage keys\nconst ACCESS_TOKEN_KEY = 'access_token';\nconst REFRESH_TOKEN_KEY = 'refresh_token';\nconst USER_KEY = 'user';\nconst TOKEN_EXPIRY_KEY = 'token_expiry';\n\n// Token expiry buffer (5 minutes before actual expiry)\nconst EXPIRY_BUFFER = 5 * 60 * 1000;\n\nexport class TokenManager {\n  /**\n   * Set tokens and user data from auth response\n   */\n  setTokens(authResponse: AuthResponse): void {\n    try {\n      localStorage.setItem(ACCESS_TOKEN_KEY, authResponse.access_token);\n      localStorage.setItem(USER_KEY, JSON.stringify(authResponse.user));\n      \n      // Calculate and store token expiry (assuming 1 hour default)\n      const expiryTime = Date.now() + (60 * 60 * 1000); // 1 hour from now\n      localStorage.setItem(TOKEN_EXPIRY_KEY, expiryTime.toString());\n      \n      // Store refresh token if provided\n      if ('refresh_token' in authResponse) {\n        localStorage.setItem(REFRESH_TOKEN_KEY, (authResponse as any).refresh_token);\n      }\n    } catch (error) {\n      console.error('Failed to store tokens:', error);\n    }\n  }\n\n  /**\n   * Get access token\n   */\n  getAccessToken(): string | null {\n    try {\n      return localStorage.getItem(ACCESS_TOKEN_KEY);\n    } catch (error) {\n      console.error('Failed to get access token:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get refresh token\n   */\n  getRefreshToken(): string | null {\n    try {\n      return localStorage.getItem(REFRESH_TOKEN_KEY);\n    } catch (error) {\n      console.error('Failed to get refresh token:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Get stored user data\n   */\n  getUser(): User | null {\n    try {\n      const userStr = localStorage.getItem(USER_KEY);\n      return userStr ? JSON.parse(userStr) : null;\n    } catch (error) {\n      console.error('Failed to get user data:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Update stored user data\n   */\n  setUser(user: User): void {\n    try {\n      localStorage.setItem(USER_KEY, JSON.stringify(user));\n    } catch (error) {\n      console.error('Failed to store user data:', error);\n    }\n  }\n\n  /**\n   * Check if user is authenticated (has valid token)\n   */\n  isAuthenticated(): boolean {\n    const token = this.getAccessToken();\n    return !!token && !this.isTokenExpired();\n  }\n\n  /**\n   * Check if token is expired or about to expire\n   */\n  isTokenExpired(): boolean {\n    try {\n      const expiryStr = localStorage.getItem(TOKEN_EXPIRY_KEY);\n      if (!expiryStr) {\n        // If no expiry stored, assume token is valid for backward compatibility\n        return false;\n      }\n\n      const expiry = parseInt(expiryStr, 10);\n      const now = Date.now();\n      \n      // Consider token expired if it expires within the buffer time\n      return now >= (expiry - EXPIRY_BUFFER);\n    } catch (error) {\n      console.error('Failed to check token expiry:', error);\n      return true; // Assume expired on error\n    }\n  }\n\n  /**\n   * Get time until token expires (in milliseconds)\n   */\n  getTimeUntilExpiry(): number {\n    try {\n      const expiryStr = localStorage.getItem(TOKEN_EXPIRY_KEY);\n      if (!expiryStr) {\n        return 0;\n      }\n\n      const expiry = parseInt(expiryStr, 10);\n      const now = Date.now();\n      \n      return Math.max(0, expiry - now);\n    } catch (error) {\n      console.error('Failed to get time until expiry:', error);\n      return 0;\n    }\n  }\n\n  /**\n   * Update access token (for refresh operations)\n   */\n  updateAccessToken(accessToken: string, expiresIn?: number): void {\n    try {\n      localStorage.setItem(ACCESS_TOKEN_KEY, accessToken);\n      \n      // Update expiry if provided\n      if (expiresIn) {\n        const expiryTime = Date.now() + (expiresIn * 1000);\n        localStorage.setItem(TOKEN_EXPIRY_KEY, expiryTime.toString());\n      }\n    } catch (error) {\n      console.error('Failed to update access token:', error);\n    }\n  }\n\n  /**\n   * Clear all stored tokens and user data\n   */\n  clearTokens(): void {\n    try {\n      localStorage.removeItem(ACCESS_TOKEN_KEY);\n      localStorage.removeItem(REFRESH_TOKEN_KEY);\n      localStorage.removeItem(USER_KEY);\n      localStorage.removeItem(TOKEN_EXPIRY_KEY);\n    } catch (error) {\n      console.error('Failed to clear tokens:', error);\n    }\n  }\n\n  /**\n   * Get authorization header value\n   */\n  getAuthHeader(): string | null {\n    const token = this.getAccessToken();\n    return token ? `Bearer ${token}` : null;\n  }\n\n  /**\n   * Check if refresh token is available\n   */\n  hasRefreshToken(): boolean {\n    return !!this.getRefreshToken();\n  }\n\n  /**\n   * Get all stored auth data for debugging\n   */\n  getAuthData(): {\n    accessToken: string | null;\n    refreshToken: string | null;\n    user: User | null;\n    isAuthenticated: boolean;\n    isExpired: boolean;\n    timeUntilExpiry: number;\n  } {\n    return {\n      accessToken: this.getAccessToken(),\n      refreshToken: this.getRefreshToken(),\n      user: this.getUser(),\n      isAuthenticated: this.isAuthenticated(),\n      isExpired: this.isTokenExpired(),\n      timeUntilExpiry: this.getTimeUntilExpiry(),\n    };\n  }\n\n  /**\n   * Subscribe to storage changes (for multi-tab sync)\n   */\n  onStorageChange(callback: (event: StorageEvent) => void): () => void {\n    const handler = (event: StorageEvent) => {\n      if ([ACCESS_TOKEN_KEY, REFRESH_TOKEN_KEY, USER_KEY, TOKEN_EXPIRY_KEY].includes(event.key || '')) {\n        callback(event);\n      }\n    };\n\n    window.addEventListener('storage', handler);\n    \n    return () => {\n      window.removeEventListener('storage', handler);\n    };\n  }\n}\n\n// Export singleton instance\nexport const tokenManager = new TokenManager();\nexport default tokenManager;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}