{"ast":null,"code":"import { PositionStatus, InterviewType, InterviewPlace, InterviewOutcome } from './index';\n\n// Validation schema types\n\n// Position validation schema\nexport const positionValidationSchema = {\n  title: {\n    required: true,\n    minLength: 2,\n    maxLength: 200\n  },\n  company: {\n    required: true,\n    minLength: 2,\n    maxLength: 100\n  },\n  description: {\n    maxLength: 2000\n  },\n  location: {\n    maxLength: 100\n  },\n  salary_range: {\n    maxLength: 50\n  },\n  status: {\n    required: true,\n    custom: value => {\n      if (!Object.values(PositionStatus).includes(value)) {\n        return 'Invalid position status';\n      }\n      return null;\n    }\n  },\n  application_date: {\n    required: true,\n    custom: value => {\n      const date = new Date(value);\n      if (isNaN(date.getTime())) {\n        return 'Invalid date format';\n      }\n      if (date > new Date()) {\n        return 'Application date cannot be in the future';\n      }\n      return null;\n    }\n  }\n};\n\n// Interview validation schema\nexport const interviewValidationSchema = {\n  type: {\n    required: true,\n    custom: value => {\n      if (!Object.values(InterviewType).includes(value)) {\n        return 'Invalid interview type';\n      }\n      return null;\n    }\n  },\n  place: {\n    required: true,\n    custom: value => {\n      if (!Object.values(InterviewPlace).includes(value)) {\n        return 'Invalid interview place';\n      }\n      return null;\n    }\n  },\n  scheduled_date: {\n    required: true,\n    custom: value => {\n      const date = new Date(value);\n      if (isNaN(date.getTime())) {\n        return 'Invalid date format';\n      }\n      return null;\n    }\n  },\n  duration_minutes: {\n    custom: value => {\n      if (value !== undefined && value !== null) {\n        const num = Number(value);\n        if (isNaN(num) || num < 0 || num > 480) {\n          return 'Duration must be between 0 and 480 minutes';\n        }\n      }\n      return null;\n    }\n  },\n  notes: {\n    maxLength: 2000\n  },\n  outcome: {\n    required: true,\n    custom: value => {\n      if (!Object.values(InterviewOutcome).includes(value)) {\n        return 'Invalid interview outcome';\n      }\n      return null;\n    }\n  }\n};\n\n// User registration validation schema\nexport const registerValidationSchema = {\n  email: {\n    required: true,\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n    maxLength: 254\n  },\n  password: {\n    required: true,\n    minLength: 8,\n    maxLength: 128,\n    custom: value => {\n      if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/.test(value)) {\n        return 'Password must contain at least one lowercase letter, one uppercase letter, and one number';\n      }\n      return null;\n    }\n  },\n  confirmPassword: {\n    required: true,\n    custom: (value, formData) => {\n      if (value !== (formData === null || formData === void 0 ? void 0 : formData.password)) {\n        return 'Passwords do not match';\n      }\n      return null;\n    }\n  },\n  first_name: {\n    required: true,\n    minLength: 1,\n    maxLength: 50,\n    pattern: /^[a-zA-Z\\s'-]+$/\n  },\n  last_name: {\n    required: true,\n    minLength: 1,\n    maxLength: 50,\n    pattern: /^[a-zA-Z\\s'-]+$/\n  }\n};\n\n// Login validation schema\nexport const loginValidationSchema = {\n  email: {\n    required: true,\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  },\n  password: {\n    required: true,\n    minLength: 1\n  }\n};\n\n// Validation utility functions\nexport const validateField = (value, rule, formData) => {\n  // Check required\n  if (rule.required && (value === undefined || value === null || value === '')) {\n    return 'This field is required';\n  }\n\n  // Skip other validations if value is empty and not required\n  if (!rule.required && (value === undefined || value === null || value === '')) {\n    return null;\n  }\n\n  // Check minLength\n  if (rule.minLength && value.length < rule.minLength) {\n    return `Minimum length is ${rule.minLength} characters`;\n  }\n\n  // Check maxLength\n  if (rule.maxLength && value.length > rule.maxLength) {\n    return `Maximum length is ${rule.maxLength} characters`;\n  }\n\n  // Check pattern\n  if (rule.pattern && !rule.pattern.test(value)) {\n    return 'Invalid format';\n  }\n\n  // Check custom validation\n  if (rule.custom) {\n    return rule.custom(value, formData);\n  }\n  return null;\n};\nexport const validateForm = (formData, schema) => {\n  const errors = {};\n  Object.keys(schema).forEach(field => {\n    const rule = schema[field];\n    if (rule) {\n      const error = validateField(formData[field], rule, formData);\n      if (error) {\n        errors[field] = error;\n      }\n    }\n  });\n  return errors;\n};\nexport const isFormValid = errors => {\n  return Object.keys(errors).length === 0;\n};","map":{"version":3,"names":["PositionStatus","InterviewType","InterviewPlace","InterviewOutcome","positionValidationSchema","title","required","minLength","maxLength","company","description","location","salary_range","status","custom","value","Object","values","includes","application_date","date","Date","isNaN","getTime","interviewValidationSchema","type","place","scheduled_date","duration_minutes","undefined","num","Number","notes","outcome","registerValidationSchema","email","pattern","password","test","confirmPassword","formData","first_name","last_name","loginValidationSchema","validateField","rule","length","validateForm","schema","errors","keys","forEach","field","error","isFormValid"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/types/validation.ts"],"sourcesContent":["import { PositionStatus, InterviewType, InterviewPlace, InterviewOutcome } from './index';\n\n// Validation schema types\nexport interface ValidationRule {\n  required?: boolean;\n  minLength?: number;\n  maxLength?: number;\n  pattern?: RegExp;\n  custom?: (value: any, formData?: any) => string | null;\n}\n\nexport interface ValidationSchema {\n  [key: string]: ValidationRule;\n}\n\n// Position validation schema\nexport const positionValidationSchema: ValidationSchema = {\n  title: {\n    required: true,\n    minLength: 2,\n    maxLength: 200,\n  },\n  company: {\n    required: true,\n    minLength: 2,\n    maxLength: 100,\n  },\n  description: {\n    maxLength: 2000,\n  },\n  location: {\n    maxLength: 100,\n  },\n  salary_range: {\n    maxLength: 50,\n  },\n  status: {\n    required: true,\n    custom: (value) => {\n      if (!Object.values(PositionStatus).includes(value)) {\n        return 'Invalid position status';\n      }\n      return null;\n    },\n  },\n  application_date: {\n    required: true,\n    custom: (value) => {\n      const date = new Date(value);\n      if (isNaN(date.getTime())) {\n        return 'Invalid date format';\n      }\n      if (date > new Date()) {\n        return 'Application date cannot be in the future';\n      }\n      return null;\n    },\n  },\n};\n\n// Interview validation schema\nexport const interviewValidationSchema: ValidationSchema = {\n  type: {\n    required: true,\n    custom: (value) => {\n      if (!Object.values(InterviewType).includes(value)) {\n        return 'Invalid interview type';\n      }\n      return null;\n    },\n  },\n  place: {\n    required: true,\n    custom: (value) => {\n      if (!Object.values(InterviewPlace).includes(value)) {\n        return 'Invalid interview place';\n      }\n      return null;\n    },\n  },\n  scheduled_date: {\n    required: true,\n    custom: (value) => {\n      const date = new Date(value);\n      if (isNaN(date.getTime())) {\n        return 'Invalid date format';\n      }\n      return null;\n    },\n  },\n  duration_minutes: {\n    custom: (value) => {\n      if (value !== undefined && value !== null) {\n        const num = Number(value);\n        if (isNaN(num) || num < 0 || num > 480) {\n          return 'Duration must be between 0 and 480 minutes';\n        }\n      }\n      return null;\n    },\n  },\n  notes: {\n    maxLength: 2000,\n  },\n  outcome: {\n    required: true,\n    custom: (value) => {\n      if (!Object.values(InterviewOutcome).includes(value)) {\n        return 'Invalid interview outcome';\n      }\n      return null;\n    },\n  },\n};\n\n// User registration validation schema\nexport const registerValidationSchema: ValidationSchema = {\n  email: {\n    required: true,\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n    maxLength: 254,\n  },\n  password: {\n    required: true,\n    minLength: 8,\n    maxLength: 128,\n    custom: (value) => {\n      if (!/(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/.test(value)) {\n        return 'Password must contain at least one lowercase letter, one uppercase letter, and one number';\n      }\n      return null;\n    },\n  },\n  confirmPassword: {\n    required: true,\n    custom: (value, formData) => {\n      if (value !== formData?.password) {\n        return 'Passwords do not match';\n      }\n      return null;\n    },\n  },\n  first_name: {\n    required: true,\n    minLength: 1,\n    maxLength: 50,\n    pattern: /^[a-zA-Z\\s'-]+$/,\n  },\n  last_name: {\n    required: true,\n    minLength: 1,\n    maxLength: 50,\n    pattern: /^[a-zA-Z\\s'-]+$/,\n  },\n};\n\n// Login validation schema\nexport const loginValidationSchema: ValidationSchema = {\n  email: {\n    required: true,\n    pattern: /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/,\n  },\n  password: {\n    required: true,\n    minLength: 1,\n  },\n};\n\n// Validation utility functions\nexport const validateField = (\n  value: any,\n  rule: ValidationRule,\n  formData?: any\n): string | null => {\n  // Check required\n  if (rule.required && (value === undefined || value === null || value === '')) {\n    return 'This field is required';\n  }\n\n  // Skip other validations if value is empty and not required\n  if (!rule.required && (value === undefined || value === null || value === '')) {\n    return null;\n  }\n\n  // Check minLength\n  if (rule.minLength && value.length < rule.minLength) {\n    return `Minimum length is ${rule.minLength} characters`;\n  }\n\n  // Check maxLength\n  if (rule.maxLength && value.length > rule.maxLength) {\n    return `Maximum length is ${rule.maxLength} characters`;\n  }\n\n  // Check pattern\n  if (rule.pattern && !rule.pattern.test(value)) {\n    return 'Invalid format';\n  }\n\n  // Check custom validation\n  if (rule.custom) {\n    return rule.custom(value, formData);\n  }\n\n  return null;\n};\n\nexport const validateForm = (\n  formData: any,\n  schema: ValidationSchema\n): { [key: string]: string } => {\n  const errors: { [key: string]: string } = {};\n\n  Object.keys(schema).forEach((field) => {\n    const rule = schema[field];\n    if (rule) {\n      const error = validateField(formData[field], rule, formData);\n      if (error) {\n        errors[field] = error;\n      }\n    }\n  });\n\n  return errors;\n};\n\nexport const isFormValid = (errors: { [key: string]: string }): boolean => {\n  return Object.keys(errors).length === 0;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}