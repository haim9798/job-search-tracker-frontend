{"ast":null,"code":"import _objectWithoutProperties from\"/home/haim/github/job-search-tracker-api/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";const _excluded=[\"confirmPassword\"];import React,{createContext,useContext,useEffect,useState,useCallback}from'react';import{useQueryClient}from'@tanstack/react-query';import{toast}from'react-hot-toast';import{authService}from'../services';import{queryKeys}from'../lib/queryClient';import{sessionPersistence}from'../utils/sessionPersistence';// Auth Context Types\nimport{jsx as _jsx}from\"react/jsx-runtime\";// Create context\nconst AuthContext=/*#__PURE__*/createContext(undefined);// Auth Provider Props\n// Token refresh interval (15 minutes)\nconst TOKEN_REFRESH_INTERVAL=15*60*1000;export const AuthProvider=_ref=>{let{children}=_ref;const[user,setUser]=useState(null);const[isLoading,setIsLoading]=useState(false);const[isInitialized,setIsInitialized]=useState(false);const[error,setError]=useState(null);const queryClient=useQueryClient();// Computed state\nconst isAuthenticated=!!user&&authService.isAuthenticated();// Clear error helper\nconst clearError=useCallback(()=>{setError(null);},[]);// Check session validity\nconst checkSession=useCallback(async()=>{try{if(!authService.isAuthenticated()){return false;}const isValid=await authService.verifyToken();return isValid;}catch(error){console.warn('Session check failed:',error);return false;}},[]);// Restore session from storage\nconst restoreSession=useCallback(async()=>{setIsLoading(true);setError(null);try{// Check if session should be restored\nif(!sessionPersistence.shouldRestoreSession()){sessionPersistence.clearSessionState();setIsInitialized(true);return;}// Try to get current user\nconst currentUser=await authService.getCurrentUser();setUser(currentUser);// Update session state\nsessionPersistence.saveSessionState(true,currentUser.id,currentUser.email);// Update query cache\nqueryClient.setQueryData(queryKeys.auth.user,currentUser);queryClient.setQueryData(queryKeys.auth.verify,true);}catch(error){console.warn('Session restoration failed:',error);// Clear invalid session\nauthService.logout();sessionPersistence.clearSessionState();setUser(null);queryClient.removeQueries(queryKeys.auth.user);queryClient.removeQueries(queryKeys.auth.verify);setError('Session expired. Please log in again.');}finally{setIsLoading(false);setIsInitialized(true);}},[queryClient]);// Login function\nconst login=useCallback(async credentials=>{setIsLoading(true);setError(null);try{const response=await authService.login(credentials);setUser(response.user);// Update session state\nsessionPersistence.saveSessionState(true,response.user.id,response.user.email);// Update query cache\nqueryClient.setQueryData(queryKeys.auth.user,response.user);queryClient.setQueryData(queryKeys.auth.verify,true);toast.success(\"Welcome back, \".concat(response.user.first_name,\"!\"));// Prefetch dashboard data after login\nqueryClient.prefetchQuery({queryKey:queryKeys.statistics.dashboard(),queryFn:()=>import('../services').then(_ref2=>{let{statisticsService}=_ref2;return statisticsService.getDashboardSummary();})});}catch(error){const errorMessage=error.message||'Login failed';setError(errorMessage);toast.error(errorMessage);throw error;}finally{setIsLoading(false);}},[queryClient]);// Register function\nconst register=useCallback(async userData=>{setIsLoading(true);setError(null);try{const{confirmPassword}=userData,registrationData=_objectWithoutProperties(userData,_excluded);await authService.register(registrationData);toast.success('Registration successful! Please log in.');}catch(error){const errorMessage=error.message||'Registration failed';setError(errorMessage);toast.error(errorMessage);throw error;}finally{setIsLoading(false);}},[]);// Logout function\nconst logout=useCallback(async()=>{setIsLoading(true);setError(null);try{await authService.logout();}catch(error){console.warn('Logout API call failed:',error);}finally{// Always clear local state\nsetUser(null);sessionPersistence.clearSessionState();// Clear all cached data\nqueryClient.clear();queryClient.removeQueries(queryKeys.auth.user);queryClient.removeQueries(queryKeys.auth.verify);toast.success('Logged out successfully');setIsLoading(false);}},[queryClient]);// Refresh token function\nconst refreshToken=useCallback(async()=>{try{await authService.refreshToken();// Update verification status\nqueryClient.setQueryData(queryKeys.auth.verify,true);console.log('Token refreshed successfully');}catch(error){console.warn('Token refresh failed:',error);// Clear auth data and redirect to login\nsetUser(null);sessionPersistence.clearSessionState();queryClient.clear();queryClient.removeQueries(queryKeys.auth.user);queryClient.removeQueries(queryKeys.auth.verify);setError('Session expired. Please log in again.');toast.error('Session expired. Please log in again.');// Redirect to login page\nwindow.location.href='/login';}},[queryClient]);// Auto-refresh token setup\nuseEffect(()=>{if(!isAuthenticated||!isInitialized){return;}const interval=setInterval(()=>{if(authService.isAuthenticated()){refreshToken();}},TOKEN_REFRESH_INTERVAL);return()=>clearInterval(interval);},[isAuthenticated,isInitialized,refreshToken]);// Initialize auth state on mount\nuseEffect(()=>{restoreSession();},[restoreSession]);// Set up activity tracking\nuseEffect(()=>{if(!isAuthenticated||!isInitialized){return;}const cleanup=sessionPersistence.setupActivityTracking();return cleanup;},[isAuthenticated,isInitialized]);// Set up session timeout warning\nuseEffect(()=>{if(!isAuthenticated||!isInitialized){return;}const cleanup=sessionPersistence.setupSessionTimeoutWarning(()=>{toast.error('Your session will expire soon. Please save your work.',{duration:10000});});return cleanup;},[isAuthenticated,isInitialized]);// Handle browser storage events (for multi-tab sync)\nuseEffect(()=>{const handleStorageChange=event=>{if(event.key==='access_token'||event.key==='user'){if(!event.newValue){// Token was removed in another tab\nsetUser(null);queryClient.clear();}else if(event.newValue&&!user){// Token was added in another tab\nrestoreSession();}}};window.addEventListener('storage',handleStorageChange);return()=>window.removeEventListener('storage',handleStorageChange);},[user,queryClient,restoreSession]);// Handle page visibility change (refresh token when page becomes visible)\nuseEffect(()=>{const handleVisibilityChange=()=>{if(document.visibilityState==='visible'&&isAuthenticated){checkSession().then(isValid=>{if(!isValid){refreshToken();}});}};document.addEventListener('visibilitychange',handleVisibilityChange);return()=>document.removeEventListener('visibilitychange',handleVisibilityChange);},[isAuthenticated,checkSession,refreshToken]);// Context value\nconst contextValue={// State\nuser,isAuthenticated,isLoading,isInitialized,error,// Actions\nlogin,register,logout,refreshToken,clearError,// Session management\ncheckSession,restoreSession};return/*#__PURE__*/_jsx(AuthContext.Provider,{value:contextValue,children:children});};// Custom hook to use auth context\nexport const useAuthContext=()=>{const context=useContext(AuthContext);if(context===undefined){throw new Error('useAuthContext must be used within an AuthProvider');}return context;};export default AuthProvider;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}