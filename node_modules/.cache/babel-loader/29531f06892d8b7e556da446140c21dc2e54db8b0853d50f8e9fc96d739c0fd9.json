{"ast":null,"code":"try {\n  self[\"workbox:window:7.2.0\"] && _();\n} catch (n) {}\nfunction n(n, t) {\n  return new Promise(function (r) {\n    var e = new MessageChannel();\n    e.port1.onmessage = function (n) {\n      r(n.data);\n    }, n.postMessage(t, [e.port2]);\n  });\n}\nfunction t(n) {\n  var t = function (n, t) {\n    if (\"object\" != typeof n || !n) return n;\n    var r = n[Symbol.toPrimitive];\n    if (void 0 !== r) {\n      var e = r.call(n, t || \"default\");\n      if (\"object\" != typeof e) return e;\n      throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (\"string\" === t ? String : Number)(n);\n  }(n, \"string\");\n  return \"symbol\" == typeof t ? t : t + \"\";\n}\nfunction r(n, r) {\n  for (var e = 0; e < r.length; e++) {\n    var i = r[e];\n    i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(n, t(i.key), i);\n  }\n}\nfunction e(n, t) {\n  return e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (n, t) {\n    return n.__proto__ = t, n;\n  }, e(n, t);\n}\nfunction i(n, t) {\n  (null == t || t > n.length) && (t = n.length);\n  for (var r = 0, e = new Array(t); r < t; r++) e[r] = n[r];\n  return e;\n}\nfunction o(n, t) {\n  var r = \"undefined\" != typeof Symbol && n[Symbol.iterator] || n[\"@@iterator\"];\n  if (r) return (r = r.call(n)).next.bind(r);\n  if (Array.isArray(n) || (r = function (n, t) {\n    if (n) {\n      if (\"string\" == typeof n) return i(n, t);\n      var r = Object.prototype.toString.call(n).slice(8, -1);\n      return \"Object\" === r && n.constructor && (r = n.constructor.name), \"Map\" === r || \"Set\" === r ? Array.from(n) : \"Arguments\" === r || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r) ? i(n, t) : void 0;\n    }\n  }(n)) || t && n && \"number\" == typeof n.length) {\n    r && (n = r);\n    var e = 0;\n    return function () {\n      return e >= n.length ? {\n        done: !0\n      } : {\n        done: !1,\n        value: n[e++]\n      };\n    };\n  }\n  throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\ntry {\n  self[\"workbox:core:7.2.0\"] && _();\n} catch (n) {}\nvar u = function () {\n  var n = this;\n  this.promise = new Promise(function (t, r) {\n    n.resolve = t, n.reject = r;\n  });\n};\nfunction a(n, t) {\n  var r = location.href;\n  return new URL(n, r).href === new URL(t, r).href;\n}\nvar c = function (n, t) {\n  this.type = n, Object.assign(this, t);\n};\nfunction f(n, t, r) {\n  return r ? t ? t(n) : n : (n && n.then || (n = Promise.resolve(n)), t ? n.then(t) : n);\n}\nfunction s() {}\nvar v = {\n  type: \"SKIP_WAITING\"\n};\nfunction h(n, t) {\n  if (!t) return n && n.then ? n.then(s) : Promise.resolve();\n}\nvar l = function (t) {\n  function i(n, r) {\n    var e, i;\n    return void 0 === r && (r = {}), (e = t.call(this) || this).nn = {}, e.tn = 0, e.rn = new u(), e.en = new u(), e.on = new u(), e.un = 0, e.an = new Set(), e.cn = function () {\n      var n = e.fn,\n        t = n.installing;\n      e.tn > 0 || !a(t.scriptURL, e.sn.toString()) || performance.now() > e.un + 6e4 ? (e.vn = t, n.removeEventListener(\"updatefound\", e.cn)) : (e.hn = t, e.an.add(t), e.rn.resolve(t)), ++e.tn, t.addEventListener(\"statechange\", e.ln);\n    }, e.ln = function (n) {\n      var t = e.fn,\n        r = n.target,\n        i = r.state,\n        o = r === e.vn,\n        u = {\n          sw: r,\n          isExternal: o,\n          originalEvent: n\n        };\n      !o && e.mn && (u.isUpdate = !0), e.dispatchEvent(new c(i, u)), \"installed\" === i ? e.wn = self.setTimeout(function () {\n        \"installed\" === i && t.waiting === r && e.dispatchEvent(new c(\"waiting\", u));\n      }, 200) : \"activating\" === i && (clearTimeout(e.wn), o || e.en.resolve(r));\n    }, e.yn = function (n) {\n      var t = e.hn,\n        r = t !== navigator.serviceWorker.controller;\n      e.dispatchEvent(new c(\"controlling\", {\n        isExternal: r,\n        originalEvent: n,\n        sw: t,\n        isUpdate: e.mn\n      })), r || e.on.resolve(t);\n    }, e.gn = (i = function (n) {\n      var t = n.data,\n        r = n.ports,\n        i = n.source;\n      return f(e.getSW(), function () {\n        e.an.has(i) && e.dispatchEvent(new c(\"message\", {\n          data: t,\n          originalEvent: n,\n          ports: r,\n          sw: i\n        }));\n      });\n    }, function () {\n      for (var n = [], t = 0; t < arguments.length; t++) n[t] = arguments[t];\n      try {\n        return Promise.resolve(i.apply(this, n));\n      } catch (n) {\n        return Promise.reject(n);\n      }\n    }), e.sn = n, e.nn = r, navigator.serviceWorker.addEventListener(\"message\", e.gn), e;\n  }\n  var o, s;\n  s = t, (o = i).prototype = Object.create(s.prototype), o.prototype.constructor = o, e(o, s);\n  var l,\n    m,\n    w,\n    y = i.prototype;\n  return y.register = function (n) {\n    var t = (void 0 === n ? {} : n).immediate,\n      r = void 0 !== t && t;\n    try {\n      var e = this;\n      return f(function (n, t) {\n        var r = n();\n        if (r && r.then) return r.then(t);\n        return t(r);\n      }(function () {\n        if (!r && \"complete\" !== document.readyState) return h(new Promise(function (n) {\n          return window.addEventListener(\"load\", n);\n        }));\n      }, function () {\n        return e.mn = Boolean(navigator.serviceWorker.controller), e.dn = e.pn(), f(e.bn(), function (n) {\n          e.fn = n, e.dn && (e.hn = e.dn, e.en.resolve(e.dn), e.on.resolve(e.dn), e.dn.addEventListener(\"statechange\", e.ln, {\n            once: !0\n          }));\n          var t = e.fn.waiting;\n          return t && a(t.scriptURL, e.sn.toString()) && (e.hn = t, Promise.resolve().then(function () {\n            e.dispatchEvent(new c(\"waiting\", {\n              sw: t,\n              wasWaitingBeforeRegister: !0\n            }));\n          }).then(function () {})), e.hn && (e.rn.resolve(e.hn), e.an.add(e.hn)), e.fn.addEventListener(\"updatefound\", e.cn), navigator.serviceWorker.addEventListener(\"controllerchange\", e.yn), e.fn;\n        });\n      }));\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, y.update = function () {\n    try {\n      return this.fn ? f(h(this.fn.update())) : f();\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, y.getSW = function () {\n    return void 0 !== this.hn ? Promise.resolve(this.hn) : this.rn.promise;\n  }, y.messageSW = function (t) {\n    try {\n      return f(this.getSW(), function (r) {\n        return n(r, t);\n      });\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, y.messageSkipWaiting = function () {\n    this.fn && this.fn.waiting && n(this.fn.waiting, v);\n  }, y.pn = function () {\n    var n = navigator.serviceWorker.controller;\n    return n && a(n.scriptURL, this.sn.toString()) ? n : void 0;\n  }, y.bn = function () {\n    try {\n      var n = this;\n      return f(function (n, t) {\n        try {\n          var r = n();\n        } catch (n) {\n          return t(n);\n        }\n        if (r && r.then) return r.then(void 0, t);\n        return r;\n      }(function () {\n        return f(navigator.serviceWorker.register(n.sn, n.nn), function (t) {\n          return n.un = performance.now(), t;\n        });\n      }, function (n) {\n        throw n;\n      }));\n    } catch (n) {\n      return Promise.reject(n);\n    }\n  }, l = i, (m = [{\n    key: \"active\",\n    get: function () {\n      return this.en.promise;\n    }\n  }, {\n    key: \"controlling\",\n    get: function () {\n      return this.on.promise;\n    }\n  }]) && r(l.prototype, m), w && r(l, w), Object.defineProperty(l, \"prototype\", {\n    writable: !1\n  }), l;\n}(function () {\n  function n() {\n    this.Pn = new Map();\n  }\n  var t = n.prototype;\n  return t.addEventListener = function (n, t) {\n    this.jn(n).add(t);\n  }, t.removeEventListener = function (n, t) {\n    this.jn(n).delete(t);\n  }, t.dispatchEvent = function (n) {\n    n.target = this;\n    for (var t, r = o(this.jn(n.type)); !(t = r()).done;) {\n      (0, t.value)(n);\n    }\n  }, t.jn = function (n) {\n    return this.Pn.has(n) || this.Pn.set(n, new Set()), this.Pn.get(n);\n  }, n;\n}());\nexport { l as Workbox, c as WorkboxEvent, n as messageSW };","map":{"version":3,"names":["self","_","n","t","Promise","r","e","MessageChannel","port1","onmessage","data","postMessage","port2","Symbol","toPrimitive","call","TypeError","String","Number","length","i","enumerable","configurable","writable","Object","defineProperty","key","setPrototypeOf","bind","__proto__","Array","o","iterator","next","isArray","prototype","toString","slice","constructor","name","from","test","done","value","u","Deferred","promise","resolve","reject","a","location","href","URL","c","WorkboxEvent","type","assign","f","then","s","v","h","l","nn","tn","rn","en","on","un","an","Set","cn","fn","installing","scriptURL","sn","performance","now","vn","removeEventListener","hn","add","addEventListener","ln","target","state","sw","isExternal","originalEvent","mn","isUpdate","dispatchEvent","wn","setTimeout","waiting","clearTimeout","yn","navigator","serviceWorker","controller","gn","ports","source","getSW","has","arguments","apply","create","m","w","y","register","immediate","document","readyState","window","Boolean","dn","pn","bn","once","wasWaitingBeforeRegister","update","messageSW","messageSkipWaiting","get","Pn","Map","jn","delete","set","Workbox"],"sources":["/home/haim/github/job-search-tracker-api/frontend/node_modules/workbox-window/_version.js","/home/haim/github/job-search-tracker-api/frontend/node_modules/workbox-window/messageSW.js","/home/haim/github/job-search-tracker-api/frontend/node_modules/workbox-core/_version.js","/home/haim/github/job-search-tracker-api/frontend/node_modules/workbox-core/_private/Deferred.js","/home/haim/github/job-search-tracker-api/frontend/node_modules/workbox-window/utils/urlsMatch.js","/home/haim/github/job-search-tracker-api/frontend/node_modules/workbox-window/utils/WorkboxEvent.js","/home/haim/github/job-search-tracker-api/frontend/node_modules/workbox-window/Workbox.js","/home/haim/github/job-search-tracker-api/frontend/node_modules/workbox-core/_private/dontWaitFor.js","/home/haim/github/job-search-tracker-api/frontend/node_modules/workbox-window/utils/WorkboxEventTarget.js"],"sourcesContent":["\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:window:7.2.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport './_version.js';\n/**\n * Sends a data object to a service worker via `postMessage` and resolves with\n * a response (if any).\n *\n * A response can be set in a message handler in the service worker by\n * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n * returned by `messageSW()`. If no response is set, the promise will not\n * resolve.\n *\n * @param {ServiceWorker} sw The service worker to send the message to.\n * @param {Object} data An object to send to the service worker.\n * @return {Promise<Object|undefined>}\n * @memberof workbox-window\n */\n// Better not change type of data.\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction messageSW(sw, data) {\n    return new Promise((resolve) => {\n        const messageChannel = new MessageChannel();\n        messageChannel.port1.onmessage = (event) => {\n            resolve(event.data);\n        };\n        sw.postMessage(data, [messageChannel.port2]);\n    });\n}\nexport { messageSW };\n","\"use strict\";\n// @ts-ignore\ntry {\n    self['workbox:core:7.2.0'] && _();\n}\ncatch (e) { }\n","/*\n  Copyright 2018 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * The Deferred class composes Promises in a way that allows for them to be\n * resolved or rejected from outside the constructor. In most cases promises\n * should be used directly, but Deferreds can be necessary when the logic to\n * resolve a promise must be separate.\n *\n * @private\n */\nclass Deferred {\n    /**\n     * Creates a promise and exposes its resolve and reject functions as methods.\n     */\n    constructor() {\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n}\nexport { Deferred };\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * Returns true if two URLs have the same `.href` property. The URLS can be\n * relative, and if they are the current location href is used to resolve URLs.\n *\n * @private\n * @param {string} url1\n * @param {string} url2\n * @return {boolean}\n */\nexport function urlsMatch(url1, url2) {\n    const { href } = location;\n    return new URL(url1, href).href === new URL(url2, href).href;\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A minimal `Event` subclass shim.\n * This doesn't *actually* subclass `Event` because not all browsers support\n * constructable `EventTarget`, and using a real `Event` will error.\n * @private\n */\nexport class WorkboxEvent {\n    constructor(type, props) {\n        this.type = type;\n        Object.assign(this, props);\n    }\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { dontWaitFor } from 'workbox-core/_private/dontWaitFor.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { messageSW } from './messageSW.js';\nimport { WorkboxEventTarget } from './utils/WorkboxEventTarget.js';\nimport { urlsMatch } from './utils/urlsMatch.js';\nimport { WorkboxEvent } from './utils/WorkboxEvent.js';\nimport './_version.js';\n// The time a SW must be in the waiting phase before we can conclude\n// `skipWaiting()` wasn't called. This 200 amount wasn't scientifically\n// chosen, but it seems to avoid false positives in my testing.\nconst WAITING_TIMEOUT_DURATION = 200;\n// The amount of time after a registration that we can reasonably conclude\n// that the registration didn't trigger an update.\nconst REGISTRATION_TIMEOUT_DURATION = 60000;\n// The de facto standard message that a service worker should be listening for\n// to trigger a call to skipWaiting().\nconst SKIP_WAITING_MESSAGE = { type: 'SKIP_WAITING' };\n/**\n * A class to aid in handling service worker registration, updates, and\n * reacting to service worker lifecycle events.\n *\n * @fires {@link workbox-window.Workbox#message}\n * @fires {@link workbox-window.Workbox#installed}\n * @fires {@link workbox-window.Workbox#waiting}\n * @fires {@link workbox-window.Workbox#controlling}\n * @fires {@link workbox-window.Workbox#activated}\n * @fires {@link workbox-window.Workbox#redundant}\n * @memberof workbox-window\n */\nclass Workbox extends WorkboxEventTarget {\n    /**\n     * Creates a new Workbox instance with a script URL and service worker\n     * options. The script URL and options are the same as those used when\n     * calling [navigator.serviceWorker.register(scriptURL, options)](https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/register).\n     *\n     * @param {string|TrustedScriptURL} scriptURL The service worker script\n     *     associated with this instance. Using a\n     *     [`TrustedScriptURL`](https://web.dev/trusted-types/) is supported.\n     * @param {Object} [registerOptions] The service worker options associated\n     *     with this instance.\n     */\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    constructor(scriptURL, registerOptions = {}) {\n        super();\n        this._registerOptions = {};\n        this._updateFoundCount = 0;\n        // Deferreds we can resolve later.\n        this._swDeferred = new Deferred();\n        this._activeDeferred = new Deferred();\n        this._controllingDeferred = new Deferred();\n        this._registrationTime = 0;\n        this._ownSWs = new Set();\n        /**\n         * @private\n         */\n        this._onUpdateFound = () => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const installingSW = registration.installing;\n            // If the script URL passed to `navigator.serviceWorker.register()` is\n            // different from the current controlling SW's script URL, we know any\n            // successful registration calls will trigger an `updatefound` event.\n            // But if the registered script URL is the same as the current controlling\n            // SW's script URL, we'll only get an `updatefound` event if the file\n            // changed since it was last registered. This can be a problem if the user\n            // opens up the same page in a different tab, and that page registers\n            // a SW that triggers an update. It's a problem because this page has no\n            // good way of knowing whether the `updatefound` event came from the SW\n            // script it registered or from a registration attempt made by a newer\n            // version of the page running in another tab.\n            // To minimize the possibility of a false positive, we use the logic here:\n            const updateLikelyTriggeredExternally = \n            // Since we enforce only calling `register()` once, and since we don't\n            // add the `updatefound` event listener until the `register()` call, if\n            // `_updateFoundCount` is > 0 then it means this method has already\n            // been called, thus this SW must be external\n            this._updateFoundCount > 0 ||\n                // If the script URL of the installing SW is different from this\n                // instance's script URL, we know it's definitely not from our\n                // registration.\n                !urlsMatch(installingSW.scriptURL, this._scriptURL.toString()) ||\n                // If all of the above are false, then we use a time-based heuristic:\n                // Any `updatefound` event that occurs long after our registration is\n                // assumed to be external.\n                performance.now() > this._registrationTime + REGISTRATION_TIMEOUT_DURATION\n                ? // If any of the above are not true, we assume the update was\n                    // triggered by this instance.\n                    true\n                : false;\n            if (updateLikelyTriggeredExternally) {\n                this._externalSW = installingSW;\n                registration.removeEventListener('updatefound', this._onUpdateFound);\n            }\n            else {\n                // If the update was not triggered externally we know the installing\n                // SW is the one we registered, so we set it.\n                this._sw = installingSW;\n                this._ownSWs.add(installingSW);\n                this._swDeferred.resolve(installingSW);\n                // The `installing` state isn't something we have a dedicated\n                // callback for, but we do log messages for it in development.\n                if (process.env.NODE_ENV !== 'production') {\n                    if (navigator.serviceWorker.controller) {\n                        logger.log('Updated service worker found. Installing now...');\n                    }\n                    else {\n                        logger.log('Service worker is installing...');\n                    }\n                }\n            }\n            // Increment the `updatefound` count, so future invocations of this\n            // method can be sure they were triggered externally.\n            ++this._updateFoundCount;\n            // Add a `statechange` listener regardless of whether this update was\n            // triggered externally, since we have callbacks for both.\n            installingSW.addEventListener('statechange', this._onStateChange);\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onStateChange = (originalEvent) => {\n            // `this._registration` will never be `undefined` after an update is found.\n            const registration = this._registration;\n            const sw = originalEvent.target;\n            const { state } = sw;\n            const isExternal = sw === this._externalSW;\n            const eventProps = {\n                sw,\n                isExternal,\n                originalEvent,\n            };\n            if (!isExternal && this._isUpdate) {\n                eventProps.isUpdate = true;\n            }\n            this.dispatchEvent(new WorkboxEvent(state, eventProps));\n            if (state === 'installed') {\n                // This timeout is used to ignore cases where the service worker calls\n                // `skipWaiting()` in the install event, thus moving it directly in the\n                // activating state. (Since all service workers *must* go through the\n                // waiting phase, the only way to detect `skipWaiting()` called in the\n                // install event is to observe that the time spent in the waiting phase\n                // is very short.)\n                // NOTE: we don't need separate timeouts for the own and external SWs\n                // since they can't go through these phases at the same time.\n                this._waitingTimeout = self.setTimeout(() => {\n                    // Ensure the SW is still waiting (it may now be redundant).\n                    if (state === 'installed' && registration.waiting === sw) {\n                        this.dispatchEvent(new WorkboxEvent('waiting', eventProps));\n                        if (process.env.NODE_ENV !== 'production') {\n                            if (isExternal) {\n                                logger.warn('An external service worker has installed but is ' +\n                                    'waiting for this client to close before activating...');\n                            }\n                            else {\n                                logger.warn('The service worker has installed but is waiting ' +\n                                    'for existing clients to close before activating...');\n                            }\n                        }\n                    }\n                }, WAITING_TIMEOUT_DURATION);\n            }\n            else if (state === 'activating') {\n                clearTimeout(this._waitingTimeout);\n                if (!isExternal) {\n                    this._activeDeferred.resolve(sw);\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                switch (state) {\n                    case 'installed':\n                        if (isExternal) {\n                            logger.warn('An external service worker has installed. ' +\n                                'You may want to suggest users reload this page.');\n                        }\n                        else {\n                            logger.log('Registered service worker installed.');\n                        }\n                        break;\n                    case 'activated':\n                        if (isExternal) {\n                            logger.warn('An external service worker has activated.');\n                        }\n                        else {\n                            logger.log('Registered service worker activated.');\n                            if (sw !== navigator.serviceWorker.controller) {\n                                logger.warn('The registered service worker is active but ' +\n                                    'not yet controlling the page. Reload or run ' +\n                                    '`clients.claim()` in the service worker.');\n                            }\n                        }\n                        break;\n                    case 'redundant':\n                        if (sw === this._compatibleControllingSW) {\n                            logger.log('Previously controlling service worker now redundant!');\n                        }\n                        else if (!isExternal) {\n                            logger.log('Registered service worker now redundant!');\n                        }\n                        break;\n                }\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onControllerChange = (originalEvent) => {\n            const sw = this._sw;\n            const isExternal = sw !== navigator.serviceWorker.controller;\n            // Unconditionally dispatch the controlling event, with isExternal set\n            // to distinguish between controller changes due to the initial registration\n            // vs. an update-check or other tab's registration.\n            // See https://github.com/GoogleChrome/workbox/issues/2786\n            this.dispatchEvent(new WorkboxEvent('controlling', {\n                isExternal,\n                originalEvent,\n                sw,\n                isUpdate: this._isUpdate,\n            }));\n            if (!isExternal) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.log('Registered service worker now controlling this page.');\n                }\n                this._controllingDeferred.resolve(sw);\n            }\n        };\n        /**\n         * @private\n         * @param {Event} originalEvent\n         */\n        this._onMessage = async (originalEvent) => {\n            // Can't change type 'any' of data.\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const { data, ports, source } = originalEvent;\n            // Wait until there's an \"own\" service worker. This is used to buffer\n            // `message` events that may be received prior to calling `register()`.\n            await this.getSW();\n            // If the service worker that sent the message is in the list of own\n            // service workers for this instance, dispatch a `message` event.\n            // NOTE: we check for all previously owned service workers rather than\n            // just the current one because some messages (e.g. cache updates) use\n            // a timeout when sent and may be delayed long enough for a service worker\n            // update to be found.\n            if (this._ownSWs.has(source)) {\n                this.dispatchEvent(new WorkboxEvent('message', {\n                    // Can't change type 'any' of data.\n                    // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n                    data,\n                    originalEvent,\n                    ports,\n                    sw: source,\n                }));\n            }\n        };\n        this._scriptURL = scriptURL;\n        this._registerOptions = registerOptions;\n        // Add a message listener immediately since messages received during\n        // page load are buffered only until the DOMContentLoaded event:\n        // https://github.com/GoogleChrome/workbox/issues/2202\n        navigator.serviceWorker.addEventListener('message', this._onMessage);\n    }\n    /**\n     * Registers a service worker for this instances script URL and service\n     * worker options. By default this method delays registration until after\n     * the window has loaded.\n     *\n     * @param {Object} [options]\n     * @param {Function} [options.immediate=false] Setting this to true will\n     *     register the service worker immediately, even if the window has\n     *     not loaded (not recommended).\n     */\n    async register({ immediate = false } = {}) {\n        if (process.env.NODE_ENV !== 'production') {\n            if (this._registrationTime) {\n                logger.error('Cannot re-register a Workbox instance after it has ' +\n                    'been registered. Create a new instance instead.');\n                return;\n            }\n        }\n        if (!immediate && document.readyState !== 'complete') {\n            await new Promise((res) => window.addEventListener('load', res));\n        }\n        // Set this flag to true if any service worker was controlling the page\n        // at registration time.\n        this._isUpdate = Boolean(navigator.serviceWorker.controller);\n        // Before registering, attempt to determine if a SW is already controlling\n        // the page, and if that SW script (and version, if specified) matches this\n        // instance's script.\n        this._compatibleControllingSW = this._getControllingSWIfCompatible();\n        this._registration = await this._registerScript();\n        // If we have a compatible controller, store the controller as the \"own\"\n        // SW, resolve active/controlling deferreds and add necessary listeners.\n        if (this._compatibleControllingSW) {\n            this._sw = this._compatibleControllingSW;\n            this._activeDeferred.resolve(this._compatibleControllingSW);\n            this._controllingDeferred.resolve(this._compatibleControllingSW);\n            this._compatibleControllingSW.addEventListener('statechange', this._onStateChange, { once: true });\n        }\n        // If there's a waiting service worker with a matching URL before the\n        // `updatefound` event fires, it likely means that this site is open\n        // in another tab, or the user refreshed the page (and thus the previous\n        // page wasn't fully unloaded before this page started loading).\n        // https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#waiting\n        const waitingSW = this._registration.waiting;\n        if (waitingSW &&\n            urlsMatch(waitingSW.scriptURL, this._scriptURL.toString())) {\n            // Store the waiting SW as the \"own\" Sw, even if it means overwriting\n            // a compatible controller.\n            this._sw = waitingSW;\n            // Run this in the next microtask, so any code that adds an event\n            // listener after awaiting `register()` will get this event.\n            dontWaitFor(Promise.resolve().then(() => {\n                this.dispatchEvent(new WorkboxEvent('waiting', {\n                    sw: waitingSW,\n                    wasWaitingBeforeRegister: true,\n                }));\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.warn('A service worker was already waiting to activate ' +\n                        'before this script was registered...');\n                }\n            }));\n        }\n        // If an \"own\" SW is already set, resolve the deferred.\n        if (this._sw) {\n            this._swDeferred.resolve(this._sw);\n            this._ownSWs.add(this._sw);\n        }\n        if (process.env.NODE_ENV !== 'production') {\n            logger.log('Successfully registered service worker.', this._scriptURL.toString());\n            if (navigator.serviceWorker.controller) {\n                if (this._compatibleControllingSW) {\n                    logger.debug('A service worker with the same script URL ' +\n                        'is already controlling this page.');\n                }\n                else {\n                    logger.debug('A service worker with a different script URL is ' +\n                        'currently controlling the page. The browser is now fetching ' +\n                        'the new script now...');\n                }\n            }\n            const currentPageIsOutOfScope = () => {\n                const scopeURL = new URL(this._registerOptions.scope || this._scriptURL.toString(), document.baseURI);\n                const scopeURLBasePath = new URL('./', scopeURL.href).pathname;\n                return !location.pathname.startsWith(scopeURLBasePath);\n            };\n            if (currentPageIsOutOfScope()) {\n                logger.warn('The current page is not in scope for the registered ' +\n                    'service worker. Was this a mistake?');\n            }\n        }\n        this._registration.addEventListener('updatefound', this._onUpdateFound);\n        navigator.serviceWorker.addEventListener('controllerchange', this._onControllerChange);\n        return this._registration;\n    }\n    /**\n     * Checks for updates of the registered service worker.\n     */\n    async update() {\n        if (!this._registration) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error('Cannot update a Workbox instance without ' +\n                    'being registered. Register the Workbox instance first.');\n            }\n            return;\n        }\n        // Try to update registration\n        await this._registration.update();\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is active. If a service worker was already controlling at registration\n     * time then it will resolve to that if the script URLs (and optionally\n     * script versions) match, otherwise it will wait until an update is found\n     * and activates.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get active() {\n        return this._activeDeferred.promise;\n    }\n    /**\n     * Resolves to the service worker registered by this instance as soon as it\n     * is controlling the page. If a service worker was already controlling at\n     * registration time then it will resolve to that if the script URLs (and\n     * optionally script versions) match, otherwise it will wait until an update\n     * is found and starts controlling the page.\n     * Note: the first time a service worker is installed it will active but\n     * not start controlling the page unless `clients.claim()` is called in the\n     * service worker.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    get controlling() {\n        return this._controllingDeferred.promise;\n    }\n    /**\n     * Resolves with a reference to a service worker that matches the script URL\n     * of this instance, as soon as it's available.\n     *\n     * If, at registration time, there's already an active or waiting service\n     * worker with a matching script URL, it will be used (with the waiting\n     * service worker taking precedence over the active service worker if both\n     * match, since the waiting service worker would have been registered more\n     * recently).\n     * If there's no matching active or waiting service worker at registration\n     * time then the promise will not resolve until an update is found and starts\n     * installing, at which point the installing service worker is used.\n     *\n     * @return {Promise<ServiceWorker>}\n     */\n    getSW() {\n        // If `this._sw` is set, resolve with that as we want `getSW()` to\n        // return the correct (new) service worker if an update is found.\n        return this._sw !== undefined\n            ? Promise.resolve(this._sw)\n            : this._swDeferred.promise;\n    }\n    /**\n     * Sends the passed data object to the service worker registered by this\n     * instance (via {@link workbox-window.Workbox#getSW}) and resolves\n     * with a response (if any).\n     *\n     * A response can be set in a message handler in the service worker by\n     * calling `event.ports[0].postMessage(...)`, which will resolve the promise\n     * returned by `messageSW()`. If no response is set, the promise will never\n     * resolve.\n     *\n     * @param {Object} data An object to send to the service worker\n     * @return {Promise<Object>}\n     */\n    // We might be able to change the 'data' type to Record<string, unknown> in the future.\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    async messageSW(data) {\n        const sw = await this.getSW();\n        return messageSW(sw, data);\n    }\n    /**\n     * Sends a `{type: 'SKIP_WAITING'}` message to the service worker that's\n     * currently in the `waiting` state associated with the current registration.\n     *\n     * If there is no current registration or no service worker is `waiting`,\n     * calling this will have no effect.\n     */\n    messageSkipWaiting() {\n        if (this._registration && this._registration.waiting) {\n            void messageSW(this._registration.waiting, SKIP_WAITING_MESSAGE);\n        }\n    }\n    /**\n     * Checks for a service worker already controlling the page and returns\n     * it if its script URL matches.\n     *\n     * @private\n     * @return {ServiceWorker|undefined}\n     */\n    _getControllingSWIfCompatible() {\n        const controller = navigator.serviceWorker.controller;\n        if (controller &&\n            urlsMatch(controller.scriptURL, this._scriptURL.toString())) {\n            return controller;\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Registers a service worker for this instances script URL and register\n     * options and tracks the time registration was complete.\n     *\n     * @private\n     */\n    async _registerScript() {\n        try {\n            // this._scriptURL may be a TrustedScriptURL, but there's no support for\n            // passing that to register() in lib.dom right now.\n            // https://github.com/GoogleChrome/workbox/issues/2855\n            const reg = await navigator.serviceWorker.register(this._scriptURL, this._registerOptions);\n            // Keep track of when registration happened, so it can be used in the\n            // `this._onUpdateFound` heuristic. Also use the presence of this\n            // property as a way to see if `.register()` has been called.\n            this._registrationTime = performance.now();\n            return reg;\n        }\n        catch (error) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(error);\n            }\n            // Re-throw the error.\n            throw error;\n        }\n    }\n}\nexport { Workbox };\n// The jsdoc comments below outline the events this instance may dispatch:\n// -----------------------------------------------------------------------\n/**\n * The `message` event is dispatched any time a `postMessage` is received.\n *\n * @event workbox-window.Workbox#message\n * @type {WorkboxEvent}\n * @property {*} data The `data` property from the original `message` event.\n * @property {Event} originalEvent The original [`message`]{@link https://developer.mozilla.org/en-US/docs/Web/API/MessageEvent}\n *     event.\n * @property {string} type `message`.\n * @property {MessagePort[]} ports The `ports` value from `originalEvent`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `installed` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * {@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw|registered service worker}\n * changes to `installed`.\n *\n * Then can happen either the very first time a service worker is installed,\n * or after an update to the current service worker is found. In the case\n * of an update being found, the event's `isUpdate` property will be `true`.\n *\n * @event workbox-window.Workbox#installed\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `installed`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `waiting` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `installed` and then doesn't immediately change to `activating`.\n * It may also be dispatched if a service worker with the same\n * [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * was already waiting when the {@link workbox-window.Workbox#register}\n * method was called.\n *\n * @event workbox-window.Workbox#waiting\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event|undefined} originalEvent The original\n *    [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event, or `undefined` in the case where the service worker was waiting\n *     to before `.register()` was called.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {boolean|undefined} wasWaitingBeforeRegister True if a service worker with\n *     a matching `scriptURL` was already waiting when this `Workbox`\n *     instance called `register()`.\n * @property {string} type `waiting`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `controlling` event is dispatched if a\n * [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n * fires on the service worker [container]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer}\n * and the [`scriptURL`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/scriptURL}\n * of the new [controller]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/controller}\n * matches the `scriptURL` of the `Workbox` instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}.\n *\n * @event workbox-window.Workbox#controlling\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`controllerchange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorkerContainer/oncontrollerchange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this service worker was registered.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `controlling`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `activated` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * {@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw|registered service worker}\n * changes to `activated`.\n *\n * @event workbox-window.Workbox#activated\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {boolean|undefined} isExternal True if this event is associated\n *     with an [external service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-window#when_an_unexpected_version_of_the_service_worker_is_found}.\n * @property {string} type `activated`.\n * @property {Workbox} target The `Workbox` instance.\n */\n/**\n * The `redundant` event is dispatched if the state of a\n * {@link workbox-window.Workbox} instance's\n * [registered service worker]{@link https://developers.google.com/web/tools/workbox/modules/workbox-precaching#def-registered-sw}\n * changes to `redundant`.\n *\n * @event workbox-window.Workbox#redundant\n * @type {WorkboxEvent}\n * @property {ServiceWorker} sw The service worker instance.\n * @property {Event} originalEvent The original [`statechange`]{@link https://developer.mozilla.org/en-US/docs/Web/API/ServiceWorker/onstatechange}\n *     event.\n * @property {boolean|undefined} isUpdate True if a service worker was already\n *     controlling when this `Workbox` instance called `register()`.\n * @property {string} type `redundant`.\n * @property {Workbox} target The `Workbox` instance.\n */\n","/*\n  Copyright 2019 Google LLC\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport '../_version.js';\n/**\n * A helper function that prevents a promise from being flagged as unused.\n *\n * @private\n **/\nexport function dontWaitFor(promise) {\n    // Effective no-op.\n    void promise.then(() => { });\n}\n","/*\n  Copyright 2019 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\n/**\n * A minimal `EventTarget` shim.\n * This is necessary because not all browsers support constructable\n * `EventTarget`, so using a real `EventTarget` will error.\n * @private\n */\nexport class WorkboxEventTarget {\n    constructor() {\n        this._eventListenerRegistry = new Map();\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    addEventListener(type, listener) {\n        const foo = this._getEventListenersByType(type);\n        foo.add(listener);\n    }\n    /**\n     * @param {string} type\n     * @param {Function} listener\n     * @private\n     */\n    removeEventListener(type, listener) {\n        this._getEventListenersByType(type).delete(listener);\n    }\n    /**\n     * @param {Object} event\n     * @private\n     */\n    dispatchEvent(event) {\n        event.target = this;\n        const listeners = this._getEventListenersByType(event.type);\n        for (const listener of listeners) {\n            listener(event);\n        }\n    }\n    /**\n     * Returns a Set of listeners associated with the passed event type.\n     * If no handlers have been registered, an empty Set is returned.\n     *\n     * @param {string} type The event type.\n     * @return {Set<ListenerCallback>} An array of handler functions.\n     * @private\n     */\n    _getEventListenersByType(type) {\n        if (!this._eventListenerRegistry.has(type)) {\n            this._eventListenerRegistry.set(type, new Set());\n        }\n        return this._eventListenerRegistry.get(type);\n    }\n}\n"],"mappings":"AAEA;EACIA,IAAA,CAAK,2BAA2BC,CAAA,EACpC;AAAA,CACA,QAAOC,CAAA,GAAG;ACmBV,SAASA,EAAUA,CAAA,EAAIC,CAAA;EACnB,OAAO,IAAIC,OAAA,CAAQ,UAACC,CAAA;IAChB,IAAMC,CAAA,GAAiB,IAAIC,cAAA;IAC3BD,CAAA,CAAeE,KAAA,CAAMC,SAAA,GAAY,UAACP,CAAA;MAC9BG,CAAA,CAAQH,CAAA,CAAMQ,IAAA;IAAA,GAElBR,CAAA,CAAGS,WAAA,CAAYR,CAAA,EAAM,CAACG,CAAA,CAAeM,KAAA,EACzC;EAAA,EACJ;AAAA;AAAA,SAAAT,EAAAD,CAAA;EAAA,IAAAC,CAAA,aAAAD,CAAA,EAAAC,CAAA;IAAA,uBAAAD,CAAA,KAAAA,CAAA,SAAAA,CAAA;IAAA,IAAAG,CAAA,GAAAH,CAAA,CAAAW,MAAA,CAAAC,WAAA;IAAA,eAAAT,CAAA;MAAA,IAAAC,CAAA,GAAAD,CAAA,CAAAU,IAAA,CAAAb,CAAA,EAAAC,CAAA;MAAA,uBAAAG,CAAA,SAAAA,CAAA;MAAA,UAAAU,SAAA;IAAA;IAAA,qBAAAb,CAAA,GAAAc,MAAA,GAAAC,MAAA,EAAAhB,CAAA;EAAA,EAAAA,CAAA;EAAA,0BAAAC,CAAA,GAAAA,CAAA,GAAAA,CAAA;AAAA;AAAA,SAAAE,EAAAH,CAAA,EAAAG,CAAA;EAAA,SAAAC,CAAA,MAAAA,CAAA,GAAAD,CAAA,CAAAc,MAAA,EAAAb,CAAA;IAAA,IAAAc,CAAA,GAAAf,CAAA,CAAAC,CAAA;IAAAc,CAAA,CAAAC,UAAA,GAAAD,CAAA,CAAAC,UAAA,QAAAD,CAAA,CAAAE,YAAA,kBAAAF,CAAA,KAAAA,CAAA,CAAAG,QAAA,QAAAC,MAAA,CAAAC,cAAA,CAAAvB,CAAA,EAAAC,CAAA,CAAAiB,CAAA,CAAAM,GAAA,GAAAN,CAAA;EAAA;AAAA;AAAA,SAAAd,EAAAJ,CAAA,EAAAC,CAAA;EAAA,OAAAG,CAAA,GAAAkB,MAAA,CAAAG,cAAA,GAAAH,MAAA,CAAAG,cAAA,CAAAC,IAAA,eAAA1B,CAAA,EAAAC,CAAA;IAAA,OAAAD,CAAA,CAAA2B,SAAA,GAAA1B,CAAA,EAAAD,CAAA;EAAA,GAAAI,CAAA,CAAAJ,CAAA,EAAAC,CAAA;AAAA;AAAA,SAAAiB,EAAAlB,CAAA,EAAAC,CAAA;EAAA,SAAAA,CAAA,IAAAA,CAAA,GAAAD,CAAA,CAAAiB,MAAA,MAAAhB,CAAA,GAAAD,CAAA,CAAAiB,MAAA;EAAA,SAAAd,CAAA,MAAAC,CAAA,OAAAwB,KAAA,CAAA3B,CAAA,GAAAE,CAAA,GAAAF,CAAA,EAAAE,CAAA,IAAAC,CAAA,CAAAD,CAAA,IAAAH,CAAA,CAAAG,CAAA;EAAA,OAAAC,CAAA;AAAA;AAAA,SAAAyB,EAAA7B,CAAA,EAAAC,CAAA;EAAA,IAAAE,CAAA,yBAAAQ,MAAA,IAAAX,CAAA,CAAAW,MAAA,CAAAmB,QAAA,KAAA9B,CAAA;EAAA,IAAAG,CAAA,UAAAA,CAAA,GAAAA,CAAA,CAAAU,IAAA,CAAAb,CAAA,GAAA+B,IAAA,CAAAL,IAAA,CAAAvB,CAAA;EAAA,IAAAyB,KAAA,CAAAI,OAAA,CAAAhC,CAAA,MAAAG,CAAA,aAAAH,CAAA,EAAAC,CAAA;IAAA,IAAAD,CAAA;MAAA,uBAAAA,CAAA,SAAAkB,CAAA,CAAAlB,CAAA,EAAAC,CAAA;MAAA,IAAAE,CAAA,GAAAmB,MAAA,CAAAW,SAAA,CAAAC,QAAA,CAAArB,IAAA,CAAAb,CAAA,EAAAmC,KAAA;MAAA,oBAAAhC,CAAA,IAAAH,CAAA,CAAAoC,WAAA,KAAAjC,CAAA,GAAAH,CAAA,CAAAoC,WAAA,CAAAC,IAAA,aAAAlC,CAAA,cAAAA,CAAA,GAAAyB,KAAA,CAAAU,IAAA,CAAAtC,CAAA,oBAAAG,CAAA,+CAAAoC,IAAA,CAAApC,CAAA,IAAAe,CAAA,CAAAlB,CAAA,EAAAC,CAAA;IAAA;EAAA,EAAAD,CAAA,MAAAC,CAAA,IAAAD,CAAA,uBAAAA,CAAA,CAAAiB,MAAA;IAAAd,CAAA,KAAAH,CAAA,GAAAG,CAAA;IAAA,IAAAC,CAAA;IAAA;MAAA,OAAAA,CAAA,IAAAJ,CAAA,CAAAiB,MAAA;QAAAuB,IAAA;MAAA;QAAAA,IAAA;QAAAC,KAAA,EAAAzC,CAAA,CAAAI,CAAA;MAAA;IAAA;EAAA;EAAA,UAAAU,SAAA;AAAA;AC9BA;EACIhB,IAAA,CAAK,yBAAyBC,CAAA,EAClC;AAAA,CACA,QAAOC,CAAA,GAAG;ACGV,IAQM0C,CAAA,GAIF,SAAAC,CAAA;EAAc,IAAA3C,CAAA;EACV,KAAK4C,OAAA,GAAU,IAAI1C,OAAA,CAAQ,UAACD,CAAA,EAASE,CAAA;IACjCH,CAAA,CAAK6C,OAAA,GAAU5C,CAAA,EACfD,CAAA,CAAK8C,MAAA,GAAS3C,CAClB;EAAA,EACJ;AAAA;ACRG,SAAS4C,EAAU/C,CAAA,EAAMC,CAAA;EAC5B,IAAQE,CAAA,GAAS6C,QAAA,CAATC,IAAA;EACR,OAAO,IAAIC,GAAA,CAAIlD,CAAA,EAAMG,CAAA,EAAM8C,IAAA,KAAS,IAAIC,GAAA,CAAIjD,CAAA,EAAME,CAAA,EAAM8C,IAC5D;AAAA;ACNA,IAAaE,CAAA,GACT,SAAAC,CAAYpD,CAAA,EAAMC,CAAA;EACd,KAAKoD,IAAA,GAAOrD,CAAA,EACZsB,MAAA,CAAOgC,MAAA,CAAO,MAAMrD,CAAA,CACxB;AAAA;ACkEG,SAASsD,EAAOvD,CAAA,EAAOC,CAAA,EAAME,CAAA;EACnC,OAAIA,CAAA,GACIF,CAAA,GAAOA,CAAA,CAAKD,CAAA,IAASA,CAAA,IAExBA,CAAA,IAAUA,CAAA,CAAMwD,IAAA,KACpBxD,CAAA,GAAQE,OAAA,CAAQ2C,OAAA,CAAQ7C,CAAA,IAElBC,CAAA,GAAOD,CAAA,CAAMwD,IAAA,CAAKvD,CAAA,IAAQD,CAAA,CAClC;AAAA;AAogBO,SAASyD,EAAA,GAChB;AAzkBA,IAAMC,CAAA,GAAuB;EAAEL,IAAA,EAAM;AAAA;AAuE9B,SAASM,EAAc3D,CAAA,EAAOC,CAAA;EACpC,KAAKA,CAAA,EACJ,OAAOD,CAAA,IAASA,CAAA,CAAMwD,IAAA,GAAOxD,CAAA,CAAMwD,IAAA,CAAKC,CAAA,IAAUvD,OAAA,CAAQ2C,OAAA,EAE5D;AAAA;AA9DM,IAAAe,CAAA,aAAO3D,CAAA;EAaT,SAAAiB,EAAYlB,CAAA,EAAWG,CAAA;IAAsB,IAAAC,CAAA,EAoB1Bc,CAAA;IAsMsD,YA1NnC,MAAff,CAAA,KAAAA,CAAA,GAAkB,MACrCC,CAAA,GAAAH,CAAA,CAAAY,IAAA,UAAO,MACFgD,EAAA,GAAmB,IACxBzD,CAAA,CAAK0D,EAAA,GAAoB,GAEzB1D,CAAA,CAAK2D,EAAA,GAAc,IAAIrB,CAAA,IACvBtC,CAAA,CAAK4D,EAAA,GAAkB,IAAItB,CAAA,IAC3BtC,CAAA,CAAK6D,EAAA,GAAuB,IAAIvB,CAAA,IAChCtC,CAAA,CAAK8D,EAAA,GAAoB,GACzB9D,CAAA,CAAK+D,EAAA,GAAU,IAAIC,GAAA,IAInBhE,CAAA,CAAKiE,EAAA,GAAiB;MAElB,IAAMrE,CAAA,GAAeI,CAAA,CAAKkE,EAAA;QACpBrE,CAAA,GAAeD,CAAA,CAAauE,UAAA;MAkBlCnE,CAAA,CAAK0D,EAAA,GAAoB,MAIpBf,CAAA,CAAU9C,CAAA,CAAauE,SAAA,EAAWpE,CAAA,CAAKqE,EAAA,CAAWvC,QAAA,OAInDwC,WAAA,CAAYC,GAAA,KAAQvE,CAAA,CAAK8D,EAAA,GAvEH,OA6EtB9D,CAAA,CAAKwE,EAAA,GAAc3E,CAAA,EACnBD,CAAA,CAAa6E,mBAAA,CAAoB,eAAezE,CAAA,CAAKiE,EAAA,MAKrDjE,CAAA,CAAK0E,EAAA,GAAM7E,CAAA,EACXG,CAAA,CAAK+D,EAAA,CAAQY,GAAA,CAAI9E,CAAA,GACjBG,CAAA,CAAK2D,EAAA,CAAYlB,OAAA,CAAQ5C,CAAA,MAc3BG,CAAA,CAAK0D,EAAA,EAGP7D,CAAA,CAAa+E,gBAAA,CAAiB,eAAe5E,CAAA,CAAK6E,EAAA;IAAA,GAMtD7E,CAAA,CAAK6E,EAAA,GAAiB,UAACjF,CAAA;MAEnB,IAAMC,CAAA,GAAeG,CAAA,CAAKkE,EAAA;QACpBnE,CAAA,GAAKH,CAAA,CAAckF,MAAA;QACjBhE,CAAA,GAAUf,CAAA,CAAVgF,KAAA;QACFtD,CAAA,GAAa1B,CAAA,KAAOC,CAAA,CAAKwE,EAAA;QACzBlC,CAAA,GAAa;UACf0C,EAAA,EAAAjF,CAAA;UACAkF,UAAA,EAAAxD,CAAA;UACAyD,aAAA,EAAAtF;QAAA;MAAA,CAEC6B,CAAA,IAAczB,CAAA,CAAKmF,EAAA,KACpB7C,CAAA,CAAW8C,QAAA,IAAW,IAE1BpF,CAAA,CAAKqF,aAAA,CAAc,IAAItC,CAAA,CAAajC,CAAA,EAAOwB,CAAA,IAC7B,gBAAVxB,CAAA,GASAd,CAAA,CAAKsF,EAAA,GAAkB5F,IAAA,CAAK6F,UAAA,CAAW;QAErB,gBAAVzE,CAAA,IAAyBjB,CAAA,CAAa2F,OAAA,KAAYzF,CAAA,IAClDC,CAAA,CAAKqF,aAAA,CAAc,IAAItC,CAAA,CAAa,WAAWT,CAAA,EAYtD;MAAA,GAtJgB,OAwJF,iBAAVxB,CAAA,KACL2E,YAAA,CAAazF,CAAA,CAAKsF,EAAA,GACb7D,CAAA,IACDzB,CAAA,CAAK4D,EAAA,CAAgBnB,OAAA,CAAQ1C,CAAA;IAAA,GA0CzCC,CAAA,CAAK0F,EAAA,GAAsB,UAAC9F,CAAA;MACxB,IAAMC,CAAA,GAAKG,CAAA,CAAK0E,EAAA;QACV3E,CAAA,GAAaF,CAAA,KAAO8F,SAAA,CAAUC,aAAA,CAAcC,UAAA;MAKlD7F,CAAA,CAAKqF,aAAA,CAAc,IAAItC,CAAA,CAAa,eAAe;QAC/CkC,UAAA,EAAAlF,CAAA;QACAmF,aAAA,EAAAtF,CAAA;QACAoF,EAAA,EAAAnF,CAAA;QACAuF,QAAA,EAAUpF,CAAA,CAAKmF;MAAA,KAEdpF,CAAA,IAIDC,CAAA,CAAK6D,EAAA,CAAqBpB,OAAA,CAAQ5C,CAAA;IAAA,GAO1CG,CAAA,CAAK8F,EAAA,IAzKUhF,CAAA,GAyKA,SAAAqC,CAAUvD,CAAA;MAGrB,IAAQC,CAAA,GAAwBD,CAAA,CAAxBQ,IAAA;QAAML,CAAA,GAAkBH,CAAA,CAAlBmG,KAAA;QAAOjF,CAAA,GAAWlB,CAAA,CAAXoG,MAAA;MAErB,OAAA7C,CAAA,CACMnD,CAAA,CAAKiG,KAAA,IAAO;QAOdjG,CAAA,CAAK+D,EAAA,CAAQmC,GAAA,CAAIpF,CAAA,KACjBd,CAAA,CAAKqF,aAAA,CAAc,IAAItC,CAAA,CAAa,WAAW;UAG3C3C,IAAA,EAAAP,CAAA;UACAqF,aAAA,EAAAtF,CAAA;UACAmG,KAAA,EAAAhG,CAAA;UACAiF,EAAA,EAAIlE;QAAA;MAAA;IAAA,GA5LhB;MACN,KAAK,IAAIlB,CAAA,GAAO,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAIsG,SAAA,CAAUtF,MAAA,EAAQhB,CAAA,IAChDD,CAAA,CAAKC,CAAA,IAAKsG,SAAA,CAAUtG,CAAA;MAErB;QACC,OAAOC,OAAA,CAAQ2C,OAAA,CAAQ3B,CAAA,CAAEsF,KAAA,CAAM,MAAMxG,CAAA,EACrC;MAAA,CAAC,QAAMA,CAAA;QACP,OAAOE,OAAA,CAAQ4C,MAAA,CAAO9C,CAAA,CACvB;MAAA;IAAA,IAwLMI,CAAA,CAAKqE,EAAA,GAAazE,CAAA,EAClBI,CAAA,CAAKyD,EAAA,GAAmB1D,CAAA,EAIxB4F,SAAA,CAAUC,aAAA,CAAchB,gBAAA,CAAiB,WAAW5E,CAAA,CAAK8F,EAAA,GAAY9F,CACzE;EAAA;EAAA,IAAAyB,CAAA,EAAA4B,CAAA;EAAAA,CAAA,GACAxD,CAAA,GAAA4B,CAAA,GAAAX,CAAA,EAAAe,SAAA,GAAAX,MAAA,CAAAmF,MAAA,CAAAhD,CAAA,CAAAxB,SAAA,GAAAJ,CAAA,CAAAI,SAAA,CAAAG,WAAA,GAAAP,CAAA,EAAAzB,CAAA,CAAAyB,CAAA,EAAA4B,CAAA;EAAA,IAAAG,CAAA;IAAA8C,CAAA;IAAAC,CAAA;IAAAC,CAAA,GAAA1F,CAAA,CAAAe,SAAA;EAqOC,OArOD2E,CAAA,CAUMC,QAAA,GAAQ,UAAA7G,CAAA;IAAA,IAA2BC,CAAA,eAA3BD,CAAA,GAAyB,CAAE,IAAAA,CAAA,EAAxB8G,SAAA;MAAA3G,CAAA,QAAY,MAAHF,CAAA,IAAQA,CAAA;IAAA;MAAS,IAAAG,CAAA,GAE/B;MAKP,OAAAmD,CAAA,CAkQF,UAAiBvD,CAAA,EAAMC,CAAA;QAC7B,IAAIE,CAAA,GAASH,CAAA;QACb,IAAIG,CAAA,IAAUA,CAAA,CAAOqD,IAAA,EACpB,OAAOrD,CAAA,CAAOqD,IAAA,CAAKvD,CAAA;QAEpB,OAAOA,CAAA,CAAKE,CAAA,CACb;MAAA,CAxQS;QAAA,KACIA,CAAA,IAAqC,eAAxB4G,QAAA,CAASC,UAAA,EAAyB,OAAArD,CAAA,CAC1C,IAAIzD,OAAA,CAAQ,UAACF,CAAA;UAAG,OAAKiH,MAAA,CAAOjC,gBAAA,CAAiB,QAAQhF,CAAA,CAAK;QAAA;MAAA;QAQC,OAJrEI,CAAA,CAAKmF,EAAA,GAAY2B,OAAA,CAAQnB,SAAA,CAAUC,aAAA,CAAcC,UAAA,GAIjD7F,CAAA,CAAK+G,EAAA,GAA2B/G,CAAA,CAAKgH,EAAA,IAAgC7D,CAAA,CAC1CnD,CAAA,CAAKiH,EAAA,cAAiBrH,CAAA;UAAjDI,CAAA,CAAKkE,EAAA,GAAatE,CAAA,EAGdI,CAAA,CAAK+G,EAAA,KACL/G,CAAA,CAAK0E,EAAA,GAAM1E,CAAA,CAAK+G,EAAA,EAChB/G,CAAA,CAAK4D,EAAA,CAAgBnB,OAAA,CAAQzC,CAAA,CAAK+G,EAAA,GAClC/G,CAAA,CAAK6D,EAAA,CAAqBpB,OAAA,CAAQzC,CAAA,CAAK+G,EAAA,GACvC/G,CAAA,CAAK+G,EAAA,CAAyBnC,gBAAA,CAAiB,eAAe5E,CAAA,CAAK6E,EAAA,EAAgB;YAAEqC,IAAA,GAAM;UAAA;UAO/F,IAAMrH,CAAA,GAAYG,CAAA,CAAKkE,EAAA,CAAcsB,OAAA;UAiDrC,OAhDI3F,CAAA,IACA8C,CAAA,CAAU9C,CAAA,CAAUuE,SAAA,EAAWpE,CAAA,CAAKqE,EAAA,CAAWvC,QAAA,QAG/C9B,CAAA,CAAK0E,EAAA,GAAM7E,CAAA,EAGCC,OAAA,CAAQ2C,OAAA,GAAUW,IAAA,CAAK;YAC/BpD,CAAA,CAAKqF,aAAA,CAAc,IAAItC,CAAA,CAAa,WAAW;cAC3CiC,EAAA,EAAInF,CAAA;cACJsH,wBAAA,GAA0B;YAAA,GAMjC;UAAA,GC3TI/D,IAAA,CAAK,aAAM,KD8ThBpD,CAAA,CAAK0E,EAAA,KACL1E,CAAA,CAAK2D,EAAA,CAAYlB,OAAA,CAAQzC,CAAA,CAAK0E,EAAA,GAC9B1E,CAAA,CAAK+D,EAAA,CAAQY,GAAA,CAAI3E,CAAA,CAAK0E,EAAA,IAyB1B1E,CAAA,CAAKkE,EAAA,CAAcU,gBAAA,CAAiB,eAAe5E,CAAA,CAAKiE,EAAA,GACxD0B,SAAA,CAAUC,aAAA,CAAchB,gBAAA,CAAiB,oBAAoB5E,CAAA,CAAK0F,EAAA,GAC3D1F,CAAA,CAAKkE,EAAc;QAAA;MAAA,GAC7B;IAAA,SAAAtE,CAAA;MAAA,OAAAE,OAAA,CAAA4C,MAAA,CAAA9C,CAAA;IAAA;EAAA,GACD4G,CAAA,CAGMY,MAAA,GAAM;IAAA;MACR,OAAK,KAAKlD,EAAA,GAOVf,CAAA,CAAAI,CAAA,CAPK,KAQMW,EAAA,CAAckD,MAAA,OAHrBjE,CAAA,EAIP;IAAA,SAAAvD,CAAA;MAAA,OAAAE,OAAA,CAAA4C,MAAA,CAAA9C,CAAA;IAAA;EAAA,GA4BD4G,CAAA,CAeAP,KAAA;IAGI,YAAoB,MAAb,KAAKvB,EAAA,GACN5E,OAAA,CAAQ2C,OAAA,CAAQ,KAAKiC,EAAA,IACrB,KAAKf,EAAA,CAAYnB,OAC3B;EAAA,GAeAgE,CAAA,CACMa,SAAA,GAAS,UAACxH,CAAA;IAAI;MACK,OAAAsD,CAAA,CAAJ,KAAK8C,KAAA,cAAhBlG,CAAA;QACN,OAAOH,CAAA,CAAUG,CAAA,EAAIF,CAAA,CAAM;MAAA,EAC9B;IAAA,SAAAD,CAAA;MAAA,OAAAE,OAAA,CAAA4C,MAAA,CAAA9C,CAAA;IAAA;EAAA,GACD4G,CAAA,CAOAc,kBAAA;IACQ,KAAKpD,EAAA,IAAiB,KAAKA,EAAA,CAAcsB,OAAA,IACpC5F,CAAA,CAAU,KAAKsE,EAAA,CAAcsB,OAAA,EAASlC,CAAA,CAEnD;EAAA,GACAkD,CAAA,CAOAQ,EAAA;IACI,IAAMpH,CAAA,GAAa+F,SAAA,CAAUC,aAAA,CAAcC,UAAA;IAC3C,OAAIjG,CAAA,IACA+C,CAAA,CAAU/C,CAAA,CAAWwE,SAAA,EAAW,KAAKC,EAAA,CAAWvC,QAAA,MACzClC,CAAA,QAGP,CAER;EAAA,GACA4G,CAAA,CAMMS,EAAA,GAAe;IAAA;MAAG,IAAArH,CAAA,GAKmC;MAAI,OAAAuD,CAAA,CA6E5D,UAAgBvD,CAAA,EAAMC,CAAA;QAC5B;UACC,IAAIE,CAAA,GAASH,CAAA,EACb;QAAA,CAAC,QAAMA,CAAA;UACP,OAAOC,CAAA,CAAQD,CAAA,CAChB;QAAA;QACA,IAAIG,CAAA,IAAUA,CAAA,CAAOqD,IAAA,EACpB,OAAOrD,CAAA,CAAOqD,IAAA,MAAK,GAAQvD,CAAA;QAE5B,OAAOE,CACR;MAAA,CAvFmE,CAJvD;QAGA,OAAAoD,CAAA,CACkBwC,SAAA,CAAUC,aAAA,CAAca,QAAA,CAAS7G,CAAA,CAAKyE,EAAA,EAAYzE,CAAA,CAAK6D,EAAA,aAAnE5D,CAAA;UAKN,OADAD,CAAA,CAAKkE,EAAA,GAAoBQ,WAAA,CAAYC,GAAA,IAC9B1E,CAAI;QAAA,EACd;MAAA,aACMD,CAAA;QAKH,MAAMA,CACT;MAAA,GACJ;IAAA,SAAAA,CAAA;MAAA,OAAAE,OAAA,CAAA4C,MAAA,CAAA9C,CAAA;IAAA;EAAA,GAAA4D,CAAA,GAAA1C,CAAA,GAAAwF,CAAA;IAAAlF,GAAA;IAAAmG,GAAA,EAjHD,SAAAA,CAAA;MACI,OAAO,KAAK3D,EAAA,CAAgBpB,OAChC;IAAA;EAAA,GACA;IAAApB,GAAA;IAAAmG,GAAA,EAYA,SAAAA,CAAA;MACI,OAAO,KAAK1D,EAAA,CAAqBrB,OACrC;IAAA;EAAA,OAAAzC,CAAA,CAAAyD,CAAA,CAAA3B,SAAA,EAAAyE,CAAA,GAAAC,CAAA,IAAAxG,CAAA,CAAAyD,CAAA,EAAA+C,CAAA,GAAArF,MAAA,CAAAC,cAAA,CAAAqC,CAAA;IAAAvC,QAAA;EAAA,IAAAuC,CAAC;AAAA,EEtY0B;EAC3B,SAAA5D,EAAA;IACI,KAAK4H,EAAA,GAAyB,IAAIC,GACtC,CADsC,CACtC;EAAA;EACA,IAAA5H,CAAA,GAAAD,CAAA,CAAAiC,SAAA;EAyCC,OAzCDhC,CAAA,CAKA+E,gBAAA,aAAiBhF,CAAA,EAAMC,CAAA;IACP,KAAK6H,EAAA,CAAyB9H,CAAA,EACtC+E,GAAA,CAAI9E,CAAA,CACZ;EAAA,GACAA,CAAA,CAKA4E,mBAAA,aAAoB7E,CAAA,EAAMC,CAAA;IACtB,KAAK6H,EAAA,CAAyB9H,CAAA,EAAM+H,MAAA,CAAO9H,CAAA,CAC/C;EAAA,GACAA,CAAA,CAIAwF,aAAA,aAAczF,CAAA;IACVA,CAAA,CAAMkF,MAAA,GAAS;IAEf,KADA,IACgCjF,CAAA,EAAhCE,CAAA,GAAA0B,CAAA,CADkB,KAAKiG,EAAA,CAAyB9H,CAAA,CAAMqD,IAAA,MACtBpD,CAAA,GAAAE,CAAA,IAAAqC,IAAA,GAAE;MAAA,CAC9B,GADevC,CAAA,CAAAwC,KAAA,EACNzC,CAAA,CACb;IAAA;EACJ,GACAC,CAAA,CAQA6H,EAAA,aAAyB9H,CAAA;IAIrB,OAHK,KAAK4H,EAAA,CAAuBtB,GAAA,CAAItG,CAAA,KACjC,KAAK4H,EAAA,CAAuBI,GAAA,CAAIhI,CAAA,EAAM,IAAIoE,GAAA,KAEvC,KAAKwD,EAAA,CAAuBD,GAAA,CAAI3H,CAAA;EAAA,GAC1CA,CAAA;AAAA,CA7C0B;AAAA,SAAA4D,CAAA,IAAAqE,OAAA,EAAA9E,CAAA,IAAAC,YAAA,EAAApD,CAAA,IAAAyH,SAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}