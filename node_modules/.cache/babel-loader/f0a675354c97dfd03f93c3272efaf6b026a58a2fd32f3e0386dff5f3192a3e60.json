{"ast":null,"code":"var _s = $RefreshSig$(),\n  _s2 = $RefreshSig$(),\n  _s3 = $RefreshSig$(),\n  _s4 = $RefreshSig$(),\n  _s5 = $RefreshSig$(),\n  _s6 = $RefreshSig$(),\n  _s7 = $RefreshSig$(),\n  _s8 = $RefreshSig$(),\n  _s9 = $RefreshSig$(),\n  _s0 = $RefreshSig$(),\n  _s1 = $RefreshSig$(),\n  _s10 = $RefreshSig$(),\n  _s11 = $RefreshSig$(),\n  _s12 = $RefreshSig$(),\n  _s13 = $RefreshSig$(),\n  _s14 = $RefreshSig$(),\n  _s15 = $RefreshSig$(),\n  _s16 = $RefreshSig$(),\n  _s17 = $RefreshSig$(),\n  _s18 = $RefreshSig$();\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { toast } from 'react-hot-toast';\nimport { interviewService } from '../services';\nimport { queryKeys, invalidateQueries, optimisticUpdates } from '../lib/queryClient';\n// Query hooks\nexport const useInterviews = positionId => {\n  _s();\n  return useQuery({\n    queryKey: queryKeys.interviews.list(positionId),\n    queryFn: () => interviewService.getInterviews(positionId),\n    enabled: !!positionId,\n    staleTime: 2 * 60 * 1000 // 2 minutes\n  });\n};\n_s(useInterviews, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [useQuery];\n});\nexport const useInterview = id => {\n  _s2();\n  return useQuery({\n    queryKey: queryKeys.interviews.detail(id),\n    queryFn: () => interviewService.getInterview(id),\n    enabled: !!id,\n    staleTime: 5 * 60 * 1000\n  });\n};\n_s2(useInterview, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [useQuery];\n});\nexport const useAllUserInterviews = () => {\n  _s3();\n  return useQuery({\n    queryKey: queryKeys.interviews.all,\n    queryFn: () => interviewService.getAllUserInterviews(),\n    staleTime: 2 * 60 * 1000\n  });\n};\n_s3(useAllUserInterviews, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [useQuery];\n});\nexport const useUpcomingInterviews = () => {\n  _s4();\n  return useQuery({\n    queryKey: queryKeys.interviews.upcoming(),\n    queryFn: () => interviewService.getUpcomingInterviews(),\n    staleTime: 1 * 60 * 1000 // 1 minute for time-sensitive data\n  });\n};\n_s4(useUpcomingInterviews, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [useQuery];\n});\nexport const useTodaysInterviews = () => {\n  _s5();\n  return useQuery({\n    queryKey: queryKeys.interviews.today(),\n    queryFn: () => interviewService.getTodaysInterviews(),\n    staleTime: 30 * 1000,\n    // 30 seconds for very time-sensitive data\n    refetchInterval: 60 * 1000 // Refetch every minute\n  });\n};\n_s5(useTodaysInterviews, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [useQuery];\n});\nexport const useOverdueInterviews = () => {\n  _s6();\n  return useQuery({\n    queryKey: queryKeys.interviews.overdue(),\n    queryFn: () => interviewService.getOverdueInterviews(),\n    staleTime: 1 * 60 * 1000\n  });\n};\n_s6(useOverdueInterviews, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [useQuery];\n});\nexport const useInterviewsByOutcome = outcome => {\n  _s7();\n  return useQuery({\n    queryKey: queryKeys.interviews.byOutcome(outcome),\n    queryFn: () => interviewService.getInterviewsByOutcome(outcome),\n    enabled: !!outcome,\n    staleTime: 5 * 60 * 1000\n  });\n};\n_s7(useInterviewsByOutcome, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [useQuery];\n});\nexport const usePositionInterviewStats = positionId => {\n  _s8();\n  return useQuery({\n    queryKey: queryKeys.interviews.stats(positionId),\n    queryFn: () => interviewService.getPositionInterviewStats(positionId),\n    enabled: !!positionId,\n    staleTime: 5 * 60 * 1000\n  });\n};\n\n// Mutation hooks\n_s8(usePositionInterviewStats, \"4ZpngI1uv+Uo3WQHEZmTQ5FNM+k=\", false, function () {\n  return [useQuery];\n});\nexport const useCreateInterview = () => {\n  _s9();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: data => interviewService.createInterview(data),\n    onMutate: async newInterview => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({\n        queryKey: queryKeys.interviews.list(newInterview.position_id)\n      });\n\n      // Snapshot previous value\n      const previousInterviews = queryClient.getQueryData(queryKeys.interviews.list(newInterview.position_id));\n\n      // Optimistically update\n      const tempInterview = {\n        id: `temp-${Date.now()}`,\n        ...newInterview,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString()\n      };\n      queryClient.setQueryData(queryKeys.interviews.list(newInterview.position_id), old => {\n        if (!old) return [tempInterview];\n        return [...old, tempInterview];\n      });\n      return {\n        previousInterviews,\n        positionId: newInterview.position_id\n      };\n    },\n    onError: (_err, _newInterview, context) => {\n      // Rollback on error\n      if (context !== null && context !== void 0 && context.previousInterviews) {\n        queryClient.setQueryData(queryKeys.interviews.list(context.positionId), context.previousInterviews);\n      }\n      toast.error('Failed to create interview');\n    },\n    onSuccess: _data => {\n      toast.success('Interview created successfully');\n    },\n    onSettled: (data, _error, variables) => {\n      // Always refetch after mutation\n      invalidateQueries.interview((data === null || data === void 0 ? void 0 : data.id) || 'unknown', variables.position_id);\n    }\n  });\n};\n_s9(useCreateInterview, \"YK0wzM21ECnncaq5SECwU+/SVdQ=\", false, function () {\n  return [useQueryClient, useMutation];\n});\nexport const useUpdateInterview = () => {\n  _s0();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({\n      id,\n      data\n    }) => interviewService.updateInterview(id, data),\n    onMutate: async ({\n      id,\n      data\n    }) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({\n        queryKey: queryKeys.interviews.detail(id)\n      });\n\n      // Snapshot previous value\n      const previousInterview = queryClient.getQueryData(queryKeys.interviews.detail(id));\n\n      // Get position ID for cache updates\n      const interview = previousInterview;\n      const positionId = interview === null || interview === void 0 ? void 0 : interview.position_id;\n\n      // Optimistically update\n      if (positionId) {\n        optimisticUpdates.updateInterview(id, positionId, data);\n      }\n      return {\n        previousInterview,\n        id,\n        positionId\n      };\n    },\n    onError: (_err, {\n      id\n    }, context) => {\n      // Rollback on error\n      if (context !== null && context !== void 0 && context.previousInterview) {\n        queryClient.setQueryData(queryKeys.interviews.detail(id), context.previousInterview);\n      }\n      toast.error('Failed to update interview');\n    },\n    onSuccess: () => {\n      toast.success('Interview updated successfully');\n    },\n    onSettled: (_data, _error, {\n      id\n    }, context) => {\n      // Always refetch after mutation\n      invalidateQueries.interview(id, context === null || context === void 0 ? void 0 : context.positionId);\n    }\n  });\n};\n_s0(useUpdateInterview, \"YK0wzM21ECnncaq5SECwU+/SVdQ=\", false, function () {\n  return [useQueryClient, useMutation];\n});\nexport const useUpdateInterviewField = () => {\n  _s1();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({\n      id,\n      field,\n      value\n    }) => interviewService.updateInterviewField(id, field, value),\n    onMutate: async ({\n      id,\n      field,\n      value\n    }) => {\n      await queryClient.cancelQueries({\n        queryKey: queryKeys.interviews.detail(id)\n      });\n      const previousInterview = queryClient.getQueryData(queryKeys.interviews.detail(id));\n      const positionId = previousInterview === null || previousInterview === void 0 ? void 0 : previousInterview.position_id;\n      if (positionId) {\n        optimisticUpdates.updateInterview(id, positionId, {\n          [field]: value\n        });\n      }\n      return {\n        previousInterview,\n        id,\n        positionId\n      };\n    },\n    onError: (_err, {\n      id\n    }, context) => {\n      if (context !== null && context !== void 0 && context.previousInterview) {\n        queryClient.setQueryData(queryKeys.interviews.detail(id), context.previousInterview);\n      }\n      // Don't show toast for field updates to avoid spam\n    },\n    onSettled: (_data, _error, {\n      id\n    }, context) => {\n      invalidateQueries.interview(id, context === null || context === void 0 ? void 0 : context.positionId);\n    }\n  });\n};\n_s1(useUpdateInterviewField, \"YK0wzM21ECnncaq5SECwU+/SVdQ=\", false, function () {\n  return [useQueryClient, useMutation];\n});\nexport const useUpdateInterviewDate = () => {\n  _s10();\n  const updateField = useUpdateInterviewField();\n  return useMutation({\n    mutationFn: ({\n      id,\n      scheduledDate\n    }) => updateField.mutateAsync({\n      id,\n      field: 'scheduled_date',\n      value: scheduledDate\n    }),\n    onSuccess: () => {\n      toast.success('Interview date updated');\n    },\n    onError: () => {\n      toast.error('Failed to update interview date');\n    }\n  });\n};\n_s10(useUpdateInterviewDate, \"Ep8u7a7xrRWmZs+bFM/P/LLRf0c=\", false, function () {\n  return [useUpdateInterviewField, useMutation];\n});\nexport const useUpdateInterviewOutcome = () => {\n  _s11();\n  const updateField = useUpdateInterviewField();\n  return useMutation({\n    mutationFn: ({\n      id,\n      outcome\n    }) => updateField.mutateAsync({\n      id,\n      field: 'outcome',\n      value: outcome\n    }),\n    onSuccess: () => {\n      toast.success('Interview outcome updated');\n    },\n    onError: () => {\n      toast.error('Failed to update interview outcome');\n    }\n  });\n};\n_s11(useUpdateInterviewOutcome, \"Ep8u7a7xrRWmZs+bFM/P/LLRf0c=\", false, function () {\n  return [useUpdateInterviewField, useMutation];\n});\nexport const useDeleteInterview = () => {\n  _s12();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: id => interviewService.deleteInterview(id),\n    onMutate: async id => {\n      // Get interview data to find position ID\n      const interview = queryClient.getQueryData(queryKeys.interviews.detail(id));\n      const positionId = interview === null || interview === void 0 ? void 0 : interview.position_id;\n      if (positionId) {\n        await queryClient.cancelQueries({\n          queryKey: queryKeys.interviews.list(positionId)\n        });\n        const previousInterviews = queryClient.getQueryData(queryKeys.interviews.list(positionId));\n\n        // Optimistically remove\n        queryClient.setQueryData(queryKeys.interviews.list(positionId), old => {\n          if (!old) return old;\n          return old.filter(interview => interview.id !== id);\n        });\n        return {\n          previousInterviews,\n          positionId\n        };\n      }\n      return {\n        positionId\n      };\n    },\n    onError: (_err, _id, context) => {\n      if (context !== null && context !== void 0 && context.previousInterviews && context !== null && context !== void 0 && context.positionId) {\n        queryClient.setQueryData(queryKeys.interviews.list(context.positionId), context.previousInterviews);\n      }\n      toast.error('Failed to delete interview');\n    },\n    onSuccess: () => {\n      toast.success('Interview deleted successfully');\n    },\n    onSettled: (_data, _error, id, context) => {\n      invalidateQueries.interview(id, context === null || context === void 0 ? void 0 : context.positionId);\n    }\n  });\n};\n_s12(useDeleteInterview, \"YK0wzM21ECnncaq5SECwU+/SVdQ=\", false, function () {\n  return [useQueryClient, useMutation];\n});\nexport const useRescheduleInterview = () => {\n  _s13();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({\n      id,\n      newDate,\n      notes\n    }) => interviewService.rescheduleInterview(id, newDate, notes),\n    onSuccess: () => {\n      toast.success('Interview rescheduled successfully');\n    },\n    onError: () => {\n      toast.error('Failed to reschedule interview');\n    },\n    onSettled: (_data, _error, {\n      id\n    }) => {\n      const interview = queryClient.getQueryData(queryKeys.interviews.detail(id));\n      invalidateQueries.interview(id, interview === null || interview === void 0 ? void 0 : interview.position_id);\n    }\n  });\n};\n_s13(useRescheduleInterview, \"YK0wzM21ECnncaq5SECwU+/SVdQ=\", false, function () {\n  return [useQueryClient, useMutation];\n});\nexport const useCancelInterview = () => {\n  _s14();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({\n      id,\n      reason\n    }) => interviewService.cancelInterview(id, reason),\n    onSuccess: () => {\n      toast.success('Interview cancelled');\n    },\n    onError: () => {\n      toast.error('Failed to cancel interview');\n    },\n    onSettled: (_data, _error, {\n      id\n    }) => {\n      const interview = queryClient.getQueryData(queryKeys.interviews.detail(id));\n      invalidateQueries.interview(id, interview === null || interview === void 0 ? void 0 : interview.position_id);\n    }\n  });\n};\n_s14(useCancelInterview, \"YK0wzM21ECnncaq5SECwU+/SVdQ=\", false, function () {\n  return [useQueryClient, useMutation];\n});\nexport const useCompleteInterview = () => {\n  _s15();\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: ({\n      id,\n      outcome,\n      notes\n    }) => interviewService.completeInterview(id, outcome, notes),\n    onSuccess: (_data, {\n      outcome\n    }) => {\n      toast.success(`Interview marked as ${outcome}`);\n    },\n    onError: () => {\n      toast.error('Failed to complete interview');\n    },\n    onSettled: (_data, _error, {\n      id\n    }) => {\n      const interview = queryClient.getQueryData(queryKeys.interviews.detail(id));\n      invalidateQueries.interview(id, interview === null || interview === void 0 ? void 0 : interview.position_id);\n    }\n  });\n};\n_s15(useCompleteInterview, \"YK0wzM21ECnncaq5SECwU+/SVdQ=\", false, function () {\n  return [useQueryClient, useMutation];\n});\nexport const useBulkUpdateInterviews = () => {\n  _s16();\n  return useMutation({\n    mutationFn: updates => interviewService.bulkUpdateInterviews(updates),\n    onSuccess: data => {\n      toast.success(`${data.length} interviews updated successfully`);\n    },\n    onError: () => {\n      toast.error('Failed to update interviews');\n    },\n    onSettled: () => {\n      // Invalidate all interview queries since we don't know which positions were affected\n      invalidateQueries.interviews();\n    }\n  });\n};\n\n// Combined hooks for common patterns\n_s16(useBulkUpdateInterviews, \"wwwtpB20p0aLiHIvSy5P98MwIUg=\", false, function () {\n  return [useMutation];\n});\nexport const useInterviewsWithStats = positionId => {\n  _s17();\n  const interviewsQuery = useInterviews(positionId);\n  const statsQuery = usePositionInterviewStats(positionId);\n  return {\n    interviews: interviewsQuery,\n    stats: statsQuery,\n    isLoading: interviewsQuery.isLoading || statsQuery.isLoading,\n    error: interviewsQuery.error || statsQuery.error\n  };\n};\n_s17(useInterviewsWithStats, \"A/B5pD3JwkU6nkkeb77ds40Q4Xc=\", false, function () {\n  return [useInterviews, usePositionInterviewStats];\n});\nexport const useInterviewDashboard = () => {\n  _s18();\n  const upcomingQuery = useUpcomingInterviews();\n  const todaysQuery = useTodaysInterviews();\n  const overdueQuery = useOverdueInterviews();\n  return {\n    upcoming: upcomingQuery,\n    today: todaysQuery,\n    overdue: overdueQuery,\n    isLoading: upcomingQuery.isLoading || todaysQuery.isLoading || overdueQuery.isLoading,\n    error: upcomingQuery.error || todaysQuery.error || overdueQuery.error\n  };\n};\n_s18(useInterviewDashboard, \"BcaaPUq8LEd3YrqG0u8ddTbX1og=\", false, function () {\n  return [useUpcomingInterviews, useTodaysInterviews, useOverdueInterviews];\n});","map":{"version":3,"names":["useQuery","useMutation","useQueryClient","toast","interviewService","queryKeys","invalidateQueries","optimisticUpdates","useInterviews","positionId","_s","queryKey","interviews","list","queryFn","getInterviews","enabled","staleTime","useInterview","id","_s2","detail","getInterview","useAllUserInterviews","_s3","all","getAllUserInterviews","useUpcomingInterviews","_s4","upcoming","getUpcomingInterviews","useTodaysInterviews","_s5","today","getTodaysInterviews","refetchInterval","useOverdueInterviews","_s6","overdue","getOverdueInterviews","useInterviewsByOutcome","outcome","_s7","byOutcome","getInterviewsByOutcome","usePositionInterviewStats","_s8","stats","getPositionInterviewStats","useCreateInterview","_s9","queryClient","mutationFn","data","createInterview","onMutate","newInterview","cancelQueries","position_id","previousInterviews","getQueryData","tempInterview","Date","now","created_at","toISOString","updated_at","setQueryData","old","onError","_err","_newInterview","context","error","onSuccess","_data","success","onSettled","_error","variables","interview","useUpdateInterview","_s0","updateInterview","previousInterview","useUpdateInterviewField","_s1","field","value","updateInterviewField","useUpdateInterviewDate","_s10","updateField","scheduledDate","mutateAsync","useUpdateInterviewOutcome","_s11","useDeleteInterview","_s12","deleteInterview","filter","_id","useRescheduleInterview","_s13","newDate","notes","rescheduleInterview","useCancelInterview","_s14","reason","cancelInterview","useCompleteInterview","_s15","completeInterview","useBulkUpdateInterviews","_s16","updates","bulkUpdateInterviews","length","useInterviewsWithStats","_s17","interviewsQuery","statsQuery","isLoading","useInterviewDashboard","_s18","upcomingQuery","todaysQuery","overdueQuery"],"sources":["/home/haim/github/job-search-tracker-api/frontend/src/hooks/useInterviews.ts"],"sourcesContent":["import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { toast } from 'react-hot-toast';\nimport { interviewService } from '../services';\nimport { queryKeys, invalidateQueries, optimisticUpdates } from '../lib/queryClient';\nimport {\n  Interview,\n  CreateInterviewData,\n  UpdateInterviewData,\n  InterviewOutcome,\n} from '../types';\n\n// Query hooks\nexport const useInterviews = (positionId: string) => {\n  return useQuery({\n    queryKey: queryKeys.interviews.list(positionId),\n    queryFn: () => interviewService.getInterviews(positionId),\n    enabled: !!positionId,\n    staleTime: 2 * 60 * 1000, // 2 minutes\n  });\n};\n\nexport const useInterview = (id: string) => {\n  return useQuery({\n    queryKey: queryKeys.interviews.detail(id),\n    queryFn: () => interviewService.getInterview(id),\n    enabled: !!id,\n    staleTime: 5 * 60 * 1000,\n  });\n};\n\nexport const useAllUserInterviews = () => {\n  return useQuery({\n    queryKey: queryKeys.interviews.all,\n    queryFn: () => interviewService.getAllUserInterviews(),\n    staleTime: 2 * 60 * 1000,\n  });\n};\n\nexport const useUpcomingInterviews = () => {\n  return useQuery({\n    queryKey: queryKeys.interviews.upcoming(),\n    queryFn: () => interviewService.getUpcomingInterviews(),\n    staleTime: 1 * 60 * 1000, // 1 minute for time-sensitive data\n  });\n};\n\nexport const useTodaysInterviews = () => {\n  return useQuery({\n    queryKey: queryKeys.interviews.today(),\n    queryFn: () => interviewService.getTodaysInterviews(),\n    staleTime: 30 * 1000, // 30 seconds for very time-sensitive data\n    refetchInterval: 60 * 1000, // Refetch every minute\n  });\n};\n\nexport const useOverdueInterviews = () => {\n  return useQuery({\n    queryKey: queryKeys.interviews.overdue(),\n    queryFn: () => interviewService.getOverdueInterviews(),\n    staleTime: 1 * 60 * 1000,\n  });\n};\n\nexport const useInterviewsByOutcome = (outcome: string) => {\n  return useQuery({\n    queryKey: queryKeys.interviews.byOutcome(outcome),\n    queryFn: () => interviewService.getInterviewsByOutcome(outcome),\n    enabled: !!outcome,\n    staleTime: 5 * 60 * 1000,\n  });\n};\n\nexport const usePositionInterviewStats = (positionId: string) => {\n  return useQuery({\n    queryKey: queryKeys.interviews.stats(positionId),\n    queryFn: () => interviewService.getPositionInterviewStats(positionId),\n    enabled: !!positionId,\n    staleTime: 5 * 60 * 1000,\n  });\n};\n\n// Mutation hooks\nexport const useCreateInterview = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (data: CreateInterviewData) => interviewService.createInterview(data),\n    onMutate: async (newInterview) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ \n        queryKey: queryKeys.interviews.list(newInterview.position_id) \n      });\n\n      // Snapshot previous value\n      const previousInterviews = queryClient.getQueryData(\n        queryKeys.interviews.list(newInterview.position_id)\n      );\n\n      // Optimistically update\n      const tempInterview = {\n        id: `temp-${Date.now()}`,\n        ...newInterview,\n        created_at: new Date().toISOString(),\n        updated_at: new Date().toISOString(),\n      };\n\n      queryClient.setQueryData(\n        queryKeys.interviews.list(newInterview.position_id),\n        (old: Interview[] | undefined) => {\n          if (!old) return [tempInterview];\n          return [...old, tempInterview];\n        }\n      );\n\n      return { previousInterviews, positionId: newInterview.position_id };\n    },\n    onError: (_err, _newInterview, context) => {\n      // Rollback on error\n      if (context?.previousInterviews) {\n        queryClient.setQueryData(\n          queryKeys.interviews.list(context.positionId),\n          context.previousInterviews\n        );\n      }\n      toast.error('Failed to create interview');\n    },\n    onSuccess: (_data) => {\n      toast.success('Interview created successfully');\n    },\n    onSettled: (data, _error, variables) => {\n      // Always refetch after mutation\n      invalidateQueries.interview(data?.id || 'unknown', variables.position_id);\n    },\n  });\n};\n\nexport const useUpdateInterview = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, data }: { id: string; data: UpdateInterviewData }) =>\n      interviewService.updateInterview(id, data),\n    onMutate: async ({ id, data }) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: queryKeys.interviews.detail(id) });\n\n      // Snapshot previous value\n      const previousInterview = queryClient.getQueryData(queryKeys.interviews.detail(id));\n\n      // Get position ID for cache updates\n      const interview = previousInterview as Interview;\n      const positionId = interview?.position_id;\n\n      // Optimistically update\n      if (positionId) {\n        optimisticUpdates.updateInterview(id, positionId, data);\n      }\n\n      return { previousInterview, id, positionId };\n    },\n    onError: (_err, { id }, context) => {\n      // Rollback on error\n      if (context?.previousInterview) {\n        queryClient.setQueryData(queryKeys.interviews.detail(id), context.previousInterview);\n      }\n      toast.error('Failed to update interview');\n    },\n    onSuccess: () => {\n      toast.success('Interview updated successfully');\n    },\n    onSettled: (_data, _error, { id }, context) => {\n      // Always refetch after mutation\n      invalidateQueries.interview(id, context?.positionId);\n    },\n  });\n};\n\nexport const useUpdateInterviewField = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, field, value }: { id: string; field: string; value: any }) =>\n      interviewService.updateInterviewField(id, field, value),\n    onMutate: async ({ id, field, value }) => {\n      await queryClient.cancelQueries({ queryKey: queryKeys.interviews.detail(id) });\n      \n      const previousInterview = queryClient.getQueryData(queryKeys.interviews.detail(id)) as Interview;\n      const positionId = previousInterview?.position_id;\n\n      if (positionId) {\n        optimisticUpdates.updateInterview(id, positionId, { [field]: value });\n      }\n\n      return { previousInterview, id, positionId };\n    },\n    onError: (_err, { id }, context) => {\n      if (context?.previousInterview) {\n        queryClient.setQueryData(queryKeys.interviews.detail(id), context.previousInterview);\n      }\n      // Don't show toast for field updates to avoid spam\n    },\n    onSettled: (_data, _error, { id }, context) => {\n      invalidateQueries.interview(id, context?.positionId);\n    },\n  });\n};\n\nexport const useUpdateInterviewDate = () => {\n  const updateField = useUpdateInterviewField();\n  \n  return useMutation({\n    mutationFn: ({ id, scheduledDate }: { id: string; scheduledDate: string }) =>\n      updateField.mutateAsync({ id, field: 'scheduled_date', value: scheduledDate }),\n    onSuccess: () => {\n      toast.success('Interview date updated');\n    },\n    onError: () => {\n      toast.error('Failed to update interview date');\n    },\n  });\n};\n\nexport const useUpdateInterviewOutcome = () => {\n  const updateField = useUpdateInterviewField();\n  \n  return useMutation({\n    mutationFn: ({ id, outcome }: { id: string; outcome: string }) =>\n      updateField.mutateAsync({ id, field: 'outcome', value: outcome }),\n    onSuccess: () => {\n      toast.success('Interview outcome updated');\n    },\n    onError: () => {\n      toast.error('Failed to update interview outcome');\n    },\n  });\n};\n\nexport const useDeleteInterview = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (id: string) => interviewService.deleteInterview(id),\n    onMutate: async (id) => {\n      // Get interview data to find position ID\n      const interview = queryClient.getQueryData(queryKeys.interviews.detail(id)) as Interview;\n      const positionId = interview?.position_id;\n\n      if (positionId) {\n        await queryClient.cancelQueries({ queryKey: queryKeys.interviews.list(positionId) });\n        \n        const previousInterviews = queryClient.getQueryData(queryKeys.interviews.list(positionId));\n\n        // Optimistically remove\n        queryClient.setQueryData(\n          queryKeys.interviews.list(positionId),\n          (old: Interview[] | undefined) => {\n            if (!old) return old;\n            return old.filter(interview => interview.id !== id);\n          }\n        );\n\n        return { previousInterviews, positionId };\n      }\n\n      return { positionId };\n    },\n    onError: (_err, _id, context) => {\n      if (context?.previousInterviews && context?.positionId) {\n        queryClient.setQueryData(\n          queryKeys.interviews.list(context.positionId),\n          context.previousInterviews\n        );\n      }\n      toast.error('Failed to delete interview');\n    },\n    onSuccess: () => {\n      toast.success('Interview deleted successfully');\n    },\n    onSettled: (_data, _error, id, context) => {\n      invalidateQueries.interview(id, context?.positionId);\n    },\n  });\n};\n\nexport const useRescheduleInterview = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, newDate, notes }: { id: string; newDate: string; notes?: string }) =>\n      interviewService.rescheduleInterview(id, newDate, notes),\n    onSuccess: () => {\n      toast.success('Interview rescheduled successfully');\n    },\n    onError: () => {\n      toast.error('Failed to reschedule interview');\n    },\n    onSettled: (_data, _error, { id }) => {\n      const interview = queryClient.getQueryData(queryKeys.interviews.detail(id)) as Interview;\n      invalidateQueries.interview(id, interview?.position_id);\n    },\n  });\n};\n\nexport const useCancelInterview = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, reason }: { id: string; reason?: string }) =>\n      interviewService.cancelInterview(id, reason),\n    onSuccess: () => {\n      toast.success('Interview cancelled');\n    },\n    onError: () => {\n      toast.error('Failed to cancel interview');\n    },\n    onSettled: (_data, _error, { id }) => {\n      const interview = queryClient.getQueryData(queryKeys.interviews.detail(id)) as Interview;\n      invalidateQueries.interview(id, interview?.position_id);\n    },\n  });\n};\n\nexport const useCompleteInterview = () => {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ id, outcome, notes }: { id: string; outcome: InterviewOutcome.PASSED | InterviewOutcome.FAILED; notes?: string }) =>\n      interviewService.completeInterview(id, outcome, notes),\n    onSuccess: (_data, { outcome }) => {\n      toast.success(`Interview marked as ${outcome}`);\n    },\n    onError: () => {\n      toast.error('Failed to complete interview');\n    },\n    onSettled: (_data, _error, { id }) => {\n      const interview = queryClient.getQueryData(queryKeys.interviews.detail(id)) as Interview;\n      invalidateQueries.interview(id, interview?.position_id);\n    },\n  });\n};\n\nexport const useBulkUpdateInterviews = () => {\n  return useMutation({\n    mutationFn: (updates: Array<{ id: string; data: Partial<UpdateInterviewData> }>) =>\n      interviewService.bulkUpdateInterviews(updates),\n    onSuccess: (data) => {\n      toast.success(`${data.length} interviews updated successfully`);\n    },\n    onError: () => {\n      toast.error('Failed to update interviews');\n    },\n    onSettled: () => {\n      // Invalidate all interview queries since we don't know which positions were affected\n      invalidateQueries.interviews();\n    },\n  });\n};\n\n// Combined hooks for common patterns\nexport const useInterviewsWithStats = (positionId: string) => {\n  const interviewsQuery = useInterviews(positionId);\n  const statsQuery = usePositionInterviewStats(positionId);\n\n  return {\n    interviews: interviewsQuery,\n    stats: statsQuery,\n    isLoading: interviewsQuery.isLoading || statsQuery.isLoading,\n    error: interviewsQuery.error || statsQuery.error,\n  };\n};\n\nexport const useInterviewDashboard = () => {\n  const upcomingQuery = useUpcomingInterviews();\n  const todaysQuery = useTodaysInterviews();\n  const overdueQuery = useOverdueInterviews();\n\n  return {\n    upcoming: upcomingQuery,\n    today: todaysQuery,\n    overdue: overdueQuery,\n    isLoading: upcomingQuery.isLoading || todaysQuery.isLoading || overdueQuery.isLoading,\n    error: upcomingQuery.error || todaysQuery.error || overdueQuery.error,\n  };\n};"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,SAASA,QAAQ,EAAEC,WAAW,EAAEC,cAAc,QAAQ,uBAAuB;AAC7E,SAASC,KAAK,QAAQ,iBAAiB;AACvC,SAASC,gBAAgB,QAAQ,aAAa;AAC9C,SAASC,SAAS,EAAEC,iBAAiB,EAAEC,iBAAiB,QAAQ,oBAAoB;AAQpF;AACA,OAAO,MAAMC,aAAa,GAAIC,UAAkB,IAAK;EAAAC,EAAA;EACnD,OAAOV,QAAQ,CAAC;IACdW,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAACC,IAAI,CAACJ,UAAU,CAAC;IAC/CK,OAAO,EAAEA,CAAA,KAAMV,gBAAgB,CAACW,aAAa,CAACN,UAAU,CAAC;IACzDO,OAAO,EAAE,CAAC,CAACP,UAAU;IACrBQ,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI,CAAE;EAC5B,CAAC,CAAC;AACJ,CAAC;AAACP,EAAA,CAPWF,aAAa;EAAA,QACjBR,QAAQ;AAAA;AAQjB,OAAO,MAAMkB,YAAY,GAAIC,EAAU,IAAK;EAAAC,GAAA;EAC1C,OAAOpB,QAAQ,CAAC;IACdW,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE,CAAC;IACzCL,OAAO,EAAEA,CAAA,KAAMV,gBAAgB,CAACkB,YAAY,CAACH,EAAE,CAAC;IAChDH,OAAO,EAAE,CAAC,CAACG,EAAE;IACbF,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG;EACtB,CAAC,CAAC;AACJ,CAAC;AAACG,GAAA,CAPWF,YAAY;EAAA,QAChBlB,QAAQ;AAAA;AAQjB,OAAO,MAAMuB,oBAAoB,GAAGA,CAAA,KAAM;EAAAC,GAAA;EACxC,OAAOxB,QAAQ,CAAC;IACdW,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAACa,GAAG;IAClCX,OAAO,EAAEA,CAAA,KAAMV,gBAAgB,CAACsB,oBAAoB,CAAC,CAAC;IACtDT,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG;EACtB,CAAC,CAAC;AACJ,CAAC;AAACO,GAAA,CANWD,oBAAoB;EAAA,QACxBvB,QAAQ;AAAA;AAOjB,OAAO,MAAM2B,qBAAqB,GAAGA,CAAA,KAAM;EAAAC,GAAA;EACzC,OAAO5B,QAAQ,CAAC;IACdW,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAACiB,QAAQ,CAAC,CAAC;IACzCf,OAAO,EAAEA,CAAA,KAAMV,gBAAgB,CAAC0B,qBAAqB,CAAC,CAAC;IACvDb,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG,IAAI,CAAE;EAC5B,CAAC,CAAC;AACJ,CAAC;AAACW,GAAA,CANWD,qBAAqB;EAAA,QACzB3B,QAAQ;AAAA;AAOjB,OAAO,MAAM+B,mBAAmB,GAAGA,CAAA,KAAM;EAAAC,GAAA;EACvC,OAAOhC,QAAQ,CAAC;IACdW,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAACqB,KAAK,CAAC,CAAC;IACtCnB,OAAO,EAAEA,CAAA,KAAMV,gBAAgB,CAAC8B,mBAAmB,CAAC,CAAC;IACrDjB,SAAS,EAAE,EAAE,GAAG,IAAI;IAAE;IACtBkB,eAAe,EAAE,EAAE,GAAG,IAAI,CAAE;EAC9B,CAAC,CAAC;AACJ,CAAC;AAACH,GAAA,CAPWD,mBAAmB;EAAA,QACvB/B,QAAQ;AAAA;AAQjB,OAAO,MAAMoC,oBAAoB,GAAGA,CAAA,KAAM;EAAAC,GAAA;EACxC,OAAOrC,QAAQ,CAAC;IACdW,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAAC0B,OAAO,CAAC,CAAC;IACxCxB,OAAO,EAAEA,CAAA,KAAMV,gBAAgB,CAACmC,oBAAoB,CAAC,CAAC;IACtDtB,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG;EACtB,CAAC,CAAC;AACJ,CAAC;AAACoB,GAAA,CANWD,oBAAoB;EAAA,QACxBpC,QAAQ;AAAA;AAOjB,OAAO,MAAMwC,sBAAsB,GAAIC,OAAe,IAAK;EAAAC,GAAA;EACzD,OAAO1C,QAAQ,CAAC;IACdW,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAAC+B,SAAS,CAACF,OAAO,CAAC;IACjD3B,OAAO,EAAEA,CAAA,KAAMV,gBAAgB,CAACwC,sBAAsB,CAACH,OAAO,CAAC;IAC/DzB,OAAO,EAAE,CAAC,CAACyB,OAAO;IAClBxB,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG;EACtB,CAAC,CAAC;AACJ,CAAC;AAACyB,GAAA,CAPWF,sBAAsB;EAAA,QAC1BxC,QAAQ;AAAA;AAQjB,OAAO,MAAM6C,yBAAyB,GAAIpC,UAAkB,IAAK;EAAAqC,GAAA;EAC/D,OAAO9C,QAAQ,CAAC;IACdW,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAACmC,KAAK,CAACtC,UAAU,CAAC;IAChDK,OAAO,EAAEA,CAAA,KAAMV,gBAAgB,CAAC4C,yBAAyB,CAACvC,UAAU,CAAC;IACrEO,OAAO,EAAE,CAAC,CAACP,UAAU;IACrBQ,SAAS,EAAE,CAAC,GAAG,EAAE,GAAG;EACtB,CAAC,CAAC;AACJ,CAAC;;AAED;AAAA6B,GAAA,CATaD,yBAAyB;EAAA,QAC7B7C,QAAQ;AAAA;AASjB,OAAO,MAAMiD,kBAAkB,GAAGA,CAAA,KAAM;EAAAC,GAAA;EACtC,MAAMC,WAAW,GAAGjD,cAAc,CAAC,CAAC;EAEpC,OAAOD,WAAW,CAAC;IACjBmD,UAAU,EAAGC,IAAyB,IAAKjD,gBAAgB,CAACkD,eAAe,CAACD,IAAI,CAAC;IACjFE,QAAQ,EAAE,MAAOC,YAAY,IAAK;MAChC;MACA,MAAML,WAAW,CAACM,aAAa,CAAC;QAC9B9C,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAACC,IAAI,CAAC2C,YAAY,CAACE,WAAW;MAC9D,CAAC,CAAC;;MAEF;MACA,MAAMC,kBAAkB,GAAGR,WAAW,CAACS,YAAY,CACjDvD,SAAS,CAACO,UAAU,CAACC,IAAI,CAAC2C,YAAY,CAACE,WAAW,CACpD,CAAC;;MAED;MACA,MAAMG,aAAa,GAAG;QACpB1C,EAAE,EAAE,QAAQ2C,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE;QACxB,GAAGP,YAAY;QACfQ,UAAU,EAAE,IAAIF,IAAI,CAAC,CAAC,CAACG,WAAW,CAAC,CAAC;QACpCC,UAAU,EAAE,IAAIJ,IAAI,CAAC,CAAC,CAACG,WAAW,CAAC;MACrC,CAAC;MAEDd,WAAW,CAACgB,YAAY,CACtB9D,SAAS,CAACO,UAAU,CAACC,IAAI,CAAC2C,YAAY,CAACE,WAAW,CAAC,EAClDU,GAA4B,IAAK;QAChC,IAAI,CAACA,GAAG,EAAE,OAAO,CAACP,aAAa,CAAC;QAChC,OAAO,CAAC,GAAGO,GAAG,EAAEP,aAAa,CAAC;MAChC,CACF,CAAC;MAED,OAAO;QAAEF,kBAAkB;QAAElD,UAAU,EAAE+C,YAAY,CAACE;MAAY,CAAC;IACrE,CAAC;IACDW,OAAO,EAAEA,CAACC,IAAI,EAAEC,aAAa,EAAEC,OAAO,KAAK;MACzC;MACA,IAAIA,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEb,kBAAkB,EAAE;QAC/BR,WAAW,CAACgB,YAAY,CACtB9D,SAAS,CAACO,UAAU,CAACC,IAAI,CAAC2D,OAAO,CAAC/D,UAAU,CAAC,EAC7C+D,OAAO,CAACb,kBACV,CAAC;MACH;MACAxD,KAAK,CAACsE,KAAK,CAAC,4BAA4B,CAAC;IAC3C,CAAC;IACDC,SAAS,EAAGC,KAAK,IAAK;MACpBxE,KAAK,CAACyE,OAAO,CAAC,gCAAgC,CAAC;IACjD,CAAC;IACDC,SAAS,EAAEA,CAACxB,IAAI,EAAEyB,MAAM,EAAEC,SAAS,KAAK;MACtC;MACAzE,iBAAiB,CAAC0E,SAAS,CAAC,CAAA3B,IAAI,aAAJA,IAAI,uBAAJA,IAAI,CAAElC,EAAE,KAAI,SAAS,EAAE4D,SAAS,CAACrB,WAAW,CAAC;IAC3E;EACF,CAAC,CAAC;AACJ,CAAC;AAACR,GAAA,CApDWD,kBAAkB;EAAA,QACT/C,cAAc,EAE3BD,WAAW;AAAA;AAmDpB,OAAO,MAAMgF,kBAAkB,GAAGA,CAAA,KAAM;EAAAC,GAAA;EACtC,MAAM/B,WAAW,GAAGjD,cAAc,CAAC,CAAC;EAEpC,OAAOD,WAAW,CAAC;IACjBmD,UAAU,EAAEA,CAAC;MAAEjC,EAAE;MAAEkC;IAAgD,CAAC,KAClEjD,gBAAgB,CAAC+E,eAAe,CAAChE,EAAE,EAAEkC,IAAI,CAAC;IAC5CE,QAAQ,EAAE,MAAAA,CAAO;MAAEpC,EAAE;MAAEkC;IAAK,CAAC,KAAK;MAChC;MACA,MAAMF,WAAW,CAACM,aAAa,CAAC;QAAE9C,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE;MAAE,CAAC,CAAC;;MAE9E;MACA,MAAMiE,iBAAiB,GAAGjC,WAAW,CAACS,YAAY,CAACvD,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE,CAAC,CAAC;;MAEnF;MACA,MAAM6D,SAAS,GAAGI,iBAA8B;MAChD,MAAM3E,UAAU,GAAGuE,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEtB,WAAW;;MAEzC;MACA,IAAIjD,UAAU,EAAE;QACdF,iBAAiB,CAAC4E,eAAe,CAAChE,EAAE,EAAEV,UAAU,EAAE4C,IAAI,CAAC;MACzD;MAEA,OAAO;QAAE+B,iBAAiB;QAAEjE,EAAE;QAAEV;MAAW,CAAC;IAC9C,CAAC;IACD4D,OAAO,EAAEA,CAACC,IAAI,EAAE;MAAEnD;IAAG,CAAC,EAAEqD,OAAO,KAAK;MAClC;MACA,IAAIA,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEY,iBAAiB,EAAE;QAC9BjC,WAAW,CAACgB,YAAY,CAAC9D,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE,CAAC,EAAEqD,OAAO,CAACY,iBAAiB,CAAC;MACtF;MACAjF,KAAK,CAACsE,KAAK,CAAC,4BAA4B,CAAC;IAC3C,CAAC;IACDC,SAAS,EAAEA,CAAA,KAAM;MACfvE,KAAK,CAACyE,OAAO,CAAC,gCAAgC,CAAC;IACjD,CAAC;IACDC,SAAS,EAAEA,CAACF,KAAK,EAAEG,MAAM,EAAE;MAAE3D;IAAG,CAAC,EAAEqD,OAAO,KAAK;MAC7C;MACAlE,iBAAiB,CAAC0E,SAAS,CAAC7D,EAAE,EAAEqD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE/D,UAAU,CAAC;IACtD;EACF,CAAC,CAAC;AACJ,CAAC;AAACyE,GAAA,CAvCWD,kBAAkB;EAAA,QACT/E,cAAc,EAE3BD,WAAW;AAAA;AAsCpB,OAAO,MAAMoF,uBAAuB,GAAGA,CAAA,KAAM;EAAAC,GAAA;EAC3C,MAAMnC,WAAW,GAAGjD,cAAc,CAAC,CAAC;EAEpC,OAAOD,WAAW,CAAC;IACjBmD,UAAU,EAAEA,CAAC;MAAEjC,EAAE;MAAEoE,KAAK;MAAEC;IAAiD,CAAC,KAC1EpF,gBAAgB,CAACqF,oBAAoB,CAACtE,EAAE,EAAEoE,KAAK,EAAEC,KAAK,CAAC;IACzDjC,QAAQ,EAAE,MAAAA,CAAO;MAAEpC,EAAE;MAAEoE,KAAK;MAAEC;IAAM,CAAC,KAAK;MACxC,MAAMrC,WAAW,CAACM,aAAa,CAAC;QAAE9C,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE;MAAE,CAAC,CAAC;MAE9E,MAAMiE,iBAAiB,GAAGjC,WAAW,CAACS,YAAY,CAACvD,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE,CAAC,CAAc;MAChG,MAAMV,UAAU,GAAG2E,iBAAiB,aAAjBA,iBAAiB,uBAAjBA,iBAAiB,CAAE1B,WAAW;MAEjD,IAAIjD,UAAU,EAAE;QACdF,iBAAiB,CAAC4E,eAAe,CAAChE,EAAE,EAAEV,UAAU,EAAE;UAAE,CAAC8E,KAAK,GAAGC;QAAM,CAAC,CAAC;MACvE;MAEA,OAAO;QAAEJ,iBAAiB;QAAEjE,EAAE;QAAEV;MAAW,CAAC;IAC9C,CAAC;IACD4D,OAAO,EAAEA,CAACC,IAAI,EAAE;MAAEnD;IAAG,CAAC,EAAEqD,OAAO,KAAK;MAClC,IAAIA,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEY,iBAAiB,EAAE;QAC9BjC,WAAW,CAACgB,YAAY,CAAC9D,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE,CAAC,EAAEqD,OAAO,CAACY,iBAAiB,CAAC;MACtF;MACA;IACF,CAAC;IACDP,SAAS,EAAEA,CAACF,KAAK,EAAEG,MAAM,EAAE;MAAE3D;IAAG,CAAC,EAAEqD,OAAO,KAAK;MAC7ClE,iBAAiB,CAAC0E,SAAS,CAAC7D,EAAE,EAAEqD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE/D,UAAU,CAAC;IACtD;EACF,CAAC,CAAC;AACJ,CAAC;AAAC6E,GAAA,CA5BWD,uBAAuB;EAAA,QACdnF,cAAc,EAE3BD,WAAW;AAAA;AA2BpB,OAAO,MAAMyF,sBAAsB,GAAGA,CAAA,KAAM;EAAAC,IAAA;EAC1C,MAAMC,WAAW,GAAGP,uBAAuB,CAAC,CAAC;EAE7C,OAAOpF,WAAW,CAAC;IACjBmD,UAAU,EAAEA,CAAC;MAAEjC,EAAE;MAAE0E;IAAqD,CAAC,KACvED,WAAW,CAACE,WAAW,CAAC;MAAE3E,EAAE;MAAEoE,KAAK,EAAE,gBAAgB;MAAEC,KAAK,EAAEK;IAAc,CAAC,CAAC;IAChFnB,SAAS,EAAEA,CAAA,KAAM;MACfvE,KAAK,CAACyE,OAAO,CAAC,wBAAwB,CAAC;IACzC,CAAC;IACDP,OAAO,EAAEA,CAAA,KAAM;MACblE,KAAK,CAACsE,KAAK,CAAC,iCAAiC,CAAC;IAChD;EACF,CAAC,CAAC;AACJ,CAAC;AAACkB,IAAA,CAbWD,sBAAsB;EAAA,QACbL,uBAAuB,EAEpCpF,WAAW;AAAA;AAYpB,OAAO,MAAM8F,yBAAyB,GAAGA,CAAA,KAAM;EAAAC,IAAA;EAC7C,MAAMJ,WAAW,GAAGP,uBAAuB,CAAC,CAAC;EAE7C,OAAOpF,WAAW,CAAC;IACjBmD,UAAU,EAAEA,CAAC;MAAEjC,EAAE;MAAEsB;IAAyC,CAAC,KAC3DmD,WAAW,CAACE,WAAW,CAAC;MAAE3E,EAAE;MAAEoE,KAAK,EAAE,SAAS;MAAEC,KAAK,EAAE/C;IAAQ,CAAC,CAAC;IACnEiC,SAAS,EAAEA,CAAA,KAAM;MACfvE,KAAK,CAACyE,OAAO,CAAC,2BAA2B,CAAC;IAC5C,CAAC;IACDP,OAAO,EAAEA,CAAA,KAAM;MACblE,KAAK,CAACsE,KAAK,CAAC,oCAAoC,CAAC;IACnD;EACF,CAAC,CAAC;AACJ,CAAC;AAACuB,IAAA,CAbWD,yBAAyB;EAAA,QAChBV,uBAAuB,EAEpCpF,WAAW;AAAA;AAYpB,OAAO,MAAMgG,kBAAkB,GAAGA,CAAA,KAAM;EAAAC,IAAA;EACtC,MAAM/C,WAAW,GAAGjD,cAAc,CAAC,CAAC;EAEpC,OAAOD,WAAW,CAAC;IACjBmD,UAAU,EAAGjC,EAAU,IAAKf,gBAAgB,CAAC+F,eAAe,CAAChF,EAAE,CAAC;IAChEoC,QAAQ,EAAE,MAAOpC,EAAE,IAAK;MACtB;MACA,MAAM6D,SAAS,GAAG7B,WAAW,CAACS,YAAY,CAACvD,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE,CAAC,CAAc;MACxF,MAAMV,UAAU,GAAGuE,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEtB,WAAW;MAEzC,IAAIjD,UAAU,EAAE;QACd,MAAM0C,WAAW,CAACM,aAAa,CAAC;UAAE9C,QAAQ,EAAEN,SAAS,CAACO,UAAU,CAACC,IAAI,CAACJ,UAAU;QAAE,CAAC,CAAC;QAEpF,MAAMkD,kBAAkB,GAAGR,WAAW,CAACS,YAAY,CAACvD,SAAS,CAACO,UAAU,CAACC,IAAI,CAACJ,UAAU,CAAC,CAAC;;QAE1F;QACA0C,WAAW,CAACgB,YAAY,CACtB9D,SAAS,CAACO,UAAU,CAACC,IAAI,CAACJ,UAAU,CAAC,EACpC2D,GAA4B,IAAK;UAChC,IAAI,CAACA,GAAG,EAAE,OAAOA,GAAG;UACpB,OAAOA,GAAG,CAACgC,MAAM,CAACpB,SAAS,IAAIA,SAAS,CAAC7D,EAAE,KAAKA,EAAE,CAAC;QACrD,CACF,CAAC;QAED,OAAO;UAAEwC,kBAAkB;UAAElD;QAAW,CAAC;MAC3C;MAEA,OAAO;QAAEA;MAAW,CAAC;IACvB,CAAC;IACD4D,OAAO,EAAEA,CAACC,IAAI,EAAE+B,GAAG,EAAE7B,OAAO,KAAK;MAC/B,IAAIA,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAEb,kBAAkB,IAAIa,OAAO,aAAPA,OAAO,eAAPA,OAAO,CAAE/D,UAAU,EAAE;QACtD0C,WAAW,CAACgB,YAAY,CACtB9D,SAAS,CAACO,UAAU,CAACC,IAAI,CAAC2D,OAAO,CAAC/D,UAAU,CAAC,EAC7C+D,OAAO,CAACb,kBACV,CAAC;MACH;MACAxD,KAAK,CAACsE,KAAK,CAAC,4BAA4B,CAAC;IAC3C,CAAC;IACDC,SAAS,EAAEA,CAAA,KAAM;MACfvE,KAAK,CAACyE,OAAO,CAAC,gCAAgC,CAAC;IACjD,CAAC;IACDC,SAAS,EAAEA,CAACF,KAAK,EAAEG,MAAM,EAAE3D,EAAE,EAAEqD,OAAO,KAAK;MACzClE,iBAAiB,CAAC0E,SAAS,CAAC7D,EAAE,EAAEqD,OAAO,aAAPA,OAAO,uBAAPA,OAAO,CAAE/D,UAAU,CAAC;IACtD;EACF,CAAC,CAAC;AACJ,CAAC;AAACyF,IAAA,CA7CWD,kBAAkB;EAAA,QACT/F,cAAc,EAE3BD,WAAW;AAAA;AA4CpB,OAAO,MAAMqG,sBAAsB,GAAGA,CAAA,KAAM;EAAAC,IAAA;EAC1C,MAAMpD,WAAW,GAAGjD,cAAc,CAAC,CAAC;EAEpC,OAAOD,WAAW,CAAC;IACjBmD,UAAU,EAAEA,CAAC;MAAEjC,EAAE;MAAEqF,OAAO;MAAEC;IAAuD,CAAC,KAClFrG,gBAAgB,CAACsG,mBAAmB,CAACvF,EAAE,EAAEqF,OAAO,EAAEC,KAAK,CAAC;IAC1D/B,SAAS,EAAEA,CAAA,KAAM;MACfvE,KAAK,CAACyE,OAAO,CAAC,oCAAoC,CAAC;IACrD,CAAC;IACDP,OAAO,EAAEA,CAAA,KAAM;MACblE,KAAK,CAACsE,KAAK,CAAC,gCAAgC,CAAC;IAC/C,CAAC;IACDI,SAAS,EAAEA,CAACF,KAAK,EAAEG,MAAM,EAAE;MAAE3D;IAAG,CAAC,KAAK;MACpC,MAAM6D,SAAS,GAAG7B,WAAW,CAACS,YAAY,CAACvD,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE,CAAC,CAAc;MACxFb,iBAAiB,CAAC0E,SAAS,CAAC7D,EAAE,EAAE6D,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEtB,WAAW,CAAC;IACzD;EACF,CAAC,CAAC;AACJ,CAAC;AAAC6C,IAAA,CAjBWD,sBAAsB;EAAA,QACbpG,cAAc,EAE3BD,WAAW;AAAA;AAgBpB,OAAO,MAAM0G,kBAAkB,GAAGA,CAAA,KAAM;EAAAC,IAAA;EACtC,MAAMzD,WAAW,GAAGjD,cAAc,CAAC,CAAC;EAEpC,OAAOD,WAAW,CAAC;IACjBmD,UAAU,EAAEA,CAAC;MAAEjC,EAAE;MAAE0F;IAAwC,CAAC,KAC1DzG,gBAAgB,CAAC0G,eAAe,CAAC3F,EAAE,EAAE0F,MAAM,CAAC;IAC9CnC,SAAS,EAAEA,CAAA,KAAM;MACfvE,KAAK,CAACyE,OAAO,CAAC,qBAAqB,CAAC;IACtC,CAAC;IACDP,OAAO,EAAEA,CAAA,KAAM;MACblE,KAAK,CAACsE,KAAK,CAAC,4BAA4B,CAAC;IAC3C,CAAC;IACDI,SAAS,EAAEA,CAACF,KAAK,EAAEG,MAAM,EAAE;MAAE3D;IAAG,CAAC,KAAK;MACpC,MAAM6D,SAAS,GAAG7B,WAAW,CAACS,YAAY,CAACvD,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE,CAAC,CAAc;MACxFb,iBAAiB,CAAC0E,SAAS,CAAC7D,EAAE,EAAE6D,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEtB,WAAW,CAAC;IACzD;EACF,CAAC,CAAC;AACJ,CAAC;AAACkD,IAAA,CAjBWD,kBAAkB;EAAA,QACTzG,cAAc,EAE3BD,WAAW;AAAA;AAgBpB,OAAO,MAAM8G,oBAAoB,GAAGA,CAAA,KAAM;EAAAC,IAAA;EACxC,MAAM7D,WAAW,GAAGjD,cAAc,CAAC,CAAC;EAEpC,OAAOD,WAAW,CAAC;IACjBmD,UAAU,EAAEA,CAAC;MAAEjC,EAAE;MAAEsB,OAAO;MAAEgE;IAAkG,CAAC,KAC7HrG,gBAAgB,CAAC6G,iBAAiB,CAAC9F,EAAE,EAAEsB,OAAO,EAAEgE,KAAK,CAAC;IACxD/B,SAAS,EAAEA,CAACC,KAAK,EAAE;MAAElC;IAAQ,CAAC,KAAK;MACjCtC,KAAK,CAACyE,OAAO,CAAC,uBAAuBnC,OAAO,EAAE,CAAC;IACjD,CAAC;IACD4B,OAAO,EAAEA,CAAA,KAAM;MACblE,KAAK,CAACsE,KAAK,CAAC,8BAA8B,CAAC;IAC7C,CAAC;IACDI,SAAS,EAAEA,CAACF,KAAK,EAAEG,MAAM,EAAE;MAAE3D;IAAG,CAAC,KAAK;MACpC,MAAM6D,SAAS,GAAG7B,WAAW,CAACS,YAAY,CAACvD,SAAS,CAACO,UAAU,CAACS,MAAM,CAACF,EAAE,CAAC,CAAc;MACxFb,iBAAiB,CAAC0E,SAAS,CAAC7D,EAAE,EAAE6D,SAAS,aAATA,SAAS,uBAATA,SAAS,CAAEtB,WAAW,CAAC;IACzD;EACF,CAAC,CAAC;AACJ,CAAC;AAACsD,IAAA,CAjBWD,oBAAoB;EAAA,QACX7G,cAAc,EAE3BD,WAAW;AAAA;AAgBpB,OAAO,MAAMiH,uBAAuB,GAAGA,CAAA,KAAM;EAAAC,IAAA;EAC3C,OAAOlH,WAAW,CAAC;IACjBmD,UAAU,EAAGgE,OAAkE,IAC7EhH,gBAAgB,CAACiH,oBAAoB,CAACD,OAAO,CAAC;IAChD1C,SAAS,EAAGrB,IAAI,IAAK;MACnBlD,KAAK,CAACyE,OAAO,CAAC,GAAGvB,IAAI,CAACiE,MAAM,kCAAkC,CAAC;IACjE,CAAC;IACDjD,OAAO,EAAEA,CAAA,KAAM;MACblE,KAAK,CAACsE,KAAK,CAAC,6BAA6B,CAAC;IAC5C,CAAC;IACDI,SAAS,EAAEA,CAAA,KAAM;MACf;MACAvE,iBAAiB,CAACM,UAAU,CAAC,CAAC;IAChC;EACF,CAAC,CAAC;AACJ,CAAC;;AAED;AAAAuG,IAAA,CAjBaD,uBAAuB;EAAA,QAC3BjH,WAAW;AAAA;AAiBpB,OAAO,MAAMsH,sBAAsB,GAAI9G,UAAkB,IAAK;EAAA+G,IAAA;EAC5D,MAAMC,eAAe,GAAGjH,aAAa,CAACC,UAAU,CAAC;EACjD,MAAMiH,UAAU,GAAG7E,yBAAyB,CAACpC,UAAU,CAAC;EAExD,OAAO;IACLG,UAAU,EAAE6G,eAAe;IAC3B1E,KAAK,EAAE2E,UAAU;IACjBC,SAAS,EAAEF,eAAe,CAACE,SAAS,IAAID,UAAU,CAACC,SAAS;IAC5DlD,KAAK,EAAEgD,eAAe,CAAChD,KAAK,IAAIiD,UAAU,CAACjD;EAC7C,CAAC;AACH,CAAC;AAAC+C,IAAA,CAVWD,sBAAsB;EAAA,QACT/G,aAAa,EAClBqC,yBAAyB;AAAA;AAU9C,OAAO,MAAM+E,qBAAqB,GAAGA,CAAA,KAAM;EAAAC,IAAA;EACzC,MAAMC,aAAa,GAAGnG,qBAAqB,CAAC,CAAC;EAC7C,MAAMoG,WAAW,GAAGhG,mBAAmB,CAAC,CAAC;EACzC,MAAMiG,YAAY,GAAG5F,oBAAoB,CAAC,CAAC;EAE3C,OAAO;IACLP,QAAQ,EAAEiG,aAAa;IACvB7F,KAAK,EAAE8F,WAAW;IAClBzF,OAAO,EAAE0F,YAAY;IACrBL,SAAS,EAAEG,aAAa,CAACH,SAAS,IAAII,WAAW,CAACJ,SAAS,IAAIK,YAAY,CAACL,SAAS;IACrFlD,KAAK,EAAEqD,aAAa,CAACrD,KAAK,IAAIsD,WAAW,CAACtD,KAAK,IAAIuD,YAAY,CAACvD;EAClE,CAAC;AACH,CAAC;AAACoD,IAAA,CAZWD,qBAAqB;EAAA,QACVjG,qBAAqB,EACvBI,mBAAmB,EAClBK,oBAAoB;AAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}